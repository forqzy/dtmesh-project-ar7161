Index: upnp_wps_ctrlpt_win.c
===================================================================
--- upnp_wps_ctrlpt_win.c	(revision 0)
+++ upnp_wps_ctrlpt_win.c	(revision 2)
@@ -0,0 +1,1603 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_ctrlpt_win.c
+//  Description: EAP-WPS UPnP control-point source for Microsoft Windows
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef COBJMACROS
+#define COBJMACROS
+#endif /* COBJMACROS */
+
+#include "includes.h"
+
+#include "common.h"
+#include "upnp_wps_ctrlpt.h"
+
+#include <upnp.h>
+
+static const wchar_t *wps_device_type = L"urn:schemas-wifialliance-org:device:WFADevice:1";
+static const wchar_t *wps_service_type = L"urn:schemas-wifialliance-org:service:WFAWLANConfig:1";
+static const wchar_t *wps_service_id = L"urn:wifialliance-org:serviceId:WFAWLANConfig1";
+
+struct wps_device;
+
+struct upnp_service_callback {
+	IUPnPServiceCallbackVtbl *lpVtbl;
+	struct upnp_wps_ctrlpt_sm *sm;
+	struct wps_device *device;
+	u32 ref_count;
+};
+
+struct wps_device {
+	IUPnPDevice *handle;
+	char *friendly_name;
+	char *manufacturer;
+	char *manufacturer_url;
+	char *model_desc;
+	char *model_name;
+	char *model_number;
+	char *model_url;
+	char *serial_number;
+	char *udn;
+	char *upc;
+	char *pres_url;
+	char *control_url;
+	IUPnPServices *services;
+	IUPnPService *service;
+	struct upnp_service_callback *service_callback;
+};
+
+struct wps_device_node {
+	struct wps_device device;
+	struct wps_device_node *next;
+};
+
+struct upnp_device_finder_callback {
+	struct IUPnPDeviceFinderCallbackVtbl *lpVtbl;
+	struct upnp_wps_ctrlpt_sm *sm;
+	u32 ref_count;
+};
+
+struct upnp_wps_ctrlpt_sm {
+	struct upnp_wps_ctrlpt_ctx *ctx;
+	void *priv;
+	int co_initialized;
+	int started;
+	IUPnPDeviceFinder *device_finder;
+	u32 async_finder;
+	struct upnp_device_finder_callback *device_finder_callback;
+	struct wps_device_node *device_list;
+	HANDLE mutex_devlist;
+};
+
+static int upnp_wps_ctrlpt_add_device(struct upnp_wps_ctrlpt_sm *sm, IUPnPDevice *device);
+static int upnp_wps_ctrlpt_remove_device(struct upnp_wps_ctrlpt_sm *sm, char *udn);
+static void upnp_wps_ctrlpt_handle_event_received(struct upnp_wps_ctrlpt_sm *sm, struct wps_device *device, char *var_name,
+												  void *value, size_t value_length);
+
+static int
+convert_bstr_to_char(BSTR bstr, char **chr)
+{
+	int ret = -1;
+	size_t len;
+
+	do {
+		if (!bstr || !chr)
+			break;
+		*chr = 0;
+
+		len = WideCharToMultiByte(CP_ACP, 0, (OLECHAR*)bstr, -1, 0, 0, 0, 0);
+
+		*chr = wpa_zalloc(len + 1);
+		if (!*chr)
+			break;
+
+		if (!WideCharToMultiByte(CP_ACP, 0, (OLECHAR*)bstr, -1, *chr, len, 0, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && !chr && !*chr) {
+		os_free(*chr);
+		*chr = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+convert_char_to_bstr(char *chr, BSTR *bstr)
+{
+	int ret = -1;
+	size_t len;
+	wchar_t *wstr = 0;
+
+	do {
+		if (!bstr || !chr)
+			break;
+		*bstr = 0;
+
+		len = os_strlen(chr);
+
+		wstr = wpa_zalloc((len + 1) * sizeof(*wstr));
+		if (!wstr)
+			break;
+
+		_snwprintf(wstr, len + 1, L"%S", chr);
+		*bstr = SysAllocString(wstr);
+		if (!*bstr)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && !bstr && !*bstr) {
+		SysFreeString(*bstr);
+		*bstr = 0;
+	}
+
+	if (wstr)
+		os_free(wstr);
+
+	return ret;
+}
+
+
+static HRESULT STDMETHODCALLTYPE
+service_callback_query_interface(IUPnPServiceCallback *This, REFIID iid, LPVOID* ppvObject)
+{
+	HRESULT hr = S_OK;
+	
+	do {
+		if(!ppvObject) {
+			hr = E_POINTER;
+			break;
+		}
+		*ppvObject = NULL;
+	
+		if(!IsEqualIID(iid, &IID_IUnknown) && !IsEqualIID(iid, &IID_IUPnPServiceCallback)) {
+			hr = E_NOINTERFACE;
+			break;
+		}
+
+		*ppvObject = This;
+		IUPnPServiceCallback_AddRef(This);
+	} while (0);
+	
+	return hr;
+}
+
+static ULONG STDMETHODCALLTYPE
+service_callback_add_ref(IUPnPServiceCallback *This)
+{
+	struct upnp_service_callback *service_callback =
+			(struct upnp_service_callback *)This;
+	return InterlockedIncrement(&service_callback->ref_count);
+}
+
+static ULONG STDMETHODCALLTYPE
+service_callback_release(IUPnPServiceCallback * This)
+{
+	struct upnp_service_callback *service_callback =
+			(struct upnp_service_callback *)This;
+	ULONG ref_count = 0;
+
+	do {
+		if (!service_callback->ref_count)
+			break;
+
+		(void)InterlockedDecrement(&service_callback->ref_count);
+		ref_count = service_callback->ref_count;
+		if (!service_callback->ref_count) {
+			os_free(service_callback->lpVtbl);
+			os_free(service_callback);
+		}
+	} while (0);
+	return ref_count;
+}
+
+static HRESULT STDMETHODCALLTYPE
+service_callback_state_variable_changed(IUPnPServiceCallback *This,
+										IUPnPService *pus,
+										LPCWSTR pcwszStateVarName,
+										VARIANT vaValue)
+{
+	HRESULT hr = S_FALSE;
+	struct upnp_service_callback *service_callback =
+			(struct upnp_service_callback *)This;
+	struct upnp_wps_ctrlpt_sm *sm = service_callback->sm;
+	struct wps_device_node *node;
+	struct wps_device *device;
+	BSTR bstrSid = 0, bstrSid2 = 0, bstrStid = 0, bstrStid2 = 0;
+	char *csid = 0, *csid2 = 0, *cstid = 0, *cstid2 = 0;
+	char var_name[0x100];
+	void *value = 0;
+	size_t value_length = 0, ubound, lbound;
+	char *cvalue = 0;
+
+	WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+	do {
+
+		if (!pus)
+			break;
+
+		if (!SUCCEEDED(IUPnPService_get_Id(pus, &bstrSid)))
+			break;
+
+		if (convert_bstr_to_char(bstrSid, &csid))
+			break;
+
+		if (!SUCCEEDED(IUPnPService_get_ServiceTypeIdentifier(pus, &bstrStid)))
+			break;
+
+		if (convert_bstr_to_char(bstrStid, &cstid))
+			break;
+
+		os_snprintf(var_name, sizeof(var_name), "%S", pcwszStateVarName);
+
+		node = sm->device_list;
+		while (node) {
+			do {
+				device = &node->device;
+
+				if (!SUCCEEDED(IUPnPService_get_Id(device->service, &bstrSid2)))
+					break;
+
+				if (convert_bstr_to_char(bstrSid2, &csid2))
+					break;
+
+				if (!SUCCEEDED(IUPnPService_get_ServiceTypeIdentifier(device->service, &bstrStid2)))
+					break;
+
+				if (convert_bstr_to_char(bstrStid2, &cstid2))
+					break;
+
+				if ((device->service_callback != service_callback) ||
+					os_strcmp(csid, csid2) || os_strcmp(cstid, cstid2))
+					break;
+
+				switch (V_VT(&vaValue)) {
+				case VT_ARRAY|VT_UI1:
+					ubound = 0;
+					lbound = 0;
+					if (!SUCCEEDED(SafeArrayGetUBound(V_ARRAY(&vaValue), 1, (LONG *)&ubound)))
+						break;
+					if (!SUCCEEDED(SafeArrayGetLBound(V_ARRAY(&vaValue), 1, (LONG *)&lbound)))
+						break;
+					value_length = ubound - lbound + 1;
+					if (!SUCCEEDED(SafeArrayAccessData(V_ARRAY(&vaValue), &value)))
+						break;
+					break;
+				case VT_UI1:
+					(u8*)value = &vaValue.bVal;
+					value_length = 1;
+					break;
+				case VT_BSTR:
+					if (convert_bstr_to_char(vaValue.bstrVal, &cvalue))
+						break;
+					value = cvalue;
+					value_length = os_strlen(cvalue);
+					break;
+				default:
+					break;
+				}
+
+				if (value && value_length) {
+					upnp_wps_ctrlpt_handle_event_received(service_callback->sm, device, var_name, value, value_length);
+
+					switch (V_VT(&vaValue)) {
+					case VT_ARRAY|VT_UI1:
+						(void)SafeArrayUnaccessData(V_ARRAY(&vaValue));
+						break;
+					case VT_UI1:
+						break;
+					case VT_BSTR:
+						if (cvalue) os_free(cvalue); cvalue = 0;
+						break;
+					default:
+						break;
+					}
+				}
+			} while(0);
+
+			node = node->next;
+
+			if (bstrSid2) SysFreeString(bstrSid2); bstrSid2 = 0;
+			if (csid2) os_free(csid2); csid2 = 0;
+			if (bstrStid2) SysFreeString(bstrStid2); bstrStid2 = 0;
+			if (cstid2) os_free(cstid2); csid2 = 0;
+		}
+
+		hr = S_OK;
+	} while (0);
+
+	ReleaseMutex(sm->mutex_devlist);
+
+	if (bstrSid) SysFreeString(bstrSid); bstrSid = 0;
+	if (csid) os_free(csid); csid = 0;
+	if (bstrStid) SysFreeString(bstrStid); bstrStid = 0;
+	if (cstid) os_free(cstid); cstid = 0;
+
+	return hr;
+}
+
+
+static HRESULT STDMETHODCALLTYPE
+service_callback_service_instance_died(IUPnPServiceCallback *This,
+									   IUPnPService *pus)
+{
+	HRESULT hr = S_FALSE;
+	struct upnp_service_callback *service_callback =
+			(struct upnp_service_callback *)This;
+
+	do {
+		if (!pus)
+			break;
+
+		hr = S_OK;
+	} while (0);
+
+	return hr;
+}
+
+
+static int
+destroy_service_callback(struct upnp_wps_ctrlpt_sm *sm,
+						 struct wps_device *device,
+						 struct upnp_service_callback *service_callback)
+{
+	int ret = -1;
+
+	do {
+		if (!service_callback)
+			break;
+
+		IUPnPServiceCallback_Release((IUPnPServiceCallback*)service_callback);
+
+		if (device->service_callback == service_callback)
+			device->service_callback = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static struct upnp_service_callback *
+create_service_callback(struct upnp_wps_ctrlpt_sm *sm,
+							  struct wps_device *device)
+{
+	int ret = -1;
+	struct upnp_service_callback *service_callback = 0;
+
+	do {
+		if (!sm)
+			break;
+
+		service_callback = wpa_zalloc(sizeof(*service_callback));
+		service_callback->sm = sm;
+		service_callback->device = device;
+		service_callback->lpVtbl= wpa_zalloc(sizeof(*service_callback->lpVtbl));
+		if (!service_callback->lpVtbl)
+			break;
+		service_callback->lpVtbl->QueryInterface = service_callback_query_interface;
+		service_callback->lpVtbl->AddRef = service_callback_add_ref;
+		service_callback->lpVtbl->Release = service_callback_release;
+		service_callback->lpVtbl->StateVariableChanged = service_callback_state_variable_changed;
+		service_callback->lpVtbl->ServiceInstanceDied = service_callback_service_instance_died;
+
+		IUPnPServiceCallback_AddRef((IUPnPServiceCallback *)service_callback);
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		destroy_service_callback(sm, device, service_callback);
+		service_callback = 0;
+	}
+
+	return service_callback;
+}
+
+
+static HRESULT STDMETHODCALLTYPE
+device_finder_callback_query_interface(IUPnPDeviceFinderCallback *This, REFIID iid, LPVOID* ppvObject)
+{
+	HRESULT hr = S_OK;
+	
+	do {
+		if(!ppvObject) {
+			hr = E_POINTER;
+			break;
+		}
+		*ppvObject = NULL;
+	
+		if(!IsEqualIID(iid, &IID_IUnknown) && !IsEqualIID(iid, &IID_IUPnPDeviceFinderCallback)) {
+			hr = E_NOINTERFACE;
+			break;
+		}
+
+		*ppvObject = This;
+		IUPnPDeviceFinderCallback_AddRef(This);
+	} while (0);
+	
+	return hr;
+}
+
+static ULONG STDMETHODCALLTYPE
+device_finder_callback_add_ref(IUPnPDeviceFinderCallback *This)
+{
+	struct upnp_device_finder_callback *device_finder_callback =
+			(struct upnp_device_finder_callback *)This;
+	return InterlockedIncrement(&device_finder_callback->ref_count);
+}
+
+static ULONG STDMETHODCALLTYPE
+device_finder_callback_release(IUPnPDeviceFinderCallback * This)
+{
+	struct upnp_device_finder_callback *device_finder_callback =
+			(struct upnp_device_finder_callback *)This;
+	ULONG ref_count = 0;
+
+	do {
+		if (!device_finder_callback->ref_count)
+			break;
+
+		(void)InterlockedDecrement(&device_finder_callback->ref_count);
+		ref_count = device_finder_callback->ref_count;
+		if (!device_finder_callback->ref_count) {
+			os_free(device_finder_callback->lpVtbl);
+			os_free(device_finder_callback);
+		}
+	} while (0);
+	return ref_count;
+}
+
+static HRESULT STDMETHODCALLTYPE
+device_finder_callback_device_added(IUPnPDeviceFinderCallback *This, LONG lFindData, IUPnPDevice *pDevice)
+{
+	HRESULT hr = S_FALSE;
+	struct upnp_device_finder_callback *device_finder_callback =
+			(struct upnp_device_finder_callback *)This;
+
+	do {
+		if (upnp_wps_ctrlpt_add_device(device_finder_callback->sm, pDevice))
+			break;
+
+		hr = S_OK;
+	} while (0);
+
+	return hr;
+}
+
+static HRESULT STDMETHODCALLTYPE
+device_finder_callback_device_removed(IUPnPDeviceFinderCallback *This, LONG lFindData, BSTR bstrUDN)
+{
+	HRESULT hr = S_FALSE;
+	struct upnp_device_finder_callback *device_finder_callback =
+			(struct upnp_device_finder_callback *)This;
+	char *udn = 0;
+
+	do {
+		if (convert_bstr_to_char(bstrUDN, &udn))
+			break;
+
+		if (upnp_wps_ctrlpt_remove_device(device_finder_callback->sm, udn))
+			break;
+
+		hr = S_OK;
+	} while (0);
+
+	if (udn)
+		os_free(udn);
+
+	return hr;
+}
+
+static HRESULT STDMETHODCALLTYPE
+device_finder_callback_search_complete(IUPnPDeviceFinderCallback *This, LONG lFindData)
+{
+	return S_OK;
+}
+
+static int
+destroy_device_finder_callback(struct upnp_wps_ctrlpt_sm *sm,
+							   struct upnp_device_finder_callback *device_finder_callback)
+{
+	int ret = -1;
+
+	do {
+		if (!device_finder_callback)
+			break;
+
+		IUPnPDeviceFinderCallback_Release((IUPnPDeviceFinderCallback*)device_finder_callback);
+
+		if (sm->device_finder_callback == device_finder_callback)
+			sm->device_finder_callback = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+							   
+static struct upnp_device_finder_callback *
+create_device_finder_callback(struct upnp_wps_ctrlpt_sm *sm)
+{
+	int ret = -1;
+	struct upnp_device_finder_callback *device_finder_callback = 0;
+
+	do {
+		if (!sm)
+			break;
+
+		device_finder_callback = wpa_zalloc(sizeof(*device_finder_callback));
+		device_finder_callback->sm = sm;
+		device_finder_callback->lpVtbl= wpa_zalloc(sizeof(*device_finder_callback->lpVtbl));
+		if (!device_finder_callback->lpVtbl)
+			break;
+		device_finder_callback->lpVtbl->QueryInterface = device_finder_callback_query_interface;
+		device_finder_callback->lpVtbl->AddRef = device_finder_callback_add_ref;
+		device_finder_callback->lpVtbl->Release = device_finder_callback_release;
+		device_finder_callback->lpVtbl->DeviceAdded = device_finder_callback_device_added;
+		device_finder_callback->lpVtbl->DeviceRemoved = device_finder_callback_device_removed;
+		device_finder_callback->lpVtbl->SearchComplete = device_finder_callback_search_complete;
+
+		IUPnPDeviceFinderCallback_AddRef((IUPnPDeviceFinderCallback *)device_finder_callback);
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		destroy_device_finder_callback(sm, device_finder_callback);
+		device_finder_callback = 0;
+	}
+
+	return device_finder_callback;
+}
+
+
+struct upnp_wps_ctrlpt_sm *
+upnp_wps_ctrlpt_init(struct upnp_wps_ctrlpt_ctx *ctx, void *priv)
+{
+	int ret = 0;
+	struct upnp_wps_ctrlpt_sm *sm = 0;
+    HRESULT hr = S_OK;
+
+	do {
+		sm = wpa_zalloc(sizeof(*sm));
+		if (!sm)
+			break;
+		sm->ctx = ctx;
+		sm->priv = priv;
+
+		do {
+			hr = CoInitializeEx(0, COINIT_MULTITHREADED);
+			if (S_OK != hr) {
+				if (S_FALSE != hr)
+					break;
+			} else {
+				sm->co_initialized = 1;
+
+				// Set general COM security levels
+				hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
+					 RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_SECURE_REFS, NULL);
+				if (S_OK != hr)
+					break;
+			}
+
+			ret = 1;
+		} while (0);
+	} while (0);
+
+	if (!ret) {
+		upnp_wps_ctrlpt_deinit(sm);
+		sm = 0;
+	}
+
+	return sm;
+}
+
+
+void
+upnp_wps_ctrlpt_deinit(struct upnp_wps_ctrlpt_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+
+		if (sm->started)
+			upnp_wps_ctrlpt_stop(sm);
+
+		if (sm->co_initialized) {
+		    CoUninitialize();
+			sm->co_initialized = 0;
+		}
+
+		if (sm->device_finder_callback)
+			(void)destroy_device_finder_callback(sm, sm->device_finder_callback);
+
+		free(sm->ctx);
+		free(sm);
+	} while (0);
+}
+
+
+static int
+upnp_wps_ctrlpt_delete_node(struct upnp_wps_ctrlpt_sm *sm,
+							struct wps_device_node *node)
+{
+	int ret = -1;
+
+	do {
+		if (!sm || !node)
+			break;
+
+		if (node->device.friendly_name)
+			free(node->device.friendly_name);
+		if (node->device.manufacturer)
+			free(node->device.manufacturer);
+		if (node->device.manufacturer_url)
+			free(node->device.manufacturer_url);
+		if (node->device.model_desc)
+			free(node->device.model_desc);
+		if (node->device.model_name)
+			free(node->device.model_name);
+		if (node->device.model_number)
+			free(node->device.model_number);
+		if (node->device.model_url)
+			free(node->device.model_url);
+		if (node->device.serial_number)
+			free(node->device.serial_number);
+		if (node->device.udn)
+			free(node->device.udn);
+		if (node->device.upc)
+			free(node->device.upc);
+		if (node->device.pres_url)
+			free(node->device.pres_url);
+
+		(void)destroy_service_callback(sm, &node->device, node->device.service_callback);
+
+		if (node->device.service)
+			IUPnPService_Release(node->device.service);
+		if (node->device.services)
+			IUPnPServices_Release(node->device.services);
+		if (node->device.handle)
+			IUPnPDevice_Release(node->device.handle);
+
+		free(node);
+		node = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_remove_device(struct upnp_wps_ctrlpt_sm *sm,
+							  char *udn)
+{
+	int ret = -1;
+	struct wps_device_node *cur, *prev = 0;
+
+	do {
+		if (!udn)
+			break;
+
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+		cur = sm->device_list;
+		while (cur) {
+			if (!os_strcmp(cur->device.udn, udn)) {
+				if (cur == sm->device_list)
+					sm->device_list = cur->next;
+				else if (prev)
+					prev->next = cur->next;
+				else
+					break;
+				upnp_wps_ctrlpt_delete_node(sm, cur);
+				break;
+			}
+			prev = cur;
+			cur = cur->next;
+		}
+
+		ReleaseMutex(sm->mutex_devlist);
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_remove_all_device(struct upnp_wps_ctrlpt_sm *sm)
+{
+	struct wps_device_node *cur, *next;
+
+	WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+	cur = sm->device_list;
+	while (cur) {
+		next = cur->next;
+		upnp_wps_ctrlpt_delete_node(sm, cur);
+		cur = next;
+	}
+	sm->device_list = 0;
+
+	ReleaseMutex(sm->mutex_devlist);
+
+	return 0;
+}
+
+
+int
+upnp_wps_ctrlpt_add_device(struct upnp_wps_ctrlpt_sm *sm, IUPnPDevice *device)
+{
+	int ret = -1;
+	struct wps_device_node *node = 0, *prev, *cur, *next;
+	IUPnPDeviceDocumentAccess *docaccess = 0;
+	BSTR service_id = 0, tmp = 0;
+	char *udn = 0;
+
+	if (!sm)
+		return ret;
+
+	WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+	do {
+		if (!SUCCEEDED(IUPnPDevice_get_UniqueDeviceName(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &udn);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!udn)
+			break;
+
+		prev = next = 0;
+		cur = sm->device_list;
+		while (cur) {
+			next = cur->next;
+			if (!os_strcmp(cur->device.udn, udn)) {
+				(void)upnp_wps_ctrlpt_delete_node(sm, cur);
+				break;
+			}
+			prev = cur;
+			cur = cur->next;
+		}
+
+		node = (struct wps_device_node *)wpa_zalloc(sizeof(*node));
+		if (!node)
+			break;
+
+		if (!SUCCEEDED(IUPnPDevice_get_FriendlyName(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.friendly_name);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_ManufacturerName(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.manufacturer);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_ManufacturerURL(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.manufacturer_url);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_Description(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.model_desc);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_ModelName(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.model_name);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_ModelNumber(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.model_number);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_ModelURL(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.model_url);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_SerialNumber(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.serial_number);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_UPC(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.upc);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_get_PresentationURL(device, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.pres_url);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		if (!SUCCEEDED(IUPnPDevice_QueryInterface(device, &IID_IUPnPDeviceDocumentAccess, (void **)&docaccess)))
+			break;
+		if (!SUCCEEDED(IUPnPDeviceDocumentAccess_GetDocumentURL(docaccess, &tmp)))
+			break;
+		(void)convert_bstr_to_char(tmp, &node->device.control_url);
+		if (tmp) SysFreeString(tmp); tmp = 0;
+
+		service_id = SysAllocString(wps_service_id);
+		if (!service_id)
+			break;
+
+		if (!SUCCEEDED(IUPnPDevice_get_Services(device, &node->device.services)))
+			break;
+
+		if (!SUCCEEDED(IUPnPServices_get_Item(node->device.services, service_id, &node->device.service)))
+			break;
+
+		node->device.service_callback = create_service_callback(sm, &node->device);
+		if (!node->device.service_callback)
+			break;
+
+		if (!SUCCEEDED(IUPnPService_AddCallback(node->device.service, (IUnknown *)node->device.service_callback)))
+			break;
+
+		node->device.udn = udn;
+		node->device.handle = device;
+		IUPnPDevice_AddRef(device);
+
+		if (!cur) {
+			if (sm->device_list) {
+				next = sm->device_list;
+				while(next->next)
+					next = next->next;
+				next->next = node;
+			} else
+				sm->device_list = node;
+		} else if (!prev) {
+			sm->device_list = node;
+			sm->device_list->next = next;
+		} else {
+			prev->next = cur;
+			cur->next = next;
+		}
+
+		ret = 0;
+    } while (0);
+
+	if (ret) {
+		if (node)
+			upnp_wps_ctrlpt_delete_node(sm, node);
+		if (udn)
+			os_free(udn);
+	}
+
+	ReleaseMutex(sm->mutex_devlist);
+
+	if (docaccess) IUPnPDeviceDocumentAccess_Release(docaccess);
+	if (service_id) SysFreeString(service_id);
+	if (tmp) SysFreeString(tmp);
+
+	return ret;
+}
+
+int
+upnp_wps_ctrlpt_get_scan_results(struct upnp_wps_ctrlpt_sm *sm,
+								 struct upnp_wps_ctrlpt_device_list **list)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	struct upnp_wps_ctrlpt_device_list *cur = 0;
+
+	do {
+		if (!sm || !list)
+			break;
+
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+		*list = 0;
+		node = sm->device_list;
+		while (node) {
+			if (!*list) {
+				*list = (struct upnp_wps_ctrlpt_device_list *)
+						wpa_zalloc(sizeof(**list));
+				if (!*list)
+					break;
+				cur = *list;
+			} else if (cur) {
+				cur->next = (struct upnp_wps_ctrlpt_device_list *)
+						wpa_zalloc(sizeof(*cur));
+				if (!cur->next)
+					break;
+				cur = cur->next;
+			} else
+				break;
+
+			os_snprintf(cur->device.manufacturer, sizeof(cur->device.manufacturer), "%s", node->device.manufacturer);
+			os_snprintf(cur->device.model_name, sizeof(cur->device.model_name), "%s", node->device.model_name);
+			os_snprintf(cur->device.model_number, sizeof(cur->device.model_number), "%s", node->device.model_number);
+			os_snprintf(cur->device.serial_number, sizeof(cur->device.serial_number), "%s", node->device.serial_number);
+			os_snprintf(cur->device.udn, sizeof(cur->device.udn), "%s", node->device.udn);
+			os_snprintf(cur->device.control_url, sizeof(cur->device.control_url), "%s", node->device.control_url);
+
+			node = node->next;
+		}
+
+		ReleaseMutex(sm->mutex_devlist);
+
+		if (node)
+			break;
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (list && *list) {
+			upnp_wps_ctrlpt_destroy_device_list(*list);
+			*list = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+void
+upnp_wps_ctrlpt_destroy_device_list(struct upnp_wps_ctrlpt_device_list *list)
+{
+	struct upnp_wps_ctrlpt_device_list *device, *next;
+	do {
+		if (!list)
+			break;
+
+		device = list;
+		while (device) {
+			next = device->next;
+			free(device);
+			device = next;
+		}
+	} while (0);
+}
+
+int
+upnp_wps_ctrlpt_refresh_device(struct upnp_wps_ctrlpt_sm *sm, int timeout)
+{
+	int ret = -1;
+	BSTR device_type = 0;
+
+
+	do {
+		if (!sm)
+			break;
+
+		if (sm->device_finder) {
+			if (sm->async_finder) {
+				IUPnPDeviceFinder_CancelAsyncFind(sm->device_finder, sm->async_finder);
+				sm->async_finder = 0;
+			}
+
+			IUPnPDeviceFinder_Release(sm->device_finder);
+			sm->device_finder = 0;
+		}
+
+		if (sm->device_finder_callback)
+			(void)destroy_device_finder_callback(sm, sm->device_finder_callback);
+
+		(void)upnp_wps_ctrlpt_remove_all_device(sm);
+
+		sm->device_finder_callback = create_device_finder_callback(sm);
+		if (!sm->device_finder_callback)
+			break;
+
+        if(!SUCCEEDED(CoCreateInstance(&CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, &IID_IUPnPDeviceFinder, &sm->device_finder)))
+			break;
+
+		device_type = SysAllocString(wps_device_type);
+		if (!device_type)
+			break;
+
+		if (!SUCCEEDED(IUPnPDeviceFinder_CreateAsyncFind(sm->device_finder, device_type, 0, (IUnknown *)sm->device_finder_callback, &sm->async_finder)))
+			break;
+
+		if (!SUCCEEDED(IUPnPDeviceFinder_StartAsyncFind(sm->device_finder, sm->async_finder))) {
+			IUPnPDeviceFinder_CancelAsyncFind(sm->device_finder, sm->async_finder);
+			sm->async_finder = 0;
+			IUPnPDeviceFinder_Release(sm->device_finder);
+			sm->device_finder = 0;
+			break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (device_type) SysFreeString(device_type);
+
+	return ret;
+}
+
+static int
+upnp_wps_ctrlpt_get_device(struct upnp_wps_ctrlpt_sm *sm,
+						   char *control_url,
+						   struct wps_device_node **node)
+{
+	int ret = -1;
+	struct wps_device_node *next;
+
+	do {
+		if (!sm || !control_url || !node)
+			break;
+
+		*node = 0;
+		next = sm->device_list;
+		while (next) {
+			if (!os_strcmp(next->device.control_url, control_url)) {
+				*node = next;
+				break;
+			}
+			next = next->next;
+		}
+
+		if (!*node)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (node && *node)
+			*node = 0;
+	}
+
+	return ret;
+}
+
+void
+upnp_wps_ctrlpt_handle_event_received(struct upnp_wps_ctrlpt_sm *sm,
+									  struct wps_device *device,
+									  char *var_name,
+									  void *value,
+									  size_t value_length)
+{
+	do {
+		if (!sm || !device || !sm->ctx || !var_name || !value)
+			break;
+
+		if (!os_strcmp("WLANEvent", var_name)) {
+			int event_type;
+			char event_mac[18];
+
+			if (sm->ctx->received_wlan_event) {
+
+				event_type = (int)*(u8*)value;
+				os_strncpy(event_mac, (char *)value + 1, sizeof(event_mac) - 1);
+				event_mac[sizeof(event_mac) - 1] = 0;
+
+				sm->ctx->received_wlan_event(sm->priv,
+											 device->control_url,
+											 event_type,
+											 event_mac,
+											 (u8*)value + 18,
+											 value_length - 18);
+			}
+		} else if (!os_strcmp("APStatus", var_name)) {
+			if (sm->ctx->received_ap_status)
+				sm->ctx->received_ap_status(sm->priv,
+											device->control_url,
+											*(u8*)value);
+		} else if (!os_strcmp("STAStatus", var_name)) {
+			if (sm->ctx->received_sta_status)
+				sm->ctx->received_sta_status(sm->priv,
+											 device->control_url,
+											 *(u8*)value);
+		}
+	} while (0);
+}
+
+
+#if 0
+static int
+upnp_wps_ctrlpt_get_var(struct upnp_wps_ctrlpt_sm *sm,
+						char *control_url,
+						char *var,
+						void *cookie)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+
+	if (!sm)
+		return ret;
+
+	ithread_mutex_lock(&sm->mutex_devlist);
+
+	do {
+		if (!var)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpGetServiceVarStatusAsync(sm->ctrlpt_handle,
+										 node->device.service.control_url,
+										 var,
+										 upnp_wps_ctrlpt_callback_event_handler,
+										 cookie))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	ithread_mutex_unlock(&sm->mutex_devlist);
+
+	return ret;
+}
+#endif
+
+
+int
+upnp_wps_ctrlpt_send_get_device_info(struct upnp_wps_ctrlpt_sm *sm,
+									 char *control_url)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	BSTR action = 0;
+	VARIANT varInArgs, varOutArgs, varReturnVal, var;
+	SAFEARRAYBOUND rgsaBound[1];
+	SAFEARRAY *psa = 0;
+	LONG rgIndices[1];
+	u8 *resp = 0;
+	size_t resp_len, lbound, ubound;
+
+	VariantInit(&varInArgs);
+	VariantInit(&varOutArgs);
+	VariantInit(&varReturnVal);
+	VariantInit(&var);
+
+	do {
+		if (!sm || !control_url)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (convert_char_to_bstr("GetDeviceInfo", &action))
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = 0;
+		psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
+		if (!psa)
+			break;
+
+		V_VT(&varInArgs) = VT_VARIANT|VT_ARRAY;
+		V_ARRAY(&varInArgs) = psa;
+
+		if (!SUCCEEDED(IUPnPService_InvokeAction(node->device.service, action,
+					   varInArgs, &varOutArgs, &varReturnVal)))
+			break;
+
+		if (!sm->ctx->received_resp_get_device_info) {
+			ret = 0;
+			break;
+		}
+
+		/* NewDeviceInfo */
+		rgIndices[0] = 0;
+		if (!SUCCEEDED(SafeArrayGetElement(V_ARRAY(&varOutArgs), rgIndices, (void *)&var)))
+			break;
+
+		ubound = 0;
+		if (!SUCCEEDED(SafeArrayGetUBound(V_ARRAY(&var), 1, (LONG *)&ubound)))
+			break;
+
+		lbound = 0;
+		if (!SUCCEEDED(SafeArrayGetLBound(V_ARRAY(&var), 1, (LONG *)&lbound)))
+			break;
+
+		resp_len = ubound - lbound + 1;
+
+		if (!SUCCEEDED(SafeArrayAccessData(V_ARRAY(&var), &resp)))
+			break;
+
+		ret = sm->ctx->received_resp_get_device_info(sm->priv, control_url, resp, resp_len);
+
+		(void)SafeArrayUnaccessData(V_ARRAY(&var));
+	} while (0);
+
+	VariantClear(&varInArgs);
+	VariantClear(&varReturnVal);
+	VariantClear(&varOutArgs);
+
+	if (action) SysFreeString(action);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_send_put_message(struct upnp_wps_ctrlpt_sm *sm,
+								 char *control_url,
+								 u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	BSTR action = 0;
+	VARIANT varInArgs, varOutArgs, varReturnVal, var, var2;
+	SAFEARRAYBOUND rgsaBound[1];
+	SAFEARRAY *psa = 0, *val = 0;
+	LONG rgIndices[1];
+	u8 *resp = 0;
+	size_t resp_len, ubound, lbound;
+	size_t i;
+
+	VariantInit(&varInArgs);
+	VariantInit(&varOutArgs);
+	VariantInit(&varReturnVal);
+	VariantInit(&var);
+	VariantInit(&var2);
+
+	do {
+		if (!sm || !control_url || !msg)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (convert_char_to_bstr("PutMessage", &action))
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = 1;
+		psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
+		if (!psa)
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = msg_len;
+		val = SafeArrayCreate(VT_UI1, 1, rgsaBound);
+		if (!val)
+			break;
+
+		for (i = 0; i < msg_len; i++) {
+			rgIndices[0] = i;
+			if (!SUCCEEDED(SafeArrayPutElement(val, rgIndices, (void *)(msg + i))))
+				break;
+		}
+		if (i != msg_len)
+			break;
+
+		/* NewInMessage */
+		V_VT(&var) = VT_ARRAY|VT_UI1;
+		V_ARRAY(&var) = val;
+
+		rgIndices[0] = 0;
+		if (!SUCCEEDED(SafeArrayPutElement(psa, rgIndices, (void *)&var)))
+			break;
+
+		V_VT(&varInArgs) = VT_VARIANT|VT_ARRAY;
+		V_ARRAY(&varInArgs) = psa;
+
+		if (!SUCCEEDED(IUPnPService_InvokeAction(node->device.service, action,
+					   varInArgs, &varOutArgs, &varReturnVal)))
+			break;
+
+		if (!sm->ctx->received_resp_put_message) {
+			ret = 0;
+			break;
+		}
+
+		/* NewOutMessage */
+		rgIndices[0] = 0;
+		if (!SUCCEEDED(SafeArrayGetElement(V_ARRAY(&varOutArgs), rgIndices, (void *)&var2)))
+			break;
+
+		ubound = 0;
+		if (!SUCCEEDED(SafeArrayGetUBound(V_ARRAY(&var2), 1, (LONG *)&ubound)))
+			break;
+
+		lbound = 0;
+		if (!SUCCEEDED(SafeArrayGetLBound(V_ARRAY(&var2), 1, (LONG *)&lbound)))
+			break;
+
+		resp_len = ubound - lbound + 1;
+
+		if (!SUCCEEDED(SafeArrayAccessData(V_ARRAY(&var2), &resp)))
+			break;
+
+		ret = sm->ctx->received_resp_put_message(sm->priv, control_url, resp, resp_len);
+
+		(void)SafeArrayUnaccessData(V_ARRAY(&var2));
+	} while (0);
+
+	VariantClear(&varInArgs);
+	VariantClear(&varReturnVal);
+	VariantClear(&varOutArgs);
+
+	if (action) SysFreeString(action);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_send_put_wlan_response(struct upnp_wps_ctrlpt_sm *sm,
+									   char *control_url, int ev_type,
+									   u8 *mac, u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	BSTR action = 0;
+	VARIANT varInArgs, varOutArgs, varReturnVal, var1, var2, var3;
+	SAFEARRAYBOUND rgsaBound[1];
+	SAFEARRAY *psa = 0, *val = 0;
+	LONG rgIndices[1];
+	char mac_address[18];
+	size_t i;
+	BSTR bstrMac = 0;
+
+	VariantInit(&varInArgs);
+	VariantInit(&varOutArgs);
+	VariantInit(&varReturnVal);
+	VariantInit(&var1);
+	VariantInit(&var2);
+	VariantInit(&var3);
+
+	do {
+		if (!sm || !control_url || !mac || !msg)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (convert_char_to_bstr("PutWLANResponse", &action))
+			break;
+
+		os_snprintf(mac_address, sizeof(mac_address), "%02X:%02X:%02X:%02X:%02X",
+					mac[1], mac[2], mac[3], mac[4], mac[5], mac[6]);
+		if (convert_char_to_bstr(mac_address, &bstrMac))
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = 3;
+		psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
+		if (!psa)
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = msg_len;
+		val = SafeArrayCreate(VT_UI1, 1, rgsaBound);
+		if (!val)
+			break;
+
+		for (i = 0; i < msg_len; i++) {
+			rgIndices[0] = i;
+			if (!SUCCEEDED(SafeArrayPutElement(val, rgIndices, (void *)(msg + i))))
+				break;
+		}
+		if (i != msg_len)
+			break;
+
+		/* NewMessage */
+		V_VT(&var1) = VT_ARRAY|VT_UI1;
+		V_ARRAY(&var1) = val;
+
+		rgIndices[0] = 0;
+		if (!SUCCEEDED(SafeArrayPutElement(psa, rgIndices, (void *)&var1)))
+			break;
+
+		/* NewWLANEventType */
+		V_VT(&var2) = VT_UI1;
+		V_UI1(&var2) = ev_type & (UPNP_WPS_WLANEVENT_TYPE_PROBE|UPNP_WPS_WLANEVENT_TYPE_EAP);
+
+		rgIndices[0] = 1;
+		if (!SUCCEEDED(SafeArrayPutElement(psa, rgIndices, (void *)&var2)))
+			break;
+
+		/* NewWLANEventMAC */
+		V_VT(&var3) = VT_BSTR;
+		V_BSTR(&var3) = bstrMac;
+
+		rgIndices[0] = 2;
+		if (!SUCCEEDED(SafeArrayPutElement(psa, rgIndices, (void *)&var3)))
+			break;
+
+		V_VT(&varInArgs) = VT_VARIANT|VT_ARRAY;
+		V_ARRAY(&varInArgs) = psa;
+
+		if (!SUCCEEDED(IUPnPService_InvokeAction(node->device.service, action,
+					   varInArgs, &varOutArgs, &varReturnVal)))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	VariantClear(&varInArgs);
+	VariantClear(&varOutArgs);
+	VariantClear(&varReturnVal);
+
+	if (action) SysFreeString(action);
+	if (bstrMac) SysFreeString(bstrMac);
+
+	return ret;
+}
+
+int
+upnp_wps_ctrlpt_send_set_selected_registrar(struct upnp_wps_ctrlpt_sm *sm,
+											char *control_url,
+											u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	BSTR action = 0;
+	VARIANT varInArgs, varOutArgs, varReturnVal, var;
+	SAFEARRAYBOUND rgsaBound[1];
+	SAFEARRAY *psa = 0, *val = 0;
+	LONG rgIndices[1];
+	size_t i;
+
+	VariantInit(&varInArgs);
+	VariantInit(&varOutArgs);
+	VariantInit(&varReturnVal);
+	VariantInit(&var);
+
+	do {
+		if (!sm || !control_url || !msg)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (convert_char_to_bstr("SetSelectedRegistrar", &action))
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = 1;
+		psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
+		if (!psa)
+			break;
+
+		rgsaBound[0].lLbound = 0;
+		rgsaBound[0].cElements = msg_len;
+		val = SafeArrayCreate(VT_UI1, 1, rgsaBound);
+		if (!val)
+			break;
+
+		for (i = 0; i < msg_len; i++) {
+			rgIndices[0] = i;
+			if (!SUCCEEDED(SafeArrayPutElement(val, rgIndices, (void *)(msg + i))))
+				break;
+		}
+		if (i != msg_len)
+			break;
+
+		/* NewMessage */
+		V_VT(&var) = VT_ARRAY|VT_UI1;
+		V_ARRAY(&var) = val;
+
+		rgIndices[0] = 0;
+		if (!SUCCEEDED(SafeArrayPutElement(psa, rgIndices, (void *)&var)))
+			break;
+
+		V_VT(&varInArgs) = VT_VARIANT|VT_ARRAY;
+		V_ARRAY(&varInArgs) = psa;
+
+		if (!SUCCEEDED(IUPnPService_InvokeAction(node->device.service, action, varInArgs, &varOutArgs, &varReturnVal)))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	VariantClear(&varInArgs);
+	VariantClear(&varOutArgs);
+	VariantClear(&varReturnVal);
+
+	if (action) SysFreeString(action);
+
+	return ret;
+}
+
+int
+upnp_wps_ctrlpt_start(struct upnp_wps_ctrlpt_sm *sm, char *net_if)
+{
+	int ret = -1;
+
+	do {
+		if (!sm)
+			break;
+
+		if (sm->started)
+			upnp_wps_ctrlpt_stop(sm);
+
+		sm->mutex_devlist = CreateMutex(0, 0, 0);
+
+		sm->started = 1;
+
+		(void)upnp_wps_ctrlpt_refresh_device(sm, 0);
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_stop(struct upnp_wps_ctrlpt_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+
+		if (!sm->started)
+			break;
+
+		if (sm->mutex_devlist)
+			WaitForSingleObject(sm->mutex_devlist, INFINITE);
+
+		if (sm->device_finder) {
+			if (sm->async_finder) {
+				IUPnPDeviceFinder_CancelAsyncFind(sm->device_finder, sm->async_finder);
+				sm->async_finder = 0;
+			}
+
+			IUPnPDeviceFinder_Release(sm->device_finder);
+			sm->device_finder = 0;
+		}
+
+		if (sm->device_finder_callback)
+			(void)destroy_device_finder_callback(sm, sm->device_finder_callback);
+
+		if (sm->mutex_devlist)
+			ReleaseMutex(sm->mutex_devlist);
+
+		(void)upnp_wps_ctrlpt_remove_all_device(sm);
+
+		if (sm->mutex_devlist) {
+			CloseHandle(sm->mutex_devlist);
+			sm->mutex_devlist = 0;
+		}
+	} while (0);
+
+	if (sm)
+		sm->started = 0;
+	return 0;
+}
+
+
Index: events.c
===================================================================
--- events.c	(revision 1)
+++ events.c	(revision 2)
@@ -29,7 +29,13 @@
 #include "eap.h"
 #include "ctrl_iface_dbus.h"
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 static int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s)
 {
 	struct wpa_ssid *ssid;
@@ -239,6 +245,13 @@
 	if (ssid->mixed_cell)
 		return 1;
 
+#ifdef EAP_WPS
+	if (wpa_config_get(ssid, "eap") &&
+	    !os_strcmp("WPS", wpa_config_get(ssid, "eap"))) {
+		return 1;
+	}
+#endif	/* EAP_WPS */
+
 	for (i = 0; i < NUM_WEP_KEYS; i++) {
 		if (ssid->wep_key_len[i]) {
 			privacy = 1;
@@ -264,6 +277,13 @@
 	struct wpa_ie_data ie;
 	int proto_match = 0;
 
+#ifdef EAP_WPS
+	if (wpa_config_get(ssid, "eap") &&
+	    !os_strcmp("WPS", wpa_config_get(ssid, "eap"))) {
+		return 1;
+	}
+#endif	/* EAP_WPS */
+
 	while ((ssid->proto & WPA_PROTO_RSN) && bss->rsn_ie_len > 0) {
 		proto_match++;
 
@@ -504,6 +524,12 @@
 	struct wpa_ssid *ssid = NULL;
 	struct wpa_scan_result *results;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config *wps = wpa_s->conf->wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	if (wpa_supplicant_get_scan_results(wpa_s) < 0) {
 		if (wpa_s->conf->ap_scan == 2)
 			return;
@@ -521,6 +547,11 @@
 	num = wpa_s->num_scan_results;
 
 	while (selected == NULL) {
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+		if (!wps->enabled_pbc || (-1 != wps->nwid_trying_wps)) {
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 		for (prio = 0; prio < wpa_s->conf->num_prio; prio++) {
 			selected = wpa_supplicant_select_bss(
 				wpa_s, wpa_s->conf->pssid[prio], results, num,
@@ -536,6 +567,17 @@
 		} else if (selected == NULL) {
 			break;
 		}
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+		}
+		
+		if (wps->enabled_pbc && !selected) {
+			selected = wps_select_pbc_ssid(wpa_s, results, num, &ssid);
+			if (!selected)
+				break;
+		}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 	}
 
 	if (selected) {
@@ -575,6 +617,14 @@
 		wpa_s->scan_res_tried++;
 		timeout = 0;
 	}
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	if (wps->enabled_pbc)
+		wpa_s->scan_req = 2;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	wpa_supplicant_req_scan(wpa_s, timeout, 0);
 }
 
Index: testbed_sta/wpspbc.cpp
===================================================================
--- testbed_sta/wpspbc.cpp	(revision 0)
+++ testbed_sta/wpspbc.cpp	(revision 2)
@@ -0,0 +1,210 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wpspbc.cpp
+//  Description: WPS PBC source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "wpspbc.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+WpsPbc::WpsPbc(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+WpsPbc::~WpsPbc()
+{
+	delete timer;
+}
+
+bool WpsPbc::pre_next()
+{
+	bool ret = false;
+
+	label->setText("PBC method");
+
+	wiz->pbNext->setText("&Start");
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	wiz->pbNext->setFocus();
+
+	do {
+		progressBar->setValue(0);
+		progressBar->setVisible(false);
+
+		MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+
+		lblComment->setText("Push-button on registrar, the push [Start] button.\n");
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void WpsPbc::cancel()
+{
+	if (timer->isActive()) {
+		timer->stop();
+		MainProcess::stopPbc();
+		wiz->pbCancel->setText("&Finish");
+		wiz->pbNext->setText("&Next");
+		wiz->pbNext->setEnabled(false);
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		label->setText("Canceled by user indication");
+		progressBar->setVisible(false);
+		lblComment->setText("Cancel WPS authentication.\n");
+	} else {
+		wiz->close();
+	}
+}
+
+bool WpsPbc::post_next()
+{
+	bool ret = false;
+	if (!wiz->pbNext->text().compare("&Next")) {
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		ret = true;
+	} else {
+		do {
+			if (!MainProcess::startPbc()) {
+				MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+				QMessageBox::warning(this, label->text(),
+									 "Could not start WPS authentication with PBC method\n");
+				wiz->pbNext->setText("&Start");
+				break;
+			} else {
+				progressBar->setValue(0);
+				progressBar->setVisible(true);
+				timer->start(100);
+				wiz->pbNext->setText("&Restart");
+			}
+			lblComment->setText("Try to authenticate with PBC method in 2 minutes\n");
+		} while (0);
+	}
+
+	return ret;
+}
+
+void WpsPbc::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_EAP_WPS_FAIL)) {
+			timer->stop();
+
+			MainProcess::stopPbc();
+
+			label->setText("Fail");
+			lblComment->setText("Fail WPS authentication with PBC method");
+			wiz->pbBack->setEnabled(false);
+			wiz->pbNext->setText("&Next");
+			wiz->pbNext->setEnabled(false);
+			progressBar->setVisible(false);
+		} else if (!strcmp(req, CTRL_REQ_EAP_WPS_COMP)) {
+			int index = atoi(msg + 1);
+			char ssid[33];
+
+			timer->stop();
+			UtilSleep::mSleep(500);
+
+			MainProcess::setNetworkIndex(index);
+			if (!MainProcess::getNetworkParam(MainProcess::getNetworkIndex(), "ssid", ssid, true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not get parameter : ssid\n");
+			}
+			MainProcess::connectNetwork(MainProcess::getNetworkIndex());
+
+			label->setText("Complete");
+			lblComment->setText("Complete WPS Authentication with PBC method.\n\nSSID : ");
+			lblComment->setText(lblComment->text() + ssid);
+			wiz->pbBack->setEnabled(false);
+			wiz->pbNext->setText("&Next");
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+			progressBar->setVisible(false);
+		} else if (!strlen(req) && strstr(msg, "WPS-PBC") &&
+				   timer->isActive()) {
+			lblComment->setText("Try to authenticate with PBC method in 2 minutes\n\n");
+			lblComment->setText(lblComment->text() + msg);
+		}
+	}
+}
+
+void WpsPbc::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void WpsPbc::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else {
+		timer->stop();
+
+		MainProcess::stopPbc();
+
+		label->setText("Timeout");
+		progressBar->setFormat("Timeout");
+		progressBar->update();
+		lblComment->setText("Timeout WPS Authentication with PBC method.\n"
+							"Could not authenticate in 2 minutes\n");
+		wiz->pbCancel->setText("&Cancel");
+		wiz->pbNext->setText("&Next");
+		wiz->pbNext->setEnabled(false);
+	}
+}
+
Index: testbed_sta/inputpin.ui
===================================================================
--- testbed_sta/inputpin.ui	(revision 0)
+++ testbed_sta/inputpin.ui	(revision 2)
@@ -0,0 +1,127 @@
+<ui version="4.0" >
+ <class>InputPin</class>
+ <widget class="QWidget" name="InputPin" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>547</width>
+    <height>320</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>PIN method</string>
+   </property>
+  </widget>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>300</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Touch NFC Token in 30 sec</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>121</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+  <widget class="QWidget" name="horizontalLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>190</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <layout class="QHBoxLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>12</number>
+    </property>
+    <item>
+     <widget class="QLabel" name="label_2" >
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+        <weight>75</weight>
+        <bold>true</bold>
+       </font>
+      </property>
+      <property name="text" >
+       <string>PIN :</string>
+      </property>
+     </widget>
+    </item>
+    <item>
+     <widget class="QLineEdit" name="lePin" >
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/testbedsta.cpp
===================================================================
--- testbed_sta/testbedsta.cpp	(revision 0)
+++ testbed_sta/testbedsta.cpp	(revision 2)
@@ -0,0 +1,323 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: testbedsta.cpp
+//  Description: WiFi - Protected Setup Station user interface source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "testbedsta.h"
+#include "mainprocess.h"
+#include "pagetemplate.h"
+#include "setupinterface.h"
+#include "selectmode.h"
+#include "netconfig.h"
+#include "selectmethod.h"
+#include "writenfcconfig.h"
+#include "readnfcconfig.h"
+#include "selectap.h"
+#include "inputpin.h"
+#include "displaypin.h"
+#include "wpsauthentication.h"
+#include "wpspbc.h"
+#include "debugwindow.h"
+#include "about.h"
+
+#include <QMessageBox>
+
+
+QProcess *MainProcess::mainProcess = new QProcess();
+struct wpa_ctrl *MainProcess::monitor = 0;
+struct wpa_ctrl *MainProcess::ctrl = 0;
+char *MainProcess::iface = 0;
+QMutex *MainProcess::mtx = new QMutex();
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+QSocketNotifier *MainProcess::msgNotifier = 0;
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+QTimer *MainProcess::msgNotifier = 0;
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+MainProcess::MODE MainProcess::mode = MODE_ENR;
+MainProcess::METHOD MainProcess::method = METHOD_NONE;
+MainProcess::AREA MainProcess::area = AREA_BOTH_INBAND_UPNP;
+int MainProcess::networkIndex = -1;
+char *MainProcess::wirelessInterface = 0;
+char *MainProcess::wiredInterface = 0;
+char *MainProcess::controlUrl = 0;
+bool MainProcess::enabledUpnp = false;
+
+
+TestbedSta::TestbedSta(QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0*/)
+: QMainWindow(parent, f)
+{
+	setupUi(this);
+
+	connect(this, SIGNAL(destroyed(QObject *)), SLOT(close()));
+
+	connect(actQuit, SIGNAL(activated()), SLOT(close()));
+	connect(actAbout, SIGNAL(activated()), SLOT(about()));
+	connect(pbBack, SIGNAL(clicked()), SLOT(back()));
+	connect(pbNext, SIGNAL(clicked()), SLOT(next()));
+	connect(pbCancel, SIGNAL(clicked()), SLOT(cancel()));
+
+	setupInterface = new SetupInterface(this, frame);
+	setupInterface->close();
+	selectMode = new SelectMode(this, frame);
+	selectMode->close();
+	netConfig = new NetConfig(this, frame);
+	netConfig->close();
+	selectMethod = new SelectMethod(this, frame);
+	selectMethod->close();
+	writeNfcConfig = new WriteNfcConfig(this, frame);
+	writeNfcConfig->close();
+	readNfcConfig = new ReadNfcConfig(this, frame);
+	readNfcConfig->close();
+	selectAp = new SelectAp(this, frame);
+	selectAp->close();
+	inputPin = new InputPin(this, frame);
+	inputPin->close();
+	displayPin = new DisplayPin(this, frame);
+	displayPin->close();
+	wpsAuthentication = new WpsAuthentication(this, frame);
+	wpsAuthentication->close();
+	wpsPbc = new WpsPbc(this, frame);
+	wpsPbc->close();
+
+	listPage.push_front(reinterpret_cast<PageTemplate *>(setupInterface));
+	listPage.front()->pre_next();
+	listPage.front()->show();
+
+	debugWindow = 0;
+	if (MainProcess::setDebugOut(this, SLOT(debugging()))) {
+		debugWindow = new DebugWindow();
+		QHBoxLayout *hl = new QHBoxLayout(debugWindow);
+		debugWindow->textEdit = new QTextEdit(debugWindow);
+		debugWindow->textEdit->setReadOnly(true);
+		hl->addWidget(debugWindow->textEdit);
+		debugWindow->setLayout(hl);
+		debugWindow->setGeometry(x(), y() + height() + 80,
+								 debugWindow->width(),
+								 debugWindow->height());
+		debugWindow->show();
+	}
+}
+
+TestbedSta::~TestbedSta()
+{
+	disconnect(actQuit);
+	disconnect(pbBack);
+	disconnect(pbNext);
+	disconnect(pbCancel);
+
+	delete setupInterface;
+	delete selectMode;
+	delete netConfig;
+	delete selectMethod;
+	delete writeNfcConfig;
+	delete readNfcConfig;
+	delete selectAp;
+	delete inputPin;
+	delete displayPin;
+	delete wpsAuthentication;
+	delete wpsPbc;
+}
+
+void TestbedSta::back()
+{
+	PageTemplate *p;
+
+	do {
+		if(!listPage.front()->post_back())
+			break;
+		p = listPage.front();
+		p->close();
+		listPage.pop_front();
+
+		if (!listPage.front()->pre_back()) {
+			if (!p->pre_next()) {
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+			listPage.push_front(p);
+			break;
+		}
+		listPage.front()->show();
+	} while (0);
+}
+
+void TestbedSta::next()
+{
+	PageTemplate *n = 0;
+
+	do {
+		if(!listPage.front()->post_next())
+			break;
+		listPage.front()->close();
+
+		if ((setupInterface == listPage.front()) ||
+			(writeNfcConfig == listPage.front()) ||
+			(readNfcConfig == listPage.front()) ||
+			(wpsPbc == listPage.front()) ||
+			(wpsAuthentication == listPage.front())) {
+			n = reinterpret_cast<PageTemplate *>(selectMode);
+		} if (selectMode == listPage.front()) {
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_CONFAP:
+			case MainProcess::MODE_MANUAL:
+				n = reinterpret_cast<PageTemplate *>(netConfig);
+				break;
+			case MainProcess::MODE_ENR:
+			case MainProcess::MODE_REG_REGAP:
+			case MainProcess::MODE_REG_REGSTA:
+				n = reinterpret_cast<PageTemplate *>(selectMethod);
+				break;
+			default:
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+		} else if (netConfig == listPage.front()) {
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_CONFAP:
+				n = reinterpret_cast<PageTemplate *>(selectMethod);
+				break;
+			case MainProcess::MODE_MANUAL:
+				n = reinterpret_cast<PageTemplate *>(wpsAuthentication);
+				break;
+			default:
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+		} else if (selectMethod == listPage.front()) {
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+				switch (MainProcess::getMode()) {
+				case MainProcess::MODE_REG_CONFAP:
+				case MainProcess::MODE_REG_REGSTA:
+					n = reinterpret_cast<PageTemplate *>(writeNfcConfig);
+					break;
+				case MainProcess::MODE_ENR:
+				case MainProcess::MODE_REG_REGAP:
+					n = reinterpret_cast<PageTemplate *>(readNfcConfig);
+					break;
+				default:
+					QMessageBox::critical(this, windowTitle(), "Critical Error");
+					break;
+				}
+				break;
+			case MainProcess::METHOD_PIN:
+				n = reinterpret_cast<PageTemplate *>(selectAp);
+				break;
+			case MainProcess::METHOD_PBC:
+				n = reinterpret_cast<PageTemplate *>(wpsPbc);
+				break;
+			default:
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+		} else if (selectAp == listPage.front()) {
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_ENR:
+				n = reinterpret_cast<PageTemplate *>(displayPin);
+				break;
+			case MainProcess::MODE_REG_CONFAP:
+			case MainProcess::MODE_REG_REGAP:
+			case MainProcess::MODE_REG_REGSTA:
+				n = reinterpret_cast<PageTemplate *>(inputPin);
+				break;
+			default:
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+		} else if (inputPin == listPage.front()) {
+			if ((MainProcess::MODE_REG_REGSTA == MainProcess::getMode()) &&
+				!pbBack->isEnabled())
+				n = reinterpret_cast<PageTemplate *>(selectMode);
+			else
+				n = reinterpret_cast<PageTemplate *>(wpsAuthentication);
+		} else if (displayPin == listPage.front()) {
+			n = reinterpret_cast<PageTemplate *>(wpsAuthentication);
+		}
+
+		if (n) {
+			if (!n->pre_next())
+				break;
+			listPage.push_front(n);
+		} else if (!listPage.front()->pre_next()) {
+			QMessageBox::critical(this, windowTitle(), "Critical Error");
+			break;
+		}
+		listPage.front()->show();
+	} while (0);
+}
+
+void TestbedSta::cancel()
+{
+	listPage.front()->cancel();
+}
+
+void TestbedSta::close()
+{
+	MainProcess::terminate();
+
+	if (debugWindow) {
+		debugWindow->close();
+		delete debugWindow;
+		debugWindow = 0;
+	}
+
+	QMainWindow::close();
+}
+
+void TestbedSta::closeEvent(QCloseEvent *)
+{
+	close();
+}
+
+void TestbedSta::about()
+{
+	About license(this);
+	license.exec();
+}
+
+void TestbedSta::debugging()
+{
+	QString out;
+	do {
+		while (1) {
+			out = MainProcess::readDebugMsg();
+			if (!out.length())
+				break;
+			if (debugWindow) {
+				out.remove(QChar('\n'));
+				out.remove(QChar('\r'));
+				debugWindow->textEdit->append(out);
+			}
+		}
+	} while (0);
+}
+
Index: testbed_sta/wpamsg.h
===================================================================
--- testbed_sta/wpamsg.h	(revision 0)
+++ testbed_sta/wpamsg.h	(revision 2)
@@ -0,0 +1,42 @@
+/*
+ * wpa_gui - WpaMsg class for storing event messages
+ * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef WPAMSG_H
+#define WPAMSG_H
+
+#include <QDateTime>
+#include <QLinkedList>
+
+class WpaMsg {
+public:
+	WpaMsg() {}
+	WpaMsg(const QString &_msg, int _priority = 2)
+		: msg(_msg), priority(_priority)
+	{
+		timestamp = QDateTime::currentDateTime();
+	}
+
+	QString getMsg() const { return msg; }
+	int getPriority() const { return priority; }
+	QDateTime getTimestamp() const { return timestamp; }
+
+private:
+	QString msg;
+	int priority;
+	QDateTime timestamp;
+};
+
+typedef QLinkedList<WpaMsg> WpaMsgList;
+
+#endif /* WPAMSG_H */
Index: testbed_sta/selectap.h
===================================================================
--- testbed_sta/selectap.h	(revision 0)
+++ testbed_sta/selectap.h	(revision 2)
@@ -0,0 +1,89 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: selectap.h
+//  Description: Select Access-Point header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef SELECTAP_H
+#define SELECTAP_H
+
+#include "ui_selectap.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+
+
+class SelectAp:
+public PageTemplate, public Ui::SelectAp
+{
+Q_OBJECT
+public:
+	SelectAp(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~SelectAp();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+	enum SELECT_AP_AREA {
+		SELECT_AP_AREA_NONE = 0,
+		SELECT_AP_AREA_INBAND,
+		SELECT_AP_AREA_WIRED_UPNP,
+		SELECT_AP_AREA_WIRELESS_UPNP
+	};
+
+private slots:
+	void selectArea(int selected);
+	void setInbandScan();
+	void setUpnpScan();
+
+	void update();
+	void progress();
+
+private:
+	void reset();
+	void displayList();
+	void displayInbandScanList();
+	void displayUpnpScanList();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+
+	int preArea;
+	enum SELECT_AP_AREA selectedArea;
+};
+
+#endif // SELECTAP_H
Index: testbed_sta/about.ui
===================================================================
--- testbed_sta/about.ui	(revision 0)
+++ testbed_sta/about.ui	(revision 2)
@@ -0,0 +1,103 @@
+<ui version="4.0" >
+ <class>About</class>
+ <widget class="QDialog" name="About" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>580</width>
+    <height>460</height>
+   </rect>
+  </property>
+  <property name="sizePolicy" >
+   <sizepolicy>
+    <hsizetype>0</hsizetype>
+    <vsizetype>0</vsizetype>
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>580</width>
+    <height>460</height>
+   </size>
+  </property>
+  <property name="maximumSize" >
+   <size>
+    <width>580</width>
+    <height>460</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string>Wi-Fi Protected Setup Station Application</string>
+  </property>
+  <widget class="QDialogButtonBox" name="buttonBox" >
+   <property name="geometry" >
+    <rect>
+     <x>20</x>
+     <y>412</y>
+     <width>541</width>
+     <height>38</height>
+    </rect>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="standardButtons" >
+    <set>QDialogButtonBox::Ok</set>
+   </property>
+   <property name="centerButtons" >
+    <bool>true</bool>
+   </property>
+  </widget>
+  <widget class="QTextEdit" name="textEdit" >
+   <property name="geometry" >
+    <rect>
+     <x>20</x>
+     <y>20</y>
+     <width>541</width>
+     <height>381</height>
+    </rect>
+   </property>
+   <property name="readOnly" >
+    <bool>true</bool>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>About</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>About</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
Index: testbed_sta/selectmethod.ui
===================================================================
--- testbed_sta/selectmethod.ui	(revision 0)
+++ testbed_sta/selectmethod.ui	(revision 2)
@@ -0,0 +1,103 @@
+<ui version="4.0" >
+ <class>SelectMethod</class>
+ <widget class="QWidget" name="SelectMethod" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>548</width>
+    <height>320</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>521</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Select Method</string>
+   </property>
+  </widget>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>531</width>
+     <height>110</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>12</number>
+    </property>
+    <item row="0" column="0" >
+     <widget class="QPushButton" name="pbNfc" >
+      <property name="text" >
+       <string>NFC Config Token</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QPushButton" name="pbPbc" >
+      <property name="text" >
+       <string>Push-Button</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QLabel" name="lblPbc" >
+      <property name="text" >
+       <string>Get configuration with Push-Button method</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QPushButton" name="pbPin" >
+      <property name="text" >
+       <string>PIN</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLabel" name="lblNfc" >
+      <property name="text" >
+       <string>Get configuration with NFC Config Token</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QLabel" name="lblPin" >
+      <property name="text" >
+       <string>Get configuration with PIN method</string>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>pbNfc</tabstop>
+  <tabstop>pbPin</tabstop>
+  <tabstop>pbPbc</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/inputpin.h
===================================================================
--- testbed_sta/inputpin.h	(revision 0)
+++ testbed_sta/inputpin.h	(revision 2)
@@ -0,0 +1,73 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: inputpin.h
+//  Description: Diplay PIN header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef INPUTPIN_H
+#define INPUTPIN_H
+
+#include "ui_inputpin.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class InputPin:
+public PageTemplate, public Ui::InputPin
+{
+Q_OBJECT
+public:
+	InputPin(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~InputPin();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+};
+
+#endif // INPUTPIN_H
Index: testbed_sta/win_if_list.h
===================================================================
--- testbed_sta/win_if_list.h	(revision 0)
+++ testbed_sta/win_if_list.h	(revision 2)
@@ -0,0 +1,57 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: win_if_list.h
+//  Description: interface list for windows header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WIN_IF_LIST_H
+#define WIN_IF_LIST_H
+
+struct win_if {
+	struct win_if *next;
+	char name[256];
+	char description[256];
+};
+
+typedef struct win_if win_if_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+int win_if_enum_devs(win_if_t **list);
+int win_if_list_free(win_if_t **list);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+
+#endif // WIN_IF_LIST_H
Index: testbed_sta/displaypin.cpp
===================================================================
--- testbed_sta/displaypin.cpp	(revision 0)
+++ testbed_sta/displaypin.cpp	(revision 2)
@@ -0,0 +1,252 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: displaypin.cpp
+//  Description: Diplay PIN source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "displaypin.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+#define WPS_IDENTITY_ENROLLEE	"WFA-SimpleConfig-Enrollee-1-0"
+#define WPS_IDENTITY_REGISTRAR	"WFA-SimpleConfig-Registrar-1-0"
+
+
+DisplayPin::DisplayPin(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+DisplayPin::~DisplayPin()
+{
+	delete timer;
+}
+
+bool DisplayPin::pre_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	progressBar->setFormat("Touch NFC token in 30 sec");
+	progressBar->update();
+
+	lblComment->setText("Input the following PIN to registrar, then push [Next] button.\n");
+
+	(void)MainProcess::clearWpsPassword();
+
+	MainProcess::connectMonitor(this, SLOT(receiveMsgs));
+	if (!MainProcess::writeNfcPassword(MainProcess::getNetworkIndex())) {
+		progressBar->setVisible(false);
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs));
+		QMessageBox::warning(this, label->text(),
+							 "Could not scan NFC token\n");
+	} else {
+		lblComment->setText(lblComment->text() + "Or touch NFC token to be written device password\n");
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(100);
+	}
+
+	return true;
+}
+
+bool DisplayPin::pre_next()
+{
+	char pin[9];
+
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	progressBar->setFormat("Touch NFC token in 30 sec");
+	progressBar->update();
+
+	MainProcess::generatePIN(pin);
+	lblPIN->setText(pin);
+
+	lblComment->setText("Input the following PIN to registrar, then push [Next] button.\n");
+
+	(void)MainProcess::clearWpsPassword();
+
+	MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+	if (!MainProcess::writeNfcPassword(MainProcess::getNetworkIndex())) {
+		progressBar->setVisible(false);
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		QMessageBox::warning(this, label->text(),
+							 "Could not scan NFC token\n");
+	} else {
+		lblComment->setText(lblComment->text() + "Or touch NFC token to be written device password\n");
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(100);
+	}
+
+	return true;
+}
+
+void DisplayPin::cancel()
+{
+	if (!wiz->pbCancel->text().compare("&Retry")) {
+		wiz->pbCancel->setText("&Cancel");
+
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		lblComment->setText("Input the following PIN to registrar, then push [Next] button.\n");
+
+		if (!MainProcess::writeNfcPassword(MainProcess::getNetworkIndex())) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+		} else {
+			lblComment->setText(lblComment->text() + "Or touch NFC token to be written device password\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+	} else {
+		MainProcess::cancelScanNfcToken();
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		wiz->close();
+	}
+}
+
+bool DisplayPin::post_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+bool DisplayPin::post_next()
+{
+	bool ret = false;
+	int index;
+
+
+	do {
+		index = MainProcess::getNetworkIndex();
+
+		if (!MainProcess::setNetworkParam(index, "key_mgmt", "IEEE8021X", false)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : key_mgmt.\n");
+			break;
+		}
+
+		if (!MainProcess::setNetworkParam(index, "eap", "WPS", false)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : eap.\n");
+			break;
+		}
+
+		if (!MainProcess::setNetworkParam(index, "identity", WPS_IDENTITY_ENROLLEE, true)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : eap.\n");
+			break;
+		}
+
+		if (!lblPIN->text().compare("Written on NFC Token.")) {
+			MainProcess::setNetworkParam(index, "password", "", true);
+		} else {
+			if (!MainProcess::setNetworkParam(index, "password", 
+											 (char *)((const char *)lblPIN->text().toAscii()), true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : password.\n");
+			}
+		}
+
+		wiz->pbCancel->setText("&Cancel");
+		MainProcess::cancelScanNfcToken();
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void DisplayPin::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_NFC_WRITE_TIMEOUT)) {
+			wiz->pbCancel->setText("&Retry");
+			progressBar->setFormat("Timeout");
+			progressBar->update();
+		} else if (!strcmp(req, CTRL_REQ_NFC_COMP_WRITE)) {
+			lblComment->setText("Complete to write device password on NFC token.\n"
+								"Touch a target registrar with the token, then push [Next] button.\n");
+			lblPIN->setText("Written on NFC Token.");
+
+			timer->stop();
+			progressBar->setVisible(false);
+		}
+	}
+}
+
+void DisplayPin::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void DisplayPin::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else
+		timer->stop();
+}
+
Index: testbed_sta/netconfig.cpp
===================================================================
--- testbed_sta/netconfig.cpp	(revision 0)
+++ testbed_sta/netconfig.cpp	(revision 2)
@@ -0,0 +1,385 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: netconfig.cpp
+//  Description: Network configuration source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "netconfig.h"
+#include "mainprocess.h"
+#include "testbedsta.h"
+
+#include <QMessageBox>
+
+#include <time.h>
+
+
+NetConfig::NetConfig(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	cmbAuth->addItem("Open");
+	cmbAuth->addItem("WPA-PSK");
+	cmbAuth->addItem("WPA2-PSK");
+
+	connect(cmbAuth, SIGNAL(currentIndexChanged(int)), SLOT(selectAuth(int)));
+	connect(cmbEncr, SIGNAL(currentIndexChanged(int)), SLOT(selectEncr(int)));
+	connect(pbGenSsid, SIGNAL(clicked()), SLOT(generateSsid()));
+	connect(pbGenNetKey, SIGNAL(clicked()), SLOT(generateNetKey()));
+
+	cmbAuth->setCurrentIndex(1);
+	cmbNetKeyIdx->addItem("1");
+	cmbNetKeyIdx->addItem("2");
+	cmbNetKeyIdx->addItem("3");
+	cmbNetKeyIdx->addItem("4");
+
+	srand(time(0));
+}
+
+NetConfig::~NetConfig()
+{
+}
+
+bool NetConfig::pre_back()
+{
+	MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	leSsid->setFocus();
+	return true;
+}
+
+bool NetConfig::pre_next()
+{
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_REG_CONFAP:
+		pbGenSsid->setVisible(true);
+		pbGenNetKey->setVisible(true);
+		break;
+	case MainProcess::MODE_MANUAL:
+		pbGenSsid->setVisible(false);
+		pbGenNetKey->setVisible(false);
+		break;
+	default:
+		return false;
+	}
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	leSsid->setText("");
+	leNetKey->setText("");
+
+	leSsid->setFocus();
+	return true;
+}
+
+bool NetConfig::post_next()
+{
+	bool ret = false;
+	char ssid[32 + 1], *key_mgmt = 0, *proto = 0,
+		 *pairwise = 0, wep_key_idx[0x10], netKey[64 + 1];
+	bool passphrase = false;
+
+	do {
+		if (!checkInputs()) {
+			QMessageBox::critical(this, label->text(), "Input error");
+			break;
+		}
+
+		MainProcess::setNetworkIndex(MainProcess::addNetwork());
+		if (0 > MainProcess::getNetworkIndex()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not add a network.\n");
+			break;
+		}
+
+		os_snprintf(ssid, sizeof(ssid), "%s", (const char *)leSsid->text().toAscii());
+		ssid[leSsid->text().length()] = 0;
+		if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "ssid", ssid, true)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : ssid.\n");
+			break;
+		}
+
+		switch (cmbAuth->currentIndex()) {
+		case 0:
+			key_mgmt = "NONE";
+			if (0 != cmbEncr->currentIndex()) {
+				os_snprintf(wep_key_idx, sizeof(wep_key_idx), "wep_key%d", cmbNetKeyIdx->currentText().toInt() - 1);
+				os_snprintf(netKey, sizeof(netKey), "%s", (const char *)leNetKey->text().toAscii());
+				netKey[leNetKey->text().length()] = 0;
+				if ((5 == leNetKey->text().length()) ||
+					(13 == leNetKey->text().length()))
+					passphrase = true;
+			}
+			break;
+		case 1:
+		case 2:
+			key_mgmt = "WPA-PSK";
+			proto = (char *)((1 == cmbAuth->currentIndex())?"WPA":"RSN");
+			pairwise = (char *)((0 == cmbEncr->currentIndex())?"TKIP":"CCMP");
+			os_snprintf(netKey, sizeof(netKey), "%s", (const char *)leNetKey->text().toAscii());
+			netKey[leNetKey->text().length()] = 0;
+			if (64 > leNetKey->text().length())
+				passphrase = true;
+			break;
+		default:
+			break;
+		}
+
+		if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "key_mgmt", key_mgmt, false)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : key_mgmt.\n");
+			break;
+		}
+
+		if (proto && !MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "proto", proto, false)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : proto.\n");
+			break;
+		}
+
+		if (pairwise && !MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "pairwise", pairwise, false)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : pairwise.\n");
+			break;
+		}
+
+		if (proto && leNetKey->isEnabled() && !MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "psk", netKey, passphrase)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set parameter : psk.\n");
+			break;
+		} else if (!proto && leNetKey->isEnabled() && cmbNetKeyIdx->isEnabled()) {
+			if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), wep_key_idx, netKey, passphrase)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : wep_key.\n");
+				break;
+			}
+
+			os_snprintf(wep_key_idx, sizeof(wep_key_idx), "%d", cmbNetKeyIdx->currentText().toInt() - 1);
+			if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "wep_tx_keyidx", wep_key_idx, false)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : wep_tx_keyidx.\n");
+				break;
+			}
+		}
+
+		if (MainProcess::MODE_REG_CONFAP == MainProcess::getMode())
+			(void)MainProcess::disableNetwork(MainProcess::getNetworkIndex());
+
+		if (!MainProcess::setWpsConfiguration(MainProcess::getNetworkIndex())) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set WPS network configuration.\n");
+			break;
+		}
+
+		if (MainProcess::MODE_MANUAL == MainProcess::getMode()) {
+			if (!MainProcess::connectNetwork(MainProcess::getNetworkIndex())) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not connect network.\n");
+			}
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+
+	return ret;
+}
+
+void NetConfig::cancel()
+{
+	wiz->close();
+}
+
+void NetConfig::selectAuth(int selected)
+{
+	cmbEncr->clear();
+	switch (selected) {
+	case 0:
+		cmbEncr->addItem("None");
+		cmbEncr->addItem("WEP");
+		leNetKey->setEnabled(false);
+		pbGenNetKey->setEnabled(false);
+		break;
+	case 1:
+	case 2:
+		cmbEncr->addItem("TKIP");
+		cmbEncr->addItem("CCMP");
+		leNetKey->setEnabled(true);
+		cmbEncr->setCurrentIndex(selected - 1);
+		pbGenNetKey->setEnabled(true);
+		cmbNetKeyIdx->setEnabled(false);
+		break;
+	default:
+		break;
+	}
+}
+
+void NetConfig::selectEncr(int selected)
+{
+	switch (cmbAuth->currentIndex()) {
+	case 0:	// Open
+		switch (selected) {
+		case 0:	// NONE
+			leNetKey->setEnabled(false);
+			pbGenNetKey->setEnabled(false);
+			break;
+		case 1:	// WEP
+			leNetKey->setEnabled(true);
+			pbGenNetKey->setEnabled(true);
+			cmbNetKeyIdx->setEnabled(true);
+			break;
+		default:
+			break;
+		}
+		break;
+	case 1:
+	case 2:
+	default:
+		break;
+	}
+}
+
+void NetConfig::generateSsid()
+{
+	char ssid[32 + 1];
+
+	for (int i = 0; i < 32; i++) {
+		ssid[i] = btoa(rand() % 16);
+	}
+	ssid[32] = 0;
+	leSsid->clear();
+	leSsid->setText(ssid);
+}
+
+void NetConfig::generateNetKey()
+{
+	char netKey[64 + 1] = {0};
+	int length = 0;
+
+	switch (cmbAuth->currentIndex()) {
+	case 0:	// Open
+		switch (cmbEncr->currentIndex()) {
+		case 0:	// NONE
+			break;
+		case 1:	// WEP
+			length = 26;
+			break;
+		default:
+			break;
+		}
+		break;
+	case 1:	// WPA-PSK
+	case 2:	// WPA2-PSK
+		length = 64;
+		break;
+	default:
+		break;
+	}
+
+	for (int i = 0; i < length; i++)
+		netKey[i] = btoa(rand() % 16);
+	netKey[length] = 0;
+	leNetKey->clear();
+	leNetKey->setText(netKey);
+}
+
+char NetConfig::btoa(int b, bool capital /* = true */ )
+{
+	if ((0 <= b) && (9 >= b)) {
+		return b + '0';
+	} else if ((0xA <= b) && (0xF >= b)) {
+		return (b - 0xA) + (capital?'A':'a');
+	} else {
+		return '0';
+	}
+}
+
+bool NetConfig::checkInputs()
+{
+	bool ret = false;
+	int i;
+
+	do {
+		if (!leSsid->text().length() || (32 < leSsid->text().length())) {
+			leSsid->setFocus();
+			break;
+		}
+
+		if (0 != cmbAuth->currentIndex()) {
+			/* WPA-PSK / WPA2-PSK */
+			if (64 == leNetKey->text().length()) {
+				for (i = 0; i < 64; i++) {
+					if (!isxdigit(*(const char *)(leNetKey->text().data() + i)))
+						break;
+				}
+				if (64 != i) {
+					leNetKey->setFocus();
+					break;
+				}
+			} else if (8 > leNetKey->text().length()) {
+				leNetKey->setFocus();
+				break;
+			}
+		} else if (0 != cmbEncr->currentIndex()) {
+			/* WEP */
+			if ((10 == leNetKey->text().length()) ||
+				(26 == leNetKey->text().length())) {
+				for (i = 0; i < leNetKey->text().length(); i++) {
+					if (!isxdigit(*(const char *)(leNetKey->text().data() + i)))
+						break;
+				}
+				if (leNetKey->text().length() != i) {
+					leNetKey->setFocus();
+					break;
+				}
+			} else if ((5 != leNetKey->text().length()) &&
+					   (13 != leNetKey->text().length())) {
+				leNetKey->setFocus();
+				break;
+			}
+		}
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
Index: testbed_sta/writenfcconfig.h
===================================================================
--- testbed_sta/writenfcconfig.h	(revision 0)
+++ testbed_sta/writenfcconfig.h	(revision 2)
@@ -0,0 +1,73 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: writenfcconfig.h
+//  Description: Read NFC config token header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WRITENFCCONFIG_H
+#define WRITENFCCONFIG_H
+
+#include "ui_writenfcconfig.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class WriteNfcConfig:
+public PageTemplate, public Ui::WriteNfcConfig
+{
+Q_OBJECT
+public:
+	WriteNfcConfig(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~WriteNfcConfig();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+};
+
+#endif // WRITENFCCONFIG_H
Index: testbed_sta/pagetemplate.h
===================================================================
--- testbed_sta/pagetemplate.h	(revision 0)
+++ testbed_sta/pagetemplate.h	(revision 2)
@@ -0,0 +1,60 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: pagetemplate.h
+//  Description: template of pages header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef PAGETEMPLATE_H
+#define PAGETEMPLATE_H
+
+#include <QWidget>
+
+
+class PageTemplate: public QWidget
+{
+Q_OBJECT
+public:
+	PageTemplate(QWidget *parent = 0, Qt::WindowFlags f = 0) : QWidget(parent, f) {};
+	~PageTemplate() {};
+
+public:
+	virtual bool pre_back() { return true; };
+	virtual bool pre_next() { return true; };
+	virtual bool pre_cancel() { return true; };
+
+	virtual bool post_back() { return true; };
+	virtual bool post_next() { return true; };
+	virtual bool post_cancel() { return true; };
+
+	virtual void cancel() { return; };
+};
+
+#endif /* PAGETEMPLATE_H */
Index: testbed_sta/wpsauthentication.h
===================================================================
--- testbed_sta/wpsauthentication.h	(revision 0)
+++ testbed_sta/wpsauthentication.h	(revision 2)
@@ -0,0 +1,73 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wpsauthentication.h
+//  Description: WPS authenticaiton header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPSAUTHENTICATION_H
+#define WPSAUTHENTICATION_H
+
+#include "ui_wpsauthentication.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class WpsAuthentication:
+public PageTemplate, public Ui::WpsAuthentication
+{
+Q_OBJECT
+public:
+	WpsAuthentication(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~WpsAuthentication();
+
+public:
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+
+	char pin[9];
+};
+
+#endif // WPSAUTHENTICATION_H
Index: testbed_sta/selectmode.ui
===================================================================
--- testbed_sta/selectmode.ui	(revision 0)
+++ testbed_sta/selectmode.ui	(revision 2)
@@ -0,0 +1,133 @@
+<ui version="4.0" >
+ <class>SelectMode</class>
+ <widget class="QWidget" name="SelectMode" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>548</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>531</width>
+     <height>190</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>12</number>
+    </property>
+    <item row="1" column="1" >
+     <widget class="QLabel" name="lblRegAp" >
+      <property name="text" >
+       <string>Register Access Point (AP) mode</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLabel" name="lblGetConfig" >
+      <property name="text" >
+       <string>Get configuration mode</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QPushButton" name="pbGetConfig" >
+      <property name="text" >
+       <string>&amp;Get Configuration</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QPushButton" name="pbRegSta" >
+      <property name="text" >
+       <string>Register Another &amp;Station</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLabel" name="lblConfigAp" >
+      <property name="text" >
+       <string>Configure Access Point (AP) mode</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QPushButton" name="pbRegAp" >
+      <property name="text" >
+       <string>Register &amp;Access Point</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QLabel" name="lblRegSta" >
+      <property name="text" >
+       <string>Register Another Station (STA) mode</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="0" >
+     <widget class="QPushButton" name="pbConfigAp" >
+      <property name="text" >
+       <string>&amp;Configure Access Point</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="0" >
+     <widget class="QPushButton" name="pbSetConfig" >
+      <property name="text" >
+       <string>Set configuration &amp;manually</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <widget class="QLabel" name="lblSetConfig" >
+      <property name="text" >
+       <string>Set configuration manually mode</string>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>521</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Select Mode</string>
+   </property>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>pbConfigAp</tabstop>
+  <tabstop>pbRegAp</tabstop>
+  <tabstop>pbRegSta</tabstop>
+  <tabstop>pbGetConfig</tabstop>
+  <tabstop>pbSetConfig</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/about.h
===================================================================
--- testbed_sta/about.h	(revision 0)
+++ testbed_sta/about.h	(revision 2)
@@ -0,0 +1,87 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: about.h
+//  Description: Display license header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef ABOUT_H
+#define ABOUT_H
+
+#include "ui_about.h"
+
+#include <QDialog>
+
+#define LICENSE \
+" Copyright(c) 2007, Sony Corporation. All rights reserved.\n" \
+"\n" \
+" Description: WiFi - Protected Setup Station Reference Application\n" \
+"\n" \
+"   Redistribution and use in source and binary forms, with or without\n" \
+"   modification, are permitted provided that the following conditions\n" \
+"   are met:\n" \
+"\n" \
+"     * Redistributions of source code must retain the above copyright\n" \
+"       notice, this list of conditions and the following disclaimer.\n" \
+"     * Redistributions in binary form must reproduce the above copyright\n" \
+"       notice, this list of conditions and the following disclaimer in\n" \
+"       the documentation and/or other materials provided with the\n" \
+"       distribution.\n" \
+"     * Neither the name of Sony Corporation nor the names of its\n" \
+"       contributors may be used to endorse or promote products derived\n" \
+"       from this software without specific prior written permission.\n" \
+"\n" \
+"   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n" \
+"   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n" \
+"   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n" \
+"   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n" \
+"   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n" \
+"   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n" \
+"   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n" \
+"   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n" \
+"   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n" \
+"   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n" \
+"   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n" \
+"\n"
+
+
+class About:
+public QDialog, public Ui::About
+{
+Q_OBJECT
+public:
+	About(QWidget *parent = 0, Qt::WindowFlags f = 0):QDialog(parent, f) {
+		setupUi(this);
+		textEdit->setText(LICENSE);
+	};
+	~About() {};
+};
+
+#endif // ABOUT_H
Index: testbed_sta/main.cpp
===================================================================
--- testbed_sta/main.cpp	(revision 0)
+++ testbed_sta/main.cpp	(revision 2)
@@ -0,0 +1,74 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: main.cpp
+//  Description: WiFi - Protected Setup Station main source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifdef CONFIG_NATIVE_WINDOWS
+#include <winsock.h>
+#endif /* CONFIG_NATIVE_WINDOWS */
+#include <QApplication>
+#include "testbedsta.h"
+
+int main(int argc, char *argv[])
+{
+	QApplication app(argc, argv);
+	TestbedSta *w;
+	int ret;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	WSADATA wsaData;
+	if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
+		printf("Could not find a usable WinSock.dll\n");
+		return -1;
+	}
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+	w = new TestbedSta;
+	if (NULL == w) {
+#ifdef CONFIG_NATIVE_WINDOWS
+		WSACleanup();
+#endif /* CONFIG_NATIVE_WINDOWS */
+		return -1;
+	}
+	w->show();
+	app.connect(&app, SIGNAL(lastWindowClosed()), &app, SLOT(quit()));
+	ret = app.exec();
+
+	delete w;
+	w = 0;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	WSACleanup();
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+	return ret;
+}
Index: testbed_sta/selectmethod.h
===================================================================
--- testbed_sta/selectmethod.h	(revision 0)
+++ testbed_sta/selectmethod.h	(revision 2)
@@ -0,0 +1,67 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: selectmethod.h
+//  Description: Select method header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef SELECTMETHOD_H
+#define SELECTMETHOD_H
+
+#include "ui_selectmethod.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+
+
+class SelectMethod:
+public PageTemplate, public Ui::SelectMethod
+{
+Q_OBJECT
+public:
+	SelectMethod(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~SelectMethod();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+private slots:
+	void selNfc();
+	void selPin();
+	void selPbc();
+
+private:
+	TestbedSta *wiz;
+};
+
+#endif // SELECTMETHOD_H
+
Index: testbed_sta/setupinterface.h
===================================================================
--- testbed_sta/setupinterface.h	(revision 0)
+++ testbed_sta/setupinterface.h	(revision 2)
@@ -0,0 +1,95 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: setupinterface.h
+//  Description: setup interface header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef SETUPINTERFACE_H
+#define SETUPINTERFACE_H
+
+#include "ui_setupinterface.h"
+#include "pagetemplate.h"
+
+#include <QRegExpValidator>
+
+#ifdef CONFIG_NATIVE_WINDOWS
+#include <QComboBox>
+#include "win_if_list.h"
+#endif // CONFIG_NATIVE_WINDOWS
+
+class TestbedSta;
+
+
+class SetupInterface:
+public PageTemplate, public Ui::SetupInterface
+{
+Q_OBJECT
+public:
+	SetupInterface(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~SetupInterface();
+
+	const char *getWirelessInterface();
+	const char *getWiredInterface();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	bool post_next();
+	void cancel();
+
+private:
+	TestbedSta *wiz;
+
+	QValidator *validator;
+	QValidator *validator2;
+	QValidator *validator3;
+	QValidator *validator4;
+	bool checkInputs();
+
+	bool end();
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	win_if_t *if_list;
+	QComboBox *cmbWInterface;
+
+	void displayWInterfaceList();
+#endif // CONFIG_NATIVE_WINDOWS
+
+private slots:
+	void enabledDhcp();
+	void enabledDhcp2();
+#ifdef CONFIG_NATIVE_WINDOWS
+	void selectWInterface(int index);
+#endif // CONFIG_NATIVE_WINDOWS
+
+};
+
+#endif // SETUPINTERFACE_H
Index: testbed_sta/readnfcconfig.cpp
===================================================================
--- testbed_sta/readnfcconfig.cpp	(revision 0)
+++ testbed_sta/readnfcconfig.cpp	(revision 2)
@@ -0,0 +1,217 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: readnfcconfig.cpp
+//  Description: Read NFC config token source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "readnfcconfig.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+ReadNfcConfig::ReadNfcConfig(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+ReadNfcConfig::~ReadNfcConfig()
+{
+	delete timer;
+}
+
+bool ReadNfcConfig::pre_back()
+{
+	label->setText("NFC Config method");
+
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool ReadNfcConfig::pre_next()
+{
+	bool ret = false;
+
+	label->setText("NFC Config method");
+
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+
+	do {
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+		if (!MainProcess::readNfcConfig()) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+			break;
+		} else {
+			lblComment->setText("Touch NFC config token to be read network configuration\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void ReadNfcConfig::cancel()
+{
+	if (!wiz->pbCancel->text().compare("&Retry")) {
+		wiz->pbCancel->setText("&Cancel");
+
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		if (!MainProcess::readNfcConfig()) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			wiz->close();
+		} else {
+			lblComment->setText("Touch NFC config token to be read network configuration\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+	} else {
+		MainProcess::cancelScanNfcToken();
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		wiz->close();
+	}
+}
+
+bool ReadNfcConfig::post_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+bool ReadNfcConfig::post_next()
+{
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+void ReadNfcConfig::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_NFC_READ_TIMEOUT)) {
+			timer->stop();
+
+			wiz->pbCancel->setText("&Retry");
+			progressBar->setFormat("Timeout");
+			progressBar->update();
+		} else if (!strcmp(req, CTRL_REQ_NFC_ADD_NEW_AP)) {
+			int index;
+			char ssid[33];
+
+			timer->stop();
+
+			index = atoi(msg + 1);
+
+			if (0 <= index) {
+				MainProcess::setNetworkIndex(index);
+				if (!MainProcess::getNetworkParam(index, "ssid", ssid, true)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not get parameter : ssid\n");
+				}
+				MainProcess::connectNetwork(MainProcess::getNetworkIndex());
+
+				label->setText("Complete");
+				lblComment->setText("Complete to read network configuration on NFC token.\n\nSSID : ");
+				lblComment->setText(lblComment->text() + ssid);
+				wiz->pbBack->setEnabled(false);
+				wiz->pbNext->setEnabled(true);
+				wiz->pbNext->setFocus();
+				progressBar->setVisible(false);
+			} else {
+				lblComment->setText("Fail to read network configuration on NFC token.\n"
+									"Probably the token is NOT config token, \n"
+									"or invalid format.\n");
+
+				wiz->pbCancel->setText("&Retry");
+				progressBar->setVisible(false);
+			}
+		}
+	}
+}
+
+void ReadNfcConfig::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void ReadNfcConfig::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else
+		timer->stop();
+}
+
Index: testbed_sta/mainprocess.h
===================================================================
--- testbed_sta/mainprocess.h	(revision 0)
+++ testbed_sta/mainprocess.h	(revision 2)
@@ -0,0 +1,229 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: mainprocess.h
+//  Description: main process control header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef MAINPROCESS_H
+#define MAINPROCESS_H
+
+#include <QProcess>
+#include <QMutex>
+#include <QThread>
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+#include <QSocketNotifier>
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+#include <QTimer>
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+#include "os.h"
+
+struct wpa_ctrl;
+
+#define CTRL_REQ_EAP_WPS_COMP		"EAP_WPS_COMP"
+#define CTRL_REQ_EAP_WPS_FAIL		"EAP_WPS_FAIL"
+#define CTRL_REQ_EAP_WPS_PASSWORD	"EAP_WPS_PASSWORD"
+
+#define CTRL_REQ_UPNP_COMP			"UPNP_COMP"
+#define CTRL_REQ_UPNP_FAIL			"UPNP_FAIL"
+#define CTRL_REQ_UPNP_PASSWORD		"UPNP_PASSWORD"
+
+#define CTRL_REQ_NFC_READ_TIMEOUT	"NFC_READ_TIMEOUT"
+#define CTRL_REQ_NFC_WRITE_TIMEOUT	"NFC_WRITE_TIMEOUT"
+#define CTRL_REQ_NFC_FAIL_READ		"NFC_FAIL_READ"
+#define CTRL_REQ_NFC_COMP_READ		"NFC_COMP_READ"
+#define CTRL_REQ_NFC_COMP_WRITE		"NFC_COMP_WRITE"
+#define CTRL_REQ_NFC_ADD_NEW_AP		"NFC_ADD_NEW_AP"
+
+
+class MainProcess
+{
+public:
+	MainProcess();
+	~MainProcess();
+
+	enum MODE {
+		MODE_ENR = 0,
+		MODE_REG_CONFAP,
+		MODE_REG_REGAP,
+		MODE_REG_REGSTA,
+		MODE_MANUAL
+	};
+
+	enum METHOD {
+		METHOD_NONE = 0,
+		METHOD_NFC,
+		METHOD_PIN,
+		METHOD_PBC
+	};
+
+	enum AREA {
+		AREA_BOTH_INBAND_UPNP = 0,
+		AREA_INBAND_ONLY,
+		AREA_UPNP_ONLY,
+	};
+
+	static bool start(const char *wi, const char *driver, const char *nfc);
+	static void terminate(bool enforced = false);
+
+private:
+	static int ctrlRequest(char *cmd, char *res, size_t *len);
+
+public:
+	static bool connectMonitor(QObject *receiver, const char *method);
+	static bool reconnectMonitor();
+	static bool disconnectMonitor(QObject *receiver, const char *method);
+
+	static bool ctrlPending();
+	static bool receive(char *msg, size_t *len);
+	static bool getCtrlRequelst(char *buf, size_t len, int *priority, char *req, char *msg);
+
+	static bool scanRequest();
+	static bool getScanResults(char *result, size_t *len);
+	static int addNetwork();
+	static bool removeNetwork(int index);
+	static bool setNetworkParam(int index, char *field, char *value, bool quote);
+	static bool getNetworkParam(int index, char *field, char *value, bool quote);
+
+	static bool connectNetwork(int index);
+	static bool disableNetwork(int index);
+
+	static bool setRegMode(int regmode);
+	static bool setWpsPassword(const char *pwd);
+	static bool setWpsConfiguration(int index);
+	static bool clearWpsPassword();
+
+	static bool setUpnpInterface(const char *ifname);
+	static bool isEnabledUpnp();
+	static bool setEnabledUpnp(bool enabled);
+	static bool upnpScanRequest();
+	static bool getUpnpScanResults(char *result, size_t *len);
+	static bool sendUpnpGetDevInfo(const char *control_url);
+	static bool sendSelectedRegistrar(const char *control_url, bool enabled);
+
+	static bool writeNfcConfig(int index);
+	static bool readNfcConfig();
+	static bool writeNfcPassword(int index);
+	static bool readNfcPassword(int index);
+	static bool cancelScanNfcToken();
+
+	static void generatePIN(char pwd[9]);
+	static bool validatePIN(const char pwd[9]);
+
+	static bool startPbc();
+	static bool stopPbc();
+
+	static bool setDebugOut(QObject *receiver, const char *method);
+	static QString readDebugMsg();
+
+	static void setWirelessInterface(const char *ifname) {
+		if (wirelessInterface) {
+			free(wirelessInterface);
+			wirelessInterface = 0;
+		}
+		if (ifname)
+			wirelessInterface = strdup(ifname);
+	};
+	static char *getWirelessInterface() { return wirelessInterface; };
+	static void setWiredInterface(const char *ifname) {
+		if (wiredInterface) {
+			free(wiredInterface);
+			wiredInterface = 0;
+		}
+		if (ifname)
+			wiredInterface = strdup(ifname);
+	};
+	static char *getWiredInterface() { return wiredInterface; };
+
+	static void setMode(MODE _mode) { mode = _mode; };
+	static MODE getMode() { return mode; };
+
+	static void setMethod(METHOD  _method) { method = _method; };
+	static METHOD getMethod() { return method; };
+
+	static void setArea(AREA  _area) { area = _area; };
+	static AREA getArea() { return area; };
+
+	static void setNetworkIndex(int index) { networkIndex = index; };
+	static int getNetworkIndex() { return networkIndex; };
+
+	static void setControlUrl(const char *control_url) {
+		if (controlUrl) {
+			free(controlUrl);
+			controlUrl = 0;
+		}
+		if (control_url)
+			controlUrl = strdup(control_url);
+	}
+	static char *getControlUrl() { return controlUrl; };
+
+private slots:
+	void receiveMsgs();
+
+private:
+	static QProcess	*mainProcess;
+
+	static struct wpa_ctrl *monitor;
+	static struct wpa_ctrl *ctrl;
+
+	static char *iface;
+
+	static QMutex *mtx;
+
+	static char *wirelessInterface;
+	static char *wiredInterface;
+
+	static MODE mode;
+	static METHOD method;
+	static AREA area;
+
+	static int networkIndex;
+	static char *controlUrl;
+	static bool enabledUpnp;
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	static QSocketNotifier *msgNotifier;
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+	static QTimer *msgNotifier;
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+};
+
+class UtilSleep : public QThread
+{
+public:
+	UtilSleep() {};
+	~UtilSleep() {};
+
+	static void sSleep(unsigned long sec) { QThread::sleep(sec); };
+	static void mSleep(unsigned long msec) { QThread::msleep(msec); };
+	static void uSleep(unsigned long usec) { QThread::usleep(usec); };
+};
+
+#endif // MAINPROCESS_H
Index: testbed_sta/selectmode.h
===================================================================
--- testbed_sta/selectmode.h	(revision 0)
+++ testbed_sta/selectmode.h	(revision 2)
@@ -0,0 +1,72 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: selectmede.h
+//  Description: Select mode header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef SELECTMODE_H
+#define SELECTMODE_H
+
+#include "ui_selectmode.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+
+
+class SelectMode:
+public PageTemplate, public Ui::SelectMode
+{
+Q_OBJECT
+public:
+	SelectMode(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~SelectMode();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+private slots:
+	void selConfigAp();
+	void selRegAp();
+	void selRegSta();
+	void selGetConfig();
+	void selSetConfig();
+
+
+private:
+	TestbedSta *wiz;
+};
+
+#endif // SELECTMODE_H
+
Index: testbed_sta/wpspbc.ui
===================================================================
--- testbed_sta/wpspbc.ui	(revision 0)
+++ testbed_sta/wpspbc.ui	(revision 2)
@@ -0,0 +1,86 @@
+<ui version="4.0" >
+ <class>WpsPbc</class>
+ <widget class="QWidget" name="WpsPbc" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>546</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>PBC method</string>
+   </property>
+  </widget>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>1200</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Processing</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>121</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/wpa_supplicant.conf
===================================================================
--- testbed_sta/wpa_supplicant.conf	(revision 0)
+++ testbed_sta/wpa_supplicant.conf	(revision 2)
@@ -0,0 +1,113 @@
+ctrl_interface=/var/run/wpa_supplicant
+update_config=0
+
+# wps_property : WPS property
+wps_property={
+	# verion : version of WPS
+	# 1.0 : 0x10
+	# 1.1 : 0x11
+	version=0x10
+
+	# uuid : this interface's UUID
+	# the length of uuid must be 16 bytes (hex)
+	uuid=000102030405060708090a0b0c0d0e0f
+
+	# auth_type_flags : capabilities of network authentication
+	# Open    : 0x0001
+	# WPAPSK  : 0x0002
+	# Shared  : 0x0004
+	# WPA     : 0x0008
+	# WPA2    : 0x0010
+	# WPA2PSK : 0x0020
+	auth_type_flags=0x0023
+
+	# encr_type_flags : capabilities of network encryption
+	# None : 0x0001
+	# WEP  : 0x0002
+	# TKIP : 0x0004
+	# AES  : 0x0008
+	encr_type_flags=0x000f
+
+	# conn_type_flags : capabilities of connection
+	# ESS  : 0x01
+	# IBSS : 0x02
+	conn_type_flags=0x01
+
+	# config_methods : supported configuration methods
+	# USBA                 : 0x0001
+	# Ethernet             : 0x0002
+	# Label                : 0x0004
+	# Display              : 0x0008
+	# External NFC Token   : 0x0010
+	# Integrated NFC Token : 0x0020
+	# NFC Interface        : 0x0040
+	# Push Button          : 0x0080
+	# Keypad               : 0x0100
+	config_methods=0x01ca
+
+	# wps_state : Wi-Fi Protected Setup State
+	# Not congigurad : 0x01
+	# Configured     : 0x02
+	# Reserved       : 0x00, 0x03 - 0xFF
+	wps_state=0x01
+
+	# rf_bands : supported RF bands
+	# 2.4GHz : 0x01
+	# 5.0GHz : 0x02
+	rf_bands=0x03
+
+	# manufacturer : the name of manufacturer
+	# the length of manufacturer must be less than 64 bytes
+	manufacturer="Sony"
+
+	# model_name : the name of model
+	# the length of model_name must be less than 32 bytes
+	model_name="WPS_SUPPLICANT_STATION"
+
+	# model_number : model number
+	# the length of model_number must be less than 32 bytes
+	model_number="01234567"
+
+	# serial_number : serial number
+	# the length of serial_number must be less than 32 bytes
+	serial_number="01234567"
+
+	# dev_category : device category
+	# dev_sub_category : device sub category
+	# category                    / sub category
+	# Computer               : 1  / PC                      : 1
+	#                             / Server                  : 2
+	#                             / Mddia Center            : 3
+	# Input Device           : 2  / do not set
+	# Printers, Scanners,
+	# Faxes and Copiers      : 3  / Printer                 : 1
+	#                             / Scanner                 : 2
+	# Camera                 : 4  / Digital Still Camera    : 1
+	# Storage                : 5  / NAS                     : 1
+	# Network Infrastructure : 6  / AP                      : 1
+	#                             / Router                  : 2
+	#                             / Switch                  : 3
+	# Displays               : 7  / Television              : 1
+	#                             / Electronc Picture Frame : 2
+	# Multimedia Devices     : 8  / DAR                     : 1
+	#                             / PVR                     : 2
+	#                             / MCX                     : 3
+	# Gaming Devices         : 9  / Xbox                    : 1
+	#                             / Xbox360                 : 2
+	#                             / Playstation             : 3
+	# Telephone              : 10 / Windows Moble           : 1
+	dev_category=1
+	dev_sub_category=1
+
+	# dev_oui : device OUI
+	# the length of dev_oui must be 4 bytes (hex)
+	dev_oui=0050f204
+
+	# dev_name : device name
+	# the length of dev_name must be less than 32 bytes (hex)
+	dev_name="SonyStation"
+
+	# dev_name : os_version
+	# for futures
+	os_version=0x00000001
+}
Index: testbed_sta/testbedsta.ui
===================================================================
--- testbed_sta/testbedsta.ui	(revision 0)
+++ testbed_sta/testbedsta.ui	(revision 2)
@@ -0,0 +1,195 @@
+<ui version="4.0" >
+ <class>TestbedSta</class>
+ <widget class="QMainWindow" name="TestbedSta" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>570</width>
+    <height>445</height>
+   </rect>
+  </property>
+  <property name="sizePolicy" >
+   <sizepolicy>
+    <hsizetype>0</hsizetype>
+    <vsizetype>0</vsizetype>
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>570</width>
+    <height>445</height>
+   </size>
+  </property>
+  <property name="maximumSize" >
+   <size>
+    <width>570</width>
+    <height>445</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string>WiFi - Protected Setup Station Application</string>
+  </property>
+  <widget class="QWidget" name="centralwidget" >
+   <widget class="QWidget" name="horizontalLayout" >
+    <property name="geometry" >
+     <rect>
+      <x>10</x>
+      <y>360</y>
+      <width>551</width>
+      <height>31</height>
+     </rect>
+    </property>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbBack" >
+       <property name="sizePolicy" >
+        <sizepolicy>
+         <hsizetype>7</hsizetype>
+         <vsizetype>0</vsizetype>
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Back</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbNext" >
+       <property name="sizePolicy" >
+        <sizepolicy>
+         <hsizetype>7</hsizetype>
+         <vsizetype>0</vsizetype>
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Next</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbCancel" >
+       <property name="sizePolicy" >
+        <sizepolicy>
+         <hsizetype>7</hsizetype>
+         <vsizetype>0</vsizetype>
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Cancel</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </widget>
+   <widget class="QFrame" name="frame" >
+    <property name="geometry" >
+     <rect>
+      <x>10</x>
+      <y>10</y>
+      <width>551</width>
+      <height>341</height>
+     </rect>
+    </property>
+    <property name="frameShadow" >
+     <enum>QFrame::Raised</enum>
+    </property>
+   </widget>
+  </widget>
+  <widget class="QMenuBar" name="menubar" >
+   <property name="geometry" >
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>570</width>
+     <height>27</height>
+    </rect>
+   </property>
+   <widget class="QMenu" name="menu_Application" >
+    <property name="title" >
+     <string>&amp;Application</string>
+    </property>
+    <addaction name="actQuit" />
+   </widget>
+   <widget class="QMenu" name="menu_Help" >
+    <property name="title" >
+     <string>&amp;Help</string>
+    </property>
+    <addaction name="actAbout" />
+   </widget>
+   <addaction name="menu_Application" />
+   <addaction name="menu_Help" />
+  </widget>
+  <widget class="QStatusBar" name="statusbar" />
+  <action name="actQuit" >
+   <property name="text" >
+    <string>&amp;Quit</string>
+   </property>
+  </action>
+  <action name="actAbout" >
+   <property name="text" >
+    <string>A&amp;bout</string>
+   </property>
+  </action>
+ </widget>
+ <tabstops>
+  <tabstop>pbNext</tabstop>
+  <tabstop>pbCancel</tabstop>
+  <tabstop>pbBack</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/selectap.cpp
===================================================================
--- testbed_sta/selectap.cpp	(revision 0)
+++ testbed_sta/selectap.cpp	(revision 2)
@@ -0,0 +1,428 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: apscanlist.cpp
+//  Description: Select Access-Point source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "selectap.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+SelectAp::SelectAp(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(pbUpdate, SIGNAL(clicked()), SLOT(update()));
+	connect(timer, SIGNAL(timeout()), SLOT(progress()));
+
+	connect(cmbSelArea, SIGNAL(currentIndexChanged(int)), SLOT(selectArea(int)));
+
+	pbUpdate->setText("Update");
+	progressBar->setVisible(false);
+
+	preArea = -1;
+	selectedArea = SELECT_AP_AREA_NONE;
+}
+
+SelectAp::~SelectAp()
+{
+	delete timer;
+}
+
+bool SelectAp::pre_back()
+{
+	if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+		MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+	}
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	displayList();
+
+	return true;
+}
+
+bool SelectAp::pre_next()
+{
+	bool ret = true;
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	if (preArea != MainProcess::getArea()) {
+		switch (MainProcess::getArea()) {
+		case MainProcess::AREA_BOTH_INBAND_UPNP:
+			cmbSelArea->clear();
+			cmbSelArea->addItem("In-band");
+			cmbSelArea->addItem("UPnP");
+			cmbSelArea->setEnabled(true);
+			cmbSelArea->setFocus();
+			break;
+		case MainProcess::AREA_INBAND_ONLY:
+			cmbSelArea->clear();
+			cmbSelArea->addItem("In-band");
+			cmbSelArea->setEnabled(false);
+			pbUpdate->setFocus();
+			break;
+		case MainProcess::AREA_UPNP_ONLY:
+			cmbSelArea->clear();
+#ifndef CONFIG_NATIVE_WINDOWS
+			cmbSelArea->addItem("Wired UPnP");
+			cmbSelArea->addItem("Wireless UPnP");
+			cmbSelArea->setEnabled(true);
+#else // CONFIG_NATIVE_WINDOWS
+			cmbSelArea->addItem("UPnP");
+			cmbSelArea->setEnabled(false);
+#endif // CONFIG_NATIVE_WINDOWS
+			pbUpdate->setFocus();
+			break;
+		default:
+			ret = false;
+			break;
+		}
+		selectArea(0);
+
+		if (ret) {
+			preArea = MainProcess::getArea();
+		}
+	}
+
+	return ret;
+}
+
+void SelectAp::cancel()
+{
+	reset();
+	wiz->close();
+}
+
+bool SelectAp::post_back()
+{
+	reset();
+	if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+		MainProcess::setEnabledUpnp(false);
+	}
+	return true;
+}
+
+bool SelectAp::post_next()
+{
+	bool ret = false;
+
+	do {
+		reset();
+		if (!apList->currentItem()) {
+			QMessageBox::warning(this, label->text(),
+								 "Select target AP first.\n");
+			break;
+		}
+
+		if (SELECT_AP_AREA_INBAND == selectedArea) {
+			MainProcess::setEnabledUpnp(false);
+
+			MainProcess::setNetworkIndex(MainProcess::addNetwork());
+			if (0 > MainProcess::getNetworkIndex()) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not add a network.\n");
+				break;
+			}
+
+			QTreeWidgetItem *item = apList->currentItem();
+			if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "ssid", (char *)((const char *)item->text(0).toAscii()), true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : ssid.\n");
+				break;
+			}
+
+			if (!MainProcess::setNetworkParam(MainProcess::getNetworkIndex(), "bssid", (char *)((const char *)item->text(1).toAscii()), false)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : bssid.\n");
+				break;
+			}
+		} else {
+			QTreeWidgetItem *item = apList->currentItem();
+			MainProcess::setControlUrl(item->text(0).toAscii());
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+
+	return ret;
+}
+
+void SelectAp::reset()
+{
+	pbUpdate->setText("Update");
+	timer->stop();
+	progressBar->setValue(0);
+	progressBar->setVisible(false);
+
+#ifndef CONFIG_NATIVE_WINDOWS
+	if (MainProcess::AREA_INBAND_ONLY != MainProcess::getArea())
+#else // CONFIG_NATIVE_WINDOWS
+	if (MainProcess::AREA_BOTH_INBAND_UPNP == MainProcess::getArea())
+#endif // CONFIG_NATIVE_WINDOWS
+		cmbSelArea->setEnabled(true);
+	apList->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+}
+
+void SelectAp::setInbandScan()
+{
+	QStringList header;
+	apList->setColumnCount(3);
+	header << "SSID" << "BSSID" << "Chanel";
+	apList->setHeaderLabels(header);
+	apList->setSortingEnabled(true);
+	apList->setColumnWidth(0, apList->width() / 3);
+	apList->setColumnWidth(1, apList->width() / 3);
+	apList->setColumnWidth(2, apList->width() / 3);
+
+}
+
+void SelectAp::setUpnpScan()
+{
+	QStringList header;
+	apList->setColumnCount(1);
+	header << "Control URL";
+	apList->setHeaderLabels(header);
+	apList->setSortingEnabled(true);
+
+}
+
+void SelectAp::displayList()
+{
+	if (!cmbSelArea->currentText().compare("In-band"))
+		displayInbandScanList();
+	else
+		displayUpnpScanList();
+}
+
+void SelectAp::displayInbandScanList()
+{
+	char res[0x1000];
+	size_t len = sizeof(res) - 1;
+	bool first = true;
+
+	if (!MainProcess::getScanResults(res, &len)) {
+		QMessageBox::warning(this, label->text(),
+							 "Could not get AP scan results.\n");
+		return;
+	}
+
+	apList->clear();
+
+	QStringList lines = QString(res).split(QChar('\n'));
+	for (QStringList::Iterator it = lines.begin();
+		 it != lines.end(); it++) {
+		if (first) {
+			first = false;
+			continue;
+		}
+
+		QStringList cols = it->split(QChar('\t'));
+		QString flags, ssid, bssid, freq, channel;
+
+		flags = cols.count() > 3?cols[3]:"";
+		if (flags.contains("WPS")) {
+			ssid = cols.count() > 4?cols[4]:"";
+			bssid = cols.count() > 0?cols[0]:"";
+			freq = cols.count() > 1?cols[1]:"";
+			if (freq.toULong() >= 5170) {
+				channel.setNum((freq.toULong() - 5170) / 5 + 34);
+			} else if (freq.toULong() >= 2412) {
+				channel.setNum((freq.toULong() - 2412) / 5 + 1);
+			} else
+				channel = "";
+
+			if (bssid.length()) {
+				QStringList item;
+				item << ssid << bssid << channel;
+				new QTreeWidgetItem(apList, item);
+			}
+		}
+	}
+}
+
+void SelectAp::displayUpnpScanList()
+{
+	char res[0x1000];
+	size_t len = sizeof(res) - 1;
+	bool first = true;
+
+	if (!MainProcess::getUpnpScanResults(res, &len)) {
+		QMessageBox::warning(this, label->text(),
+							 "Could not get AP scan results.\n");
+		return;
+	}
+
+	apList->clear();
+
+	QStringList lines = QString(res).split(QChar('\n'));
+	for (QStringList::Iterator it = lines.begin();
+		 it != lines.end(); it++) {
+		if (first) {
+			first = false;
+			continue;
+		}
+
+		QStringList cols = it->split(QChar('\t'));
+		QString ctrl_url, udn, manufacturer,
+				model_name, model_number, serial_number;
+
+		ctrl_url = cols.count() > 0?cols[0]:"";
+		udn = cols.count() > 1 ? cols[1] : "";
+		manufacturer = cols.count() > 2 ? cols[2] : "";
+		model_name = cols.count() > 3 ? cols[3] : "";
+		model_number = cols.count() > 4 ? cols[3] : "";
+		serial_number = cols.count() > 5 ? cols[4] : "";
+
+		if (ctrl_url.length()) {
+			QStringList item;
+			item << ctrl_url;
+			new QTreeWidgetItem(apList, item);
+		}
+	}
+}
+
+void SelectAp::update()
+{
+	if (!pbUpdate->text().compare("Update")) {
+		if (!cmbSelArea->currentText().compare("In-band")) {
+			if (!MainProcess::scanRequest()) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not scan AP.\n");
+				return;
+			}
+		} else {
+			if (!MainProcess::upnpScanRequest()) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not scan AP.\n");
+				return;
+			}
+		}
+
+		pbUpdate->setText("Stop");
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(1000);
+
+		cmbSelArea->setEnabled(false);
+		apList->setEnabled(false);
+		wiz->pbNext->setEnabled(false);
+	} else {
+		reset();
+		displayList();
+	}
+}
+
+void SelectAp::progress()
+{
+
+	if (progressBar->maximum() > progressBar->value()) {
+		progressBar->setValue(progressBar->value() + 1);
+	} else {
+		reset();
+		displayList();
+	}
+}
+
+void SelectAp::selectArea(int selected)
+{
+	char *upnpInterface;
+
+	if ((0 >= cmbSelArea->count()) ||
+		(cmbSelArea->count() <= selected))
+		return;
+
+	if (!cmbSelArea->currentText().compare("In-band")) {
+		setInbandScan();
+		displayInbandScanList();
+		selectedArea = SELECT_AP_AREA_INBAND;
+	} else {
+		if (MainProcess::isEnabledUpnp()) {
+			if (((selectedArea != SELECT_AP_AREA_WIRED_UPNP) &&
+				 (!cmbSelArea->currentText().compare("UPnP") ||
+				  !cmbSelArea->currentText().compare("Wired UPnP"))) ||
+				((selectedArea != SELECT_AP_AREA_WIRELESS_UPNP) &&
+				 !cmbSelArea->currentText().compare("Wireless UPnP"))) {
+				(void)MainProcess::setEnabledUpnp(false);
+			}
+		}
+
+		if (!cmbSelArea->currentText().compare("UPnP") ||
+			!cmbSelArea->currentText().compare("Wired UPnP")) {
+			upnpInterface = MainProcess::getWiredInterface();
+			selectedArea = SELECT_AP_AREA_WIRED_UPNP;
+		} else if (!cmbSelArea->currentText().compare("Wireless UPnP")) {
+			upnpInterface = MainProcess::getWirelessInterface();
+			selectedArea = SELECT_AP_AREA_WIRELESS_UPNP;
+		} else {
+			QMessageBox::warning(this, label->text(),
+								 "Unknown selected item in combobox.\n");
+			return;
+		}
+
+		if (!MainProcess::isEnabledUpnp()) {
+			if (!MainProcess::setUpnpInterface(upnpInterface)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set UPnP interface.");
+				cmbSelArea->setCurrentIndex(0);
+				return;
+			}
+
+			if (!MainProcess::setEnabledUpnp(true)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not be enabled UPnP.");
+					cmbSelArea->setCurrentIndex(0);
+				return;
+			}
+		}
+
+		setUpnpScan();
+		displayUpnpScanList();
+	}
+}
+
Index: testbed_sta/writenfcconfig.ui
===================================================================
--- testbed_sta/writenfcconfig.ui	(revision 0)
+++ testbed_sta/writenfcconfig.ui	(revision 2)
@@ -0,0 +1,86 @@
+<ui version="4.0" >
+ <class>WriteNfcConfig</class>
+ <widget class="QWidget" name="WriteNfcConfig" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>547</width>
+    <height>320</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>NFC Config method</string>
+   </property>
+  </widget>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>300</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Touch NFC Token in 30 sec</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>161</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/wpspbc.h
===================================================================
--- testbed_sta/wpspbc.h	(revision 0)
+++ testbed_sta/wpspbc.h	(revision 2)
@@ -0,0 +1,71 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wpspbc.h
+//  Description: WPS PBC header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPSPBC_H
+#define WPSPBC_H
+
+#include "ui_wpspbc.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class WpsPbc:
+public PageTemplate, public Ui::WpsPbc
+{
+Q_OBJECT
+public:
+	WpsPbc(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~WpsPbc();
+
+public:
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+};
+
+#endif // WPSPBC_H
Index: testbed_sta/setup-mingw-cross-compiling
===================================================================
--- testbed_sta/setup-mingw-cross-compiling	(revision 0)
+++ testbed_sta/setup-mingw-cross-compiling	(revision 2)
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+# qmake seems to be forcing include and lib paths from the original build
+# and I have no idea how to change these. For now, just override the
+# directories in the Makefile.Release file after qmake run.
+
+qmake -spec /q/jm/qt4-win/4.0.0/mkspecs/win32-g++ wpa_gui.pro -o Makefile
+cat Makefile.Release |
+    sed s%qt4/lib%qt4-win/4.0.0/lib%g |
+    sed s%qt4/include%qt4-win/4.0.0/include%g > tmp.Makefile.Release &&
+mv -f tmp.Makefile.Release Makefile.Release
Index: testbed_sta/testbed_sta.conf
===================================================================
--- testbed_sta/testbed_sta.conf	(revision 0)
+++ testbed_sta/testbed_sta.conf	(revision 2)
@@ -0,0 +1,6 @@
+ath0
+madwifi
+1,192.168.1.2,255.255.255.0
+1,/dev/ttyUSB0
+eth1
+1,192.168.0.2,255.255.255.0
Index: testbed_sta/wpsauthentication.ui
===================================================================
--- testbed_sta/wpsauthentication.ui	(revision 0)
+++ testbed_sta/wpsauthentication.ui	(revision 2)
@@ -0,0 +1,127 @@
+<ui version="4.0" >
+ <class>WpsAuthentication</class>
+ <widget class="QWidget" name="WpsAuthentication" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>546</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>1200</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Processing</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblPIN" >
+   <property name="geometry" >
+    <rect>
+     <x>64</x>
+     <y>192</y>
+     <width>471</width>
+     <height>21</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>00000000</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="label_2" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>192</y>
+     <width>51</width>
+     <height>21</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+     <weight>75</weight>
+     <italic>false</italic>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>PIN : </string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>WPS Authenticating ...</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>121</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/inputpin.cpp
===================================================================
--- testbed_sta/inputpin.cpp	(revision 0)
+++ testbed_sta/inputpin.cpp	(revision 2)
@@ -0,0 +1,346 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: inputpin.cpp
+//  Description: Input PIN source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "inputpin.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+#define WPS_IDENTITY_ENROLLEE	"WFA-SimpleConfig-Enrollee-1-0"
+#define WPS_IDENTITY_REGISTRAR	"WFA-SimpleConfig-Registrar-1-0"
+
+
+InputPin::InputPin(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+InputPin::~InputPin()
+{
+	delete timer;
+}
+
+bool InputPin::pre_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	label->setText("PIN method");
+	label_2->setVisible(true);
+	lePin->setVisible(true);
+	lePin->setFocus();
+
+	progressBar->setFormat("Touch NFC token in 30 sec");
+	progressBar->update();
+
+	if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode())
+		lblComment->setText("Input PIN of a target Station, \nthen push [Next] button.\n");
+	else
+		lblComment->setText("Input PIN of a target Access Point, \nthen push [Next] button.\n");
+
+	MainProcess::connectMonitor(this, SLOT(receiveMsgs));
+	if (!MainProcess::readNfcPassword(MainProcess::getNetworkIndex())) {
+		progressBar->setVisible(false);
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs));
+		QMessageBox::warning(this, label->text(),
+							 "Could not scan NFC token\n");
+	} else {
+		lblComment->setText(lblComment->text() + "Or touch NFC token to be read device password\n");
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(100);
+	}
+
+	return true;
+}
+
+bool InputPin::pre_next()
+{
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	lePin->setFocus();
+
+	progressBar->setFormat("Touch NFC token in 30 sec");
+	progressBar->update();
+
+	label->setText("PIN method");
+	label_2->setVisible(true);
+	lePin->clear();
+	lePin->setVisible(true);
+	lePin->setEnabled(true);
+
+	if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode())
+		lblComment->setText("Input PIN of a target Station, \nthen push [Next] button.\n");
+	else
+		lblComment->setText("Input PIN of a target Access Point, \nthen push [Next] button.\n");
+
+	MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+	if (!MainProcess::readNfcPassword(MainProcess::getNetworkIndex())) {
+		progressBar->setVisible(false);
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		QMessageBox::warning(this, label->text(),
+							 "Could not scan NFC token\n");
+	} else {
+		lblComment->setText(lblComment->text() + "Or touch NFC token to be read device password\n");
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(100);
+	}
+
+	return true;
+}
+
+void InputPin::cancel()
+{
+	if (!wiz->pbCancel->text().compare("&Retry")) {
+		wiz->pbCancel->setText("&Cancel");
+
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode())
+			lblComment->setText("Input PIN of a target Station, \nthen push [Next] button.\n");
+		else
+			lblComment->setText("Input PIN of a target Access Point, \nthen push [Next] button.\n");
+
+		if (!MainProcess::readNfcPassword(MainProcess::getNetworkIndex())) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+		} else {
+			lblComment->setText(lblComment->text() + "Or touch NFC token to be read device password\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+	} else {
+		MainProcess::cancelScanNfcToken();
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		if ((MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) ||
+			!wiz->pbBack->isEnabled()) {
+			wiz->close();
+		} else {
+			label->setText("Canceled by user indication");
+			lblComment->setText("Cancel WPS authentication.\n");
+			timer->stop();
+			wiz->pbBack->setEnabled(false);
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+			progressBar->setVisible(false);
+			label_2->setVisible(false);
+			lePin->clear();
+			lePin->setVisible(false);
+		}
+	}
+}
+
+bool InputPin::post_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+bool InputPin::post_next()
+{
+	bool ret = false;
+	do {
+		if ((MainProcess::MODE_REG_REGSTA == MainProcess::getMode()) &&
+			!lePin->isVisible()) {
+			ret = true;
+			break;
+		}
+
+		if (lePin->isEnabled()) {
+			if (!lePin->text().length()) {
+				lePin->setFocus();
+				if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode())
+					QMessageBox::warning(this, label->text(),
+										 "Should input PIN of a target Station.\n");
+				else
+					QMessageBox::warning(this, label->text(),
+										 "Should input PIN of a target Access Point.\n");
+				break;
+			}
+
+			if (8 == lePin->text().length()) {
+				if (!MainProcess::validatePIN(lePin->text().toAscii())) {
+					if (QMessageBox::No ==
+						QMessageBox::question(this, label->text(),
+								 "PIN has invalidate checksum.\n"
+								 "Do you really use this PIN?\n",
+								 QMessageBox::Yes|QMessageBox::No)) {
+						lePin->setFocus();
+						break;
+					}
+				}
+			}
+		}
+
+		if (MainProcess::isEnabledUpnp()) {
+			if (lePin->isEnabled()) {
+				if (!MainProcess::setWpsPassword(lePin->text().toAscii())) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set WPS password.\n");
+					break;
+				}
+			}
+
+			if (MainProcess::MODE_REG_CONFAP == MainProcess::getMode()) {
+				if (!MainProcess::sendUpnpGetDevInfo(MainProcess::getControlUrl())) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not send GetDeviceInfo thru UPnP.\n");
+					break;
+				}
+			} else if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode()) {
+				if (!MainProcess::setWpsConfiguration(MainProcess::getNetworkIndex())) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set WPS network configuration.\n");
+					break;
+				}
+
+				if (!MainProcess::sendSelectedRegistrar(MainProcess::getControlUrl(), true)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not send SelectedRegistrar thru UPnP.\n");
+					break;
+				}
+			}
+		} else if (0 <= MainProcess::getNetworkIndex()) {
+			int index = MainProcess::getNetworkIndex();
+			if (!MainProcess::setNetworkParam(index, "key_mgmt", "IEEE8021X", false)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : key_mgmt.\n");
+				break;
+			}
+
+			if (!MainProcess::setNetworkParam(index, "eap", "WPS", false)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : eap.\n");
+				break;
+			}
+
+			if (!MainProcess::setNetworkParam(index, "identity", WPS_IDENTITY_REGISTRAR, true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set parameter : eap.\n");
+				break;
+			}
+
+			if (!lePin->isEnabled()) {
+				MainProcess::setNetworkParam(index, "password", "", true);
+			} else {
+				if (!MainProcess::setNetworkParam(index, "password", 
+												 (char *)((const char *)lePin->text().toAscii()), true)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set parameter : password.\n");
+					break;
+				}
+			}
+		}
+
+		wiz->pbCancel->setText("&Cancel");
+		MainProcess::cancelScanNfcToken();
+		MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void InputPin::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_NFC_READ_TIMEOUT)) {
+			wiz->pbCancel->setText("&Retry");
+			progressBar->setFormat("Timeout");
+			progressBar->update();
+		} else if (!strcmp(req, CTRL_REQ_NFC_FAIL_READ)) {
+			timer->stop();
+			lblComment->setText("Fail to read network configuration on NFC token.\n"
+								"Probably the token is NOT config token, \n"
+								"or invalid format.\n");
+
+			wiz->pbCancel->setText("&Retry");
+			progressBar->setVisible(false);
+		} else if (!strcmp(req, CTRL_REQ_NFC_COMP_READ)) {
+			lblComment->setText("Complete to read device password on NFC token.\n");
+			lePin->setText("Read on NFC Token.");
+			lePin->setEnabled(false);
+
+			timer->stop();
+			progressBar->setVisible(false);
+			wiz->next();
+		}
+	}
+}
+
+void InputPin::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void InputPin::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else
+		timer->stop();
+}
+
Index: testbed_sta/displaypin.ui
===================================================================
--- testbed_sta/displaypin.ui	(revision 0)
+++ testbed_sta/displaypin.ui	(revision 2)
@@ -0,0 +1,126 @@
+<ui version="4.0" >
+ <class>DisplayPin</class>
+ <widget class="QWidget" name="DisplayPin" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>547</width>
+    <height>320</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>PIN method</string>
+   </property>
+  </widget>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>300</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Touch NFC Token in 30 sec</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblPIN" >
+   <property name="geometry" >
+    <rect>
+     <x>64</x>
+     <y>192</y>
+     <width>471</width>
+     <height>21</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>00000000</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>121</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+  <widget class="QLabel" name="label_2" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>192</y>
+     <width>56</width>
+     <height>21</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>PIN :</string>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/netconfig.ui
===================================================================
--- testbed_sta/netconfig.ui	(revision 0)
+++ testbed_sta/netconfig.ui	(revision 2)
@@ -0,0 +1,175 @@
+<ui version="4.0" >
+ <class>NetConfig</class>
+ <widget class="QWidget" name="NetConfig" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>548</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>76</width>
+    <height>0</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>521</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Network Configuration</string>
+   </property>
+  </widget>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>531</width>
+     <height>188</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>12</number>
+    </property>
+    <item row="4" column="0" >
+     <widget class="QLabel" name="label_6" >
+      <property name="text" >
+       <string>Network Key Index</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QComboBox" name="cmbAuth" />
+    </item>
+    <item row="2" column="0" >
+     <widget class="QLabel" name="label_4" >
+      <property name="text" >
+       <string>Encryption</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QComboBox" name="cmbEncr" />
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLineEdit" name="leSsid" >
+      <property name="maxLength" >
+       <number>32</number>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="2" >
+     <widget class="QPushButton" name="pbGenNetKey" >
+      <property name="text" >
+       <string>Generate</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="0" >
+     <widget class="QLabel" name="label_2" >
+      <property name="text" >
+       <string>SSID</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QLabel" name="label_3" >
+      <property name="text" >
+       <string>Authentication</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLineEdit" name="leNetKey" >
+      <property name="maxLength" >
+       <number>64</number>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="2" >
+     <widget class="QPushButton" name="pbGenSsid" >
+      <property name="text" >
+       <string>Generate</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QLabel" name="label_5" >
+      <property name="text" >
+       <string>Network Key</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <layout class="QHBoxLayout" >
+      <property name="margin" >
+       <number>0</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QComboBox" name="cmbNetKeyIdx" >
+        <property name="minimumSize" >
+         <size>
+          <width>76</width>
+          <height>0</height>
+         </size>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <spacer>
+        <property name="orientation" >
+         <enum>Qt::Horizontal</enum>
+        </property>
+        <property name="sizeType" >
+         <enum>QSizePolicy::Expanding</enum>
+        </property>
+        <property name="sizeHint" >
+         <size>
+          <width>40</width>
+          <height>20</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+     </layout>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>leSsid</tabstop>
+  <tabstop>pbGenSsid</tabstop>
+  <tabstop>cmbAuth</tabstop>
+  <tabstop>cmbEncr</tabstop>
+  <tabstop>leNetKey</tabstop>
+  <tabstop>pbGenNetKey</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/testbedsta.h
===================================================================
--- testbed_sta/testbedsta.h	(revision 0)
+++ testbed_sta/testbedsta.h	(revision 2)
@@ -0,0 +1,94 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: testbedsta.h
+//  Description: WiFi - Protected Setup Station graphical user interface header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef TESTBEDSTA_H
+#define TESTBEDSTA_H
+
+#include "ui_testbedsta.h"
+
+#include <QLinkedList>
+
+class PageTemplate;
+class SetupInterface;
+class SelectMode;
+class NetConfig;
+class SelectMethod;
+class WriteNfcConfig;
+class ReadNfcConfig;
+class SelectAp;
+class InputPin;
+class DisplayPin;
+class WpsAuthentication;
+class WpsPbc;
+class DebugWindow;
+
+
+class TestbedSta: public QMainWindow, public Ui::TestbedSta
+{
+Q_OBJECT
+public:
+	TestbedSta(QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~TestbedSta();
+
+public slots:
+	virtual void back();
+	virtual void next();
+	virtual void cancel();
+
+	virtual void close();
+	virtual void about();
+
+private slots:
+	void debugging();
+
+protected:
+	void closeEvent(QCloseEvent *);
+
+private:
+	QLinkedList<PageTemplate *> listPage;
+	SetupInterface *setupInterface;
+	SelectMode *selectMode;
+	NetConfig *netConfig;
+	SelectMethod *selectMethod;
+	WriteNfcConfig *writeNfcConfig;
+	ReadNfcConfig *readNfcConfig;
+	SelectAp* selectAp;
+	InputPin *inputPin;
+	DisplayPin *displayPin;
+	WpsAuthentication *wpsAuthentication;
+	WpsPbc *wpsPbc;
+	DebugWindow *debugWindow;
+};
+
+#endif // EXTREGISTRAR_H
Index: testbed_sta/writenfcconfig.cpp
===================================================================
--- testbed_sta/writenfcconfig.cpp	(revision 0)
+++ testbed_sta/writenfcconfig.cpp	(revision 2)
@@ -0,0 +1,229 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: writenfcconfig.cpp
+//  Description: Read NFC config token source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "writenfcconfig.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+WriteNfcConfig::WriteNfcConfig(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+WriteNfcConfig::~WriteNfcConfig()
+{
+	delete timer;
+}
+
+bool WriteNfcConfig::pre_back()
+{
+	label->setText("NFC Config method");
+
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool WriteNfcConfig::pre_next()
+{
+	bool ret = false;
+
+	label->setText("NFC Config method");
+
+	wiz->pbCancel->setText("&Cancel");
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+
+	do {
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+		if (!MainProcess::writeNfcConfig(MainProcess::getNetworkIndex())) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+			break;
+		} else {
+			lblComment->setText("Touch NFC config token to be written network configuration\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void WriteNfcConfig::cancel()
+{
+	if (!wiz->pbCancel->text().compare("&Retry")) {
+		wiz->pbCancel->setText("&Cancel");
+
+		progressBar->setFormat("Touch NFC token in 30 sec");
+		progressBar->update();
+
+		if (!MainProcess::writeNfcConfig(MainProcess::getNetworkIndex())) {
+			progressBar->setVisible(false);
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not scan NFC token\n");
+			if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+				MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+				wiz->close();
+			} else {
+				wiz->pbNext->setEnabled(true);
+			}
+		} else {
+			lblComment->setText("Touch NFC config token to be written network configuration\n");
+			progressBar->setValue(0);
+			progressBar->setVisible(true);
+			timer->start(100);
+		}
+	} else {
+		if (wiz->pbNext->isEnabled() ||
+			(MainProcess::MODE_REG_REGSTA != MainProcess::getMode())) {
+			MainProcess::cancelScanNfcToken();
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			wiz->close();
+		} else {
+			label->setText("Canceled by user indication");
+			lblComment->setText("Cancel to write network configuration on NFC token.\n");
+			timer->stop();
+			wiz->pbBack->setEnabled(false);
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+			progressBar->setVisible(false);
+		}
+	}
+}
+
+bool WriteNfcConfig::post_back()
+{
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+bool WriteNfcConfig::post_next()
+{
+	if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+		MainProcess::connectNetwork(MainProcess::getNetworkIndex());
+	}
+
+	wiz->pbCancel->setText("&Cancel");
+	MainProcess::cancelScanNfcToken();
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+void WriteNfcConfig::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_NFC_WRITE_TIMEOUT)) {
+			timer->stop();
+
+			wiz->pbCancel->setText("&Retry");
+			progressBar->setFormat("Timeout");
+			progressBar->update();
+		} else if (!strcmp(req, CTRL_REQ_NFC_COMP_WRITE)) {
+			char ssid[33];
+
+			timer->stop();
+
+			if (!MainProcess::getNetworkParam(MainProcess::getNetworkIndex(), "ssid", ssid, true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not get parameter : ssid\n");
+			}
+
+			label->setText("Complete");
+			lblComment->setText("Complete to write network configuration on NFC token.\n\nSSID : ");
+			lblComment->setText(lblComment->text() + ssid);
+			if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode())
+				lblComment->setText(lblComment->text() +
+									"\n\nTouch a target Station with the token, \nthen push [Next] button.\n");
+			else
+				lblComment->setText(lblComment->text() +
+									"\n\nTouch a target Access Point with the token, \nthen push [Next] button.\n");
+			wiz->pbBack->setEnabled(false);
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+			progressBar->setVisible(false);
+		}
+	}
+}
+
+void WriteNfcConfig::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len)) {
+			processCtrlRequest(msg, len);
+		}
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void WriteNfcConfig::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else
+		timer->stop();
+}
+
Index: testbed_sta/debugwindow.ui
===================================================================
--- testbed_sta/debugwindow.ui	(revision 0)
+++ testbed_sta/debugwindow.ui	(revision 2)
@@ -0,0 +1,18 @@
+<ui version="4.0" >
+ <class>DebugWindow</class>
+ <widget class="QWidget" name="DebugWindow" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>568</width>
+    <height>207</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Debug Window</string>
+  </property>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/wpsauthentication.cpp
===================================================================
--- testbed_sta/wpsauthentication.cpp	(revision 0)
+++ testbed_sta/wpsauthentication.cpp	(revision 2)
@@ -0,0 +1,269 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wpsauthentication.cpp
+//  Description: WPS authenticaiton source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "wpsauthentication.h"
+#include "testbedsta.h"
+#include "mainprocess.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+WpsAuthentication::WpsAuthentication(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), this, SLOT(increment()));
+}
+
+WpsAuthentication::~WpsAuthentication()
+{
+	delete timer;
+}
+
+bool WpsAuthentication::pre_next()
+{
+	bool ret = false;
+
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+
+	do {
+		if (MainProcess::MODE_MANUAL == MainProcess::getMode()) {
+			char ssid[33] = {0};
+
+			label->setText("Complete");
+			lblComment->setText("Complete set configuration manually.\n\nSSID : ");
+			if (!MainProcess::getNetworkParam(MainProcess::getNetworkIndex(), "ssid", ssid, true))
+				QMessageBox::warning(this, label->text(), "Could not get parameter : ssid\n");
+			else
+				lblComment->setText(lblComment->text() + ssid);
+
+			wiz->pbCancel->setText("E&xit");
+			label_2->setVisible(false);
+			lblPIN->setVisible(false);
+			progressBar->setVisible(false);
+			ret = true;
+			break;
+		} else
+			label->setText("WPS Authenticating ...");
+
+		if (MainProcess::isEnabledUpnp())
+			pin[0] = 0;
+		else if (!MainProcess::getNetworkParam(MainProcess::getNetworkIndex(), "password", pin, true))
+			pin[0] = 0;
+
+		MainProcess::connectMonitor(this, SLOT(receiveMsgs()));
+		if (!MainProcess::isEnabledUpnp() && !MainProcess::connectNetwork(MainProcess::getNetworkIndex())) {
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+			QMessageBox::warning(this, label->text(),
+								 "Could not start WPS authentication\n");
+			break;
+		}
+		progressBar->setValue(0);
+		progressBar->setVisible(true);
+		timer->start(100);
+
+		ret = true;
+
+		lblPIN->setText(pin);
+		if (lblPIN->text().length())
+			label_2->setVisible(true);
+		else
+			label_2->setVisible(false);
+
+		lblComment->setText("Try to authenticate in 2 minutes\n");
+	} while (0);
+
+	return ret;
+}
+
+void WpsAuthentication::cancel()
+{
+	if (!wiz->pbCancel->text().compare("&Cancel") &&
+		timer->isActive()) {
+		timer->stop();
+
+		if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+			MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+		} else {
+			MainProcess::sendSelectedRegistrar(MainProcess::getControlUrl(), false);
+			wiz->pbNext->setEnabled(true);
+		}
+
+		label->setText("Canceled by user indication");
+		label_2->setVisible(false);
+		lblPIN->setVisible(false);
+		progressBar->setVisible(false);
+		lblComment->setText("Cancel WPS authentication.\n");
+	} else {
+		if (MainProcess::MODE_MANUAL != MainProcess::getMode())
+			MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+		wiz->close();
+	}
+}
+
+bool WpsAuthentication::post_next()
+{
+	MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+	return true;
+}
+
+void WpsAuthentication::processCtrlRequest(char *buf, size_t len)
+{
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!strcmp(req, CTRL_REQ_EAP_WPS_FAIL)) {
+			timer->stop();
+
+			MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+
+			label->setText("Fail");
+			lblComment->setText("Fail WPS authentication");
+			label_2->setVisible(false);
+			lblPIN->setVisible(false);
+			progressBar->setVisible(false);
+		} else if (!strcmp(req, CTRL_REQ_EAP_WPS_COMP)) {
+			int index = atoi(msg + 1);
+			char ssid[33] = {0};
+
+			timer->stop();
+			UtilSleep::mSleep(500);
+
+			MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+
+			if (!MainProcess::getNetworkParam(index, "ssid", ssid, true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not get parameter : ssid\n");
+			}
+			MainProcess::setNetworkIndex(index);
+			MainProcess::connectNetwork(MainProcess::getNetworkIndex());
+
+			label->setText("Complete");
+			lblComment->setText("Complete WPS Authentication.\n\nSSID : ");
+			lblComment->setText(lblComment->text() + ssid);
+			label_2->setVisible(false);
+			lblPIN->setVisible(false);
+			progressBar->setVisible(false);
+
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+		} else if (!strcmp(req, CTRL_REQ_UPNP_FAIL)) {
+			timer->stop();
+			MainProcess::sendSelectedRegistrar(MainProcess::getControlUrl(), false);
+
+			label->setText("Fail");
+			lblComment->setText("Fail WPS authentication thru UPnP");
+			if (MainProcess::MODE_REG_REGSTA == MainProcess::getMode()) {
+				wiz->pbNext->setEnabled(true);
+				wiz->pbNext->setFocus();
+			}
+			label_2->setVisible(false);
+			lblPIN->setVisible(false);
+			progressBar->setVisible(false);
+		} else if (!strcmp(req, CTRL_REQ_UPNP_COMP)) {
+			int index = atoi(msg + 1);
+			char ssid[33] = {0};
+
+			timer->stop();
+			MainProcess::sendSelectedRegistrar(MainProcess::getControlUrl(), false);
+			MainProcess::setNetworkIndex(index);
+			if (!MainProcess::getNetworkParam(MainProcess::getNetworkIndex(), "ssid", ssid, true)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not get parameter : ssid\n");
+			}
+
+			if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+				MainProcess::connectNetwork(MainProcess::getNetworkIndex());
+			}
+
+			label->setText("Complete");
+			lblComment->setText("Complete WPS Authentication thru UPnP.\n\nSSID : ");
+			lblComment->setText(lblComment->text() + ssid);
+			label_2->setVisible(false);
+			lblPIN->setVisible(false);
+			progressBar->setVisible(false);
+
+			wiz->pbNext->setEnabled(true);
+			wiz->pbNext->setFocus();
+		} 
+	}
+}
+
+void WpsAuthentication::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+	MainProcess::reconnectMonitor();
+}
+
+void WpsAuthentication::increment()
+{
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else {
+		timer->stop();
+
+		if (MainProcess::MODE_REG_REGSTA != MainProcess::getMode()) {
+			MainProcess::removeNetwork(MainProcess::getNetworkIndex());
+		}
+
+		label_2->setVisible(false);
+		lblPIN->setVisible(false);
+		label->setText("Timeout");
+		progressBar->setFormat("Timeout");
+		progressBar->update();
+		lblComment->setText("Timeout WPS Authentication.\n"
+							"Could not authenticate in 2 minutes\n");
+		if (MainProcess::isEnabledUpnp()) {
+			MainProcess::sendSelectedRegistrar(MainProcess::getControlUrl(), false);
+			wiz->pbNext->setEnabled(true);
+		}
+	}
+}
+
Index: testbed_sta/setupinterface.ui
===================================================================
--- testbed_sta/setupinterface.ui	(revision 0)
+++ testbed_sta/setupinterface.ui	(revision 2)
@@ -0,0 +1,252 @@
+<ui version="4.0" >
+ <class>SetupInterface</class>
+ <widget class="QWidget" name="SetupInterface" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>548</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>551</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Setup Interface</string>
+   </property>
+  </widget>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>531</width>
+     <height>240</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="leftMargin" >
+     <number>0</number>
+    </property>
+    <property name="topMargin" >
+     <number>0</number>
+    </property>
+    <property name="rightMargin" >
+     <number>0</number>
+    </property>
+    <property name="bottomMargin" >
+     <number>0</number>
+    </property>
+    <property name="horizontalSpacing" >
+     <number>12</number>
+    </property>
+    <property name="verticalSpacing" >
+     <number>12</number>
+    </property>
+    <item row="3" column="1" >
+     <widget class="QLineEdit" name="leNFCInterface" >
+      <property name="text" >
+       <string>/dev/ttyUSB0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QCheckBox" name="cbNFCInterface" >
+      <property name="text" >
+       <string>NFC interface</string>
+      </property>
+      <property name="checked" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QCheckBox" name="cbIPAddress" >
+      <property name="toolTip" >
+       <string>Unchecked if using DHCP</string>
+      </property>
+      <property name="text" >
+       <string>wireless IP address</string>
+      </property>
+      <property name="checked" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLineEdit" name="leWInterface" >
+      <property name="text" >
+       <string>ath0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <widget class="QLineEdit" name="leInterface2" >
+      <property name="text" >
+       <string>eth0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="0" >
+     <widget class="QLabel" name="label_2" >
+      <property name="text" >
+       <string>wireless interface</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="0" >
+     <widget class="QLabel" name="label_4" >
+      <property name="text" >
+       <string>wired interface</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QLineEdit" name="leWDriver" >
+      <property name="enabled" >
+       <bool>false</bool>
+      </property>
+      <property name="text" >
+       <string>madwifi</string>
+      </property>
+      <property name="readOnly" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="0" >
+     <widget class="QCheckBox" name="cbIPAddress2" >
+      <property name="text" >
+       <string>wired IP address</string>
+      </property>
+      <property name="checked" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QLabel" name="label_3" >
+      <property name="text" >
+       <string>wireless driver</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <layout class="QHBoxLayout" >
+      <property name="spacing" >
+       <number>12</number>
+      </property>
+      <property name="leftMargin" >
+       <number>0</number>
+      </property>
+      <property name="topMargin" >
+       <number>0</number>
+      </property>
+      <property name="rightMargin" >
+       <number>0</number>
+      </property>
+      <property name="bottomMargin" >
+       <number>0</number>
+      </property>
+      <item>
+       <widget class="QLineEdit" name="leIPAddress" >
+        <property name="inputMask" >
+         <string/>
+        </property>
+        <property name="text" >
+         <string>192.168.1.2</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLabel" name="label_5" >
+        <property name="text" >
+         <string>net mask</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLineEdit" name="leNetMask" >
+        <property name="text" >
+         <string>255.255.255.0</string>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </item>
+    <item row="5" column="1" >
+     <layout class="QHBoxLayout" >
+      <property name="spacing" >
+       <number>12</number>
+      </property>
+      <property name="leftMargin" >
+       <number>0</number>
+      </property>
+      <property name="topMargin" >
+       <number>0</number>
+      </property>
+      <property name="rightMargin" >
+       <number>0</number>
+      </property>
+      <property name="bottomMargin" >
+       <number>0</number>
+      </property>
+      <item>
+       <widget class="QLineEdit" name="leIPAddress2" >
+        <property name="text" >
+         <string>192.168.0.2</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLabel" name="label_6" >
+        <property name="text" >
+         <string>net mask</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLineEdit" name="leNetMask2" >
+        <property name="text" >
+         <string>255.255.255.0</string>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>leWInterface</tabstop>
+  <tabstop>leWDriver</tabstop>
+  <tabstop>cbIPAddress</tabstop>
+  <tabstop>leIPAddress</tabstop>
+  <tabstop>leNetMask</tabstop>
+  <tabstop>cbNFCInterface</tabstop>
+  <tabstop>leNFCInterface</tabstop>
+  <tabstop>leInterface2</tabstop>
+  <tabstop>cbIPAddress2</tabstop>
+  <tabstop>leIPAddress2</tabstop>
+  <tabstop>leNetMask2</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/testbed_sta.pro
===================================================================
--- testbed_sta/testbed_sta.pro	(revision 0)
+++ testbed_sta/testbed_sta.pro	(revision 2)
@@ -0,0 +1,88 @@
+LANGUAGE	= C++
+
+CONFIG	+= qt warn_on release
+
+DEFINES += CONFIG_CTRL_IFACE WPS_OPT_UPNP WPS_OPT_NFC
+
+win32 {
+  # cross compilation to win32 with vs2005
+  TEMPLATE = vcapp
+  LIBS += ws2_32.lib \dev\WpdPack\lib\wpcap.lib
+  DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE USE_WINIFLIST
+  SOURCES += ../win_if_list.c
+  HEADERS += win_if_list.h
+  INCLUDEPATH += \dev\WpdPack\include
+} else:win32-g++ {
+  # cross compilation to win32
+  TEMPLATE = app
+  LIBS += ws2_32.lib \dev\WpdPack\lib\wpcap.lib
+  DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE USE_WINIFLIST
+  SOURCES += ../win_if_list.c
+  HEADERS += win_if_list.h
+  INCLUDEPATH += \dev\WpdPack\include
+} else {
+  TEMPLATE = app
+  DEFINES += CONFIG_CTRL_IFACE_UNIX
+}
+
+INCLUDEPATH	+= . .. ../../hostapd
+
+HEADERS	+= \
+	testbedsta.h \
+	about.h \
+	mainprocess.h \
+	pagetemplate.h \
+	setupinterface.h \
+	selectmode.h \
+	netconfig.h \
+	selectmethod.h \
+	writenfcconfig.h \
+	readnfcconfig.h \
+	selectap.h \
+	inputpin.h \
+	displaypin.h \
+	wpsauthentication.h \
+	wpspbc.h \
+	debugwindow.h \
+	wpamsg.h \
+
+SOURCES	+= \
+	main.cpp \
+	testbedsta.cpp \
+	mainprocess.cpp \
+	setupinterface.cpp \
+	selectmode.cpp \
+	netconfig.cpp \
+	selectmethod.cpp \
+	writenfcconfig.cpp \
+	readnfcconfig.cpp \
+	selectap.cpp \
+	inputpin.cpp \
+	displaypin.cpp \
+	wpsauthentication.cpp \
+	wpspbc.cpp \
+	../wpa_ctrl.c \
+
+FORMS	= \
+	testbedsta.ui \
+	about.ui \
+	setupinterface.ui \
+	selectmode.ui \
+	netconfig.ui \
+	selectmethod.ui \
+	writenfcconfig.ui \
+	readnfcconfig.ui \
+	selectap.ui \
+	inputpin.ui \
+	displaypin.ui \
+	wpsauthentication.ui \
+	wpspbc.ui \
+	debugwindow.ui \
+
+
+unix {
+  UI_DIR = .ui
+  MOC_DIR = .moc
+  OBJECTS_DIR = .obj
+}
+
Index: testbed_sta/selectmethod.cpp
===================================================================
--- testbed_sta/selectmethod.cpp	(revision 0)
+++ testbed_sta/selectmethod.cpp	(revision 2)
@@ -0,0 +1,161 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: selectmethod.cpp
+//  Description: Select method source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "selectmethod.h"
+#include "mainprocess.h"
+#include "testbedsta.h"
+
+#include <QMessageBox>
+
+
+SelectMethod::SelectMethod(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	connect(pbNfc, SIGNAL(clicked()), SLOT(selNfc())); 
+	connect(pbPin, SIGNAL(clicked()), SLOT(selPin())); 
+	connect(pbPbc, SIGNAL(clicked()), SLOT(selPbc())); 
+}
+
+SelectMethod::~SelectMethod()
+{
+}
+
+bool SelectMethod::pre_back()
+{
+	MainProcess::setMethod(MainProcess::METHOD_NONE);
+
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_ENR:
+		lblNfc->setText("Get configure with NFC Config Token");
+		lblPin->setText("Get configure with PIN method");
+		lblPbc->setText("Get configure with Push-Button method");
+		pbPbc->setVisible(true);
+		lblPbc->setVisible(true);
+		break;
+	case MainProcess::MODE_REG_CONFAP:
+		lblNfc->setText("Configure Access Point with NFC Config Token");
+		lblPin->setText("Configure Access Point with PIN method");
+		lblPbc->setText("Configure Access Point with Push-Button method");
+		pbPbc->setVisible(true);
+		lblPbc->setVisible(true);
+		break;
+	case MainProcess::MODE_REG_REGAP:
+		lblNfc->setText("Register Access Point with NFC Config Token");
+		lblPin->setText("Register Access Point with PIN method");
+		lblPbc->setText("Register Access Point with Push-Button method");
+		pbPbc->setVisible(true);
+		lblPbc->setVisible(true);
+		break;
+	case MainProcess::MODE_REG_REGSTA:
+		lblNfc->setText("Register Another Station with NFC Config Token");
+		lblPin->setText("Register Another Station Point with PIN method");
+		pbPbc->setVisible(false);
+		lblPbc->setVisible(false);
+		break;
+	default:
+		break;
+	}
+
+	pbNfc->setFocus();
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool SelectMethod::pre_next()
+{
+	MainProcess::setMethod(MainProcess::METHOD_NONE);
+
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_REG_CONFAP:
+		lblNfc->setText("Configure Access Point with NFC Config Token");
+		lblPin->setText("Configure Access Point with PIN method");
+		lblPbc->setText("Configure Access Point with Push-Button method");
+		pbPbc->setVisible(true);
+		lblPbc->setVisible(true);
+		break;
+	case MainProcess::MODE_REG_REGAP:
+		lblNfc->setText("Register Access Point with NFC Config Token");
+		lblPin->setText("Register Access Point with PIN method");
+		lblPbc->setText("Register Access Point with Push-Button method");
+		pbPbc->setVisible(true);
+		lblPbc->setVisible(true);
+		break;
+	case MainProcess::MODE_REG_REGSTA:
+		lblNfc->setText("Register Another Station with NFC Config Token");
+		lblPin->setText("Register Another Station Point with PIN method");
+		pbPbc->setVisible(false);
+		lblPbc->setVisible(false);
+		break;
+	default:
+		break;
+	}
+
+	pbNfc->setFocus();
+
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+void SelectMethod::cancel()
+{
+	wiz->close();
+}
+
+void SelectMethod::selNfc()
+{
+	MainProcess::setMethod(MainProcess::METHOD_NFC);
+	wiz->next();
+}
+
+void SelectMethod::selPin()
+{
+	MainProcess::setMethod(MainProcess::METHOD_PIN);
+	wiz->next();
+}
+
+void SelectMethod::selPbc()
+{
+	MainProcess::setMethod(MainProcess::METHOD_PBC);
+	wiz->next();
+}
+
Index: testbed_sta/setupinterface.cpp
===================================================================
--- testbed_sta/setupinterface.cpp	(revision 0)
+++ testbed_sta/setupinterface.cpp	(revision 2)
@@ -0,0 +1,513 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: setupinterface.cpp
+//  Description: setup interface source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "setupinterface.h"
+#include "mainprocess.h"
+#include "testbedsta.h"
+
+#include <QMessageBox>
+#include <QProcess>
+#include <QFile>
+
+
+SetupInterface::SetupInterface(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+#ifndef CONFIG_NATIVE_WINDOWS
+#define CONFIG_FILE "./testbed_sta.conf"
+#define DEFAULT_WIRELESS_INTERFACE "ath0"
+#define DEFAULT_WIRELESS_DRIVER "madwifi"
+#define DEFAULT_IPADDRESS "192.168.1.2"
+#define DEFAULT_NFC_INTERFACE "/dev/ttyUSB0"
+#define DEFAULT_WIRED_INTERFACE "eth0"
+#define DEFAULT_IPADDRESS2 "192.168.0.2"
+#define DEFAULT_NETMASK "255.255.255.0"
+#else // CONFIG_NATIVE_WINDOWS
+#define CONFIG_FILE ".\\testbed_sta.conf"
+#define DEFAULT_WIRELESS_INTERFACE ""
+#define DEFAULT_WIRELESS_DRIVER "ndis"
+#define DEFAULT_IPADDRESS "192.168.1.2"
+#define DEFAULT_NFC_INTERFACE "USB0"
+#define DEFAULT_WIRED_INTERFACE "eth0"
+#define DEFAULT_IPADDRESS2 "192.168.0.2"
+#define DEFAULT_NETMASK "255.255.255.0"
+#endif // CONFIG_NATIVE_WINDOWS
+	QFile *conf = new QFile(CONFIG_FILE);
+	bool read_file = false;
+	int index;
+
+	setupUi(this);
+
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+
+	QRegExp rx("[0-9]\\d{0,2}\\.[0-9]\\d{0,2}\\.[0-9]\\d{0,2}\\.[0-9]\\d{0,2}");
+	validator = new QRegExpValidator(rx, this);
+	leIPAddress->setValidator(validator);
+	validator2 = new QRegExpValidator(rx, this);
+	leIPAddress2->setValidator(validator2);
+	validator3 = new QRegExpValidator(rx, this);
+	leNetMask->setValidator(validator3);
+	validator4 = new QRegExpValidator(rx, this);
+	leNetMask2->setValidator(validator4);
+
+	if (conf && conf->exists() && conf->open(QIODevice::ReadOnly)) {
+		char line[BUFSIZ], *tmp, *tmp2;
+
+		index = 0;
+		while((5 >= index) && !conf->atEnd()) {
+			if (0 > conf->readLine(line, sizeof(line) - 1))
+				break;
+
+			if (0 != (tmp = strchr(line, '\n')))
+				*tmp = 0;
+
+			switch (index++) {
+			case 0: leWInterface->setText(line); break;
+			case 1: leWDriver->setText(line); break;
+			case 2:
+			{
+				if (0 != (tmp = strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					if (0 != (tmp2 = strchr(tmp, ','))) {
+						*tmp2 = 0;
+						*tmp2++;
+					}
+					cbIPAddress->setChecked(atoi(line));
+					leIPAddress->setText(tmp);
+					if (tmp2)
+						leNetMask->setText(tmp2);
+					else
+						leNetMask->setText(DEFAULT_NETMASK);
+					leIPAddress->setEnabled(cbIPAddress->isChecked());
+					leNetMask->setEnabled(cbIPAddress->isChecked());
+				}
+				break;
+			}
+			case 3:
+			{
+				if (0 != (tmp = strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					cbNFCInterface->setChecked(atoi(line));
+					leNFCInterface->setText(tmp);
+				}
+				break;
+			}
+			case 4: leInterface2->setText(line); break;
+			case 5:
+			{
+				if (0 != (tmp = strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					if (0 != (tmp2 = strchr(tmp, ','))) {
+						*tmp2 = 0;
+						*tmp2++;
+					}
+					cbIPAddress2->setChecked(atoi(line));
+					leIPAddress2->setText(tmp);
+					if (tmp2)
+						leNetMask2->setText(tmp2);
+					else
+						leNetMask2->setText(DEFAULT_NETMASK);
+					leIPAddress2->setEnabled(cbIPAddress2->isChecked());
+					leNetMask2->setEnabled(cbIPAddress2->isChecked());
+				}
+				break;
+			}
+			}
+		}
+		conf->close();
+
+		if (5 < index)
+			read_file = true;
+	}
+
+	if (conf)
+		delete conf;
+
+	if (!read_file) {
+		leWInterface->setText(DEFAULT_WIRELESS_INTERFACE);
+		leWDriver->setText(DEFAULT_WIRELESS_DRIVER);
+		cbIPAddress->setChecked(true);
+		leIPAddress->setText(DEFAULT_IPADDRESS);
+		leNetMask->setText(DEFAULT_NETMASK);
+		cbNFCInterface->setChecked(true);
+		leNFCInterface->setText(DEFAULT_NFC_INTERFACE);
+		leInterface2->setText(DEFAULT_WIRED_INTERFACE);
+		cbIPAddress2->setChecked(true);
+		leIPAddress2->setText(DEFAULT_IPADDRESS2);
+		leNetMask2->setText(DEFAULT_NETMASK);
+	}
+
+#ifndef CONFIG_NATIVE_WINDOWS
+	connect(cbIPAddress, SIGNAL(clicked()), SLOT(enabledDhcp()));
+	connect(cbIPAddress2, SIGNAL(clicked()), SLOT(enabledDhcp2()));
+#else // CONFIG_NATIVE_WINDOWS
+	leWDriver->setText(DEFAULT_WIRELESS_DRIVER);
+
+	leWInterface->setVisible(false);
+	cbIPAddress->setVisible(false);
+	leIPAddress->setVisible(false);
+	label_4->setVisible(false);
+	leNetMask->setVisible(false);
+	label_5->setVisible(false);
+	leInterface2->setVisible(false);
+	cbIPAddress2->setVisible(false);
+	leIPAddress2->setVisible(false);
+	label_6->setVisible(false);
+	leNetMask2->setVisible(false);
+
+	MainProcess::setWirelessInterface(leWInterface->text().toAscii());
+
+	if_list = 0;
+	cmbWInterface = new QComboBox(gridLayout);
+	cmbWInterface->setObjectName(QString::fromUtf8("cmbWInterface"));
+	gridLayout1->addWidget(cmbWInterface, 0, 1, 1, 1);
+
+	connect(cmbWInterface, SIGNAL(currentIndexChanged(int)), SLOT(selectWInterface(int)));
+#endif // CONFIG_NATIVE_WINDOWS
+
+#undef CONFIG_FILE
+#undef DEFAULT_WIRELESS_INTERFACE
+#undef DEFAULT_WIRELESS_DRIVER
+#undef DEFAULT_IPADDRESS
+#undef DEFAULT_NFC_INTERFACE
+#undef DEFAULT_WIRED_INTERFACE
+#undef DEFAULT_IPADDRESS2
+#undef DEFAULT_NETMASK
+}
+
+SetupInterface::~SetupInterface()
+{
+	(void)end();
+
+	disconnect(cbIPAddress);
+
+	if (validator)
+		delete validator;
+	if (validator2)
+		delete validator2;
+	if (validator3)
+		delete validator3;
+	if (validator4)
+		delete validator4;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	disconnect(cmbWInterface);
+	delete cmbWInterface;
+
+	win_if_list_free(&if_list);
+#endif // CONFIG_NATIVE_WINDOWS
+}
+
+bool SetupInterface::pre_back()
+{
+	MainProcess::terminate();
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	displayWInterfaceList();
+#endif // CONFIG_NATIVE_WINDOWS
+	return true;
+}
+
+bool SetupInterface::pre_next()
+{
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	displayWInterfaceList();
+#endif // CONFIG_NATIVE_WINDOWS
+	return true;
+}
+
+bool SetupInterface::post_next()
+{
+#ifndef CONFIG_NATIVE_WINDOWS
+#define STA_START	"./sta_start"
+#define CONFIG_FILE "./testbed_sta.conf"
+#else // CONFIG_NATIVE_WINDOWS
+#define CONFIG_FILE ".\\testbed_sta.conf"
+#endif // CONFIG_NATIVE_WINDOWS
+
+	bool ret = false;
+	QProcess *prc = new QProcess(this);
+#ifndef CONFIG_NATIVE_WINDOWS
+	char cmd[BUFSIZ];
+#endif // CONFIG_NATIVE_WINDOWS
+	QFile *conf = new QFile(CONFIG_FILE);
+	char line[BUFSIZ];
+
+	do {
+		if (!checkInputs()) {
+			QMessageBox::critical(this, label->text(), "Input error");
+			break;
+		}
+
+#ifndef CONFIG_NATIVE_WINDOWS
+		snprintf(cmd, sizeof(cmd), "%s %s %s %s %s %s %s",
+			STA_START,
+			(const char *)leWInterface->text().toAscii(),
+			cbIPAddress->isChecked()?
+				(const char *)leIPAddress->text().toAscii():"dynamic",
+			cbIPAddress->isChecked()?
+				(const char *)leNetMask->text().toAscii():"255.255.255.0",
+			(const char *)leInterface2->text().toAscii(),
+			cbIPAddress2->isChecked()?
+				(const char *)leIPAddress2->text().toAscii():"dynamic",
+			cbIPAddress2->isChecked()?
+				(const char *)leNetMask2->text().toAscii():"255.255.255.0");
+		prc->start(cmd);
+		prc->waitForFinished(-1);
+		if(prc->exitCode()) {
+			QMessageBox::critical(this, label->text(), "Set interface error");
+			break;
+		}
+#endif // CONFIG_NATIVE_WINDOWS
+
+		if (!MainProcess::start(leWInterface->text().toAscii(),
+								leWDriver->text().toAscii(),
+								cbNFCInterface->isChecked()?
+									(const char *)leNFCInterface->text().toAscii():0)) {
+			QMessageBox::critical(this, label->text(), "Cannot start main process");
+			break;
+		}
+
+		if (conf && conf->open(QIODevice::WriteOnly)) {
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leWInterface->text().toAscii());
+			conf->write(line, strlen(line));
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leWDriver->text().toAscii());
+			conf->write(line, strlen(line));
+			os_snprintf(line, sizeof(line), "%d,%s,%s\n",
+						cbIPAddress->isChecked()?1:0,
+						(const char *)leIPAddress->text().toAscii(),
+						(const char *)leNetMask->text().toAscii());
+			conf->write(line, strlen(line));
+			os_snprintf(line, sizeof(line), "%d,%s\n",
+						cbNFCInterface->isChecked()?1:0,
+						(const char *)leNFCInterface->text().toAscii());
+			conf->write(line, strlen(line));
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leInterface2->text().toAscii());
+			conf->write(line, strlen(line));
+			os_snprintf(line, sizeof(line), "%d,%s,%s\n",
+						cbIPAddress2->isChecked()?1:0,
+						(const char *)leIPAddress2->text().toAscii(),
+						(const char *)leNetMask2->text().toAscii());
+			conf->write(line, strlen(line));
+
+			conf->close();
+		}
+		if (conf)
+			delete conf;
+
+		MainProcess::setWirelessInterface(leWInterface->text().toAscii());
+		MainProcess::setWiredInterface(leInterface2->text().toAscii());
+
+		ret = true;
+	} while (0);
+
+	if (prc) {
+		delete prc;
+		prc = 0;
+	}
+
+	return ret;
+#ifndef CONFIG_NATIVE_WINDOWS
+#undef STA_START
+#endif // CONFIG_NATIVE_WINDOWS
+#undef CONFIG_FILE
+}
+
+bool SetupInterface::checkInputs()
+{
+	bool ret = false;
+	QString check = leIPAddress->text();
+	QString check2 = leIPAddress2->text();
+	QString check3 = leNetMask->text();
+	QString check4 = leNetMask2->text();
+	int pos = 0;
+
+	do {
+		if (!leWInterface->text().length()) {
+			leWInterface->setFocus();
+			break;
+		}
+
+		if (cbIPAddress->isChecked() && 
+			(QValidator::Acceptable != validator->validate(check, pos))) {
+			leIPAddress->setFocus();
+			break;
+		}
+
+		if (cbIPAddress->isChecked() && 
+			(QValidator::Acceptable != validator3->validate(check3, pos))) {
+			leNetMask->setFocus();
+			break;
+		}
+
+		if (cbNFCInterface->isChecked() &&
+			!leNFCInterface->text().length()) {
+			leNFCInterface->setFocus();
+			break;
+		}
+
+		if (!leInterface2->text().length()) {
+			leInterface2->setFocus();
+			break;
+		}
+
+		if (cbIPAddress2->isChecked() && 
+			(QValidator::Acceptable != validator2->validate(check2, pos))) {
+			leIPAddress2->setFocus();
+			break;
+		}
+
+		if (cbIPAddress2->isChecked() && 
+			(QValidator::Acceptable != validator4->validate(check4, pos))) {
+			leNetMask2->setFocus();
+			break;
+		}
+
+		ret = true;
+	} while(0);
+	return ret;
+}
+
+void SetupInterface::cancel()
+{
+	wiz->close();
+}
+
+void SetupInterface::enabledDhcp()
+{
+	leIPAddress->setEnabled(cbIPAddress->isChecked());
+	leNetMask->setEnabled(cbIPAddress->isChecked());
+}
+
+void SetupInterface::enabledDhcp2()
+{
+	leIPAddress2->setEnabled(cbIPAddress2->isChecked());
+	leNetMask2->setEnabled(cbIPAddress2->isChecked());
+}
+
+const char *SetupInterface::getWirelessInterface()
+{
+	return (const char *)leWInterface->text().toAscii();
+}
+
+const char *SetupInterface::getWiredInterface()
+{
+	return (const char *)leInterface2->text().toAscii();
+}
+
+bool SetupInterface::end()
+{
+#ifndef CONFIG_NATIVE_WINDOWS
+#define STA_END	"./sta_end"
+	bool ret = false;
+	QProcess *prc = new QProcess(this);
+	char cmd[BUFSIZ];
+
+	do {
+		if (!checkInputs()) {
+			break;
+		}
+
+		snprintf(cmd, sizeof(cmd), "%s %s %s",
+			STA_END,
+			(const char *)leWInterface->text().toAscii(),
+			(const char *)leInterface2->text().toAscii());
+		prc->start(cmd);
+		prc->waitForFinished(-1);
+
+		ret = true;
+	} while (0);
+
+	if (prc) {
+		delete prc;
+		prc = 0;
+	}
+
+	return ret;
+#undef STA_END
+#else // CONFIG_NATIVE_WINDOWS
+	return true;
+#endif // CONFIG_NATIVE_WINDOWS
+}
+
+#ifdef CONFIG_NATIVE_WINDOWS
+void SetupInterface::displayWInterfaceList()
+{
+	int selected = 0, index;
+	win_if_t *next;
+
+	win_if_list_free(&if_list);
+	cmbWInterface->clear();
+
+	do {
+		if (win_if_enum_devs(&if_list))
+			break;
+
+		for (index = 0, next = if_list; next; next = next->next, index++) {
+			cmbWInterface->addItem(next->description);
+			if (!os_strcmp(MainProcess::getWirelessInterface(), next->name))
+				selected = index;
+		}
+
+		if (selected != 0)
+			cmbWInterface->setCurrentIndex(selected);
+	} while (0);
+}
+
+void SetupInterface::selectWInterface(int index)
+{
+	win_if_t *item, *next;
+
+	next = if_list;
+	for (int i = 0; i < index && next; i++, next = next->next);
+
+	item = next;
+	if (item)
+		leWInterface->setText(item->name);
+}
+#endif // CONFIG_NATIVE_WINDOWS
Index: testbed_sta/displaypin.h
===================================================================
--- testbed_sta/displaypin.h	(revision 0)
+++ testbed_sta/displaypin.h	(revision 2)
@@ -0,0 +1,73 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: displaypin.h
+//  Description: Diplay PIN header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef DISPLAYPIN_H
+#define DISPLAYPIN_H
+
+#include "ui_displaypin.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class DisplayPin:
+public PageTemplate, public Ui::DisplayPin
+{
+Q_OBJECT
+public:
+	DisplayPin(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~DisplayPin();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+};
+
+#endif // DISPLAYPIN_H
Index: testbed_sta/netconfig.h
===================================================================
--- testbed_sta/netconfig.h	(revision 0)
+++ testbed_sta/netconfig.h	(revision 2)
@@ -0,0 +1,74 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: netconfig.h
+//  Description: Network configuration header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef NETCONFIG_H
+#define NETCONFIG_H
+
+#include "ui_netconfig.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+
+
+class NetConfig:
+public PageTemplate, public Ui::NetConfig
+{
+Q_OBJECT
+public:
+	NetConfig(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~NetConfig();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+private slots:
+	void selectAuth(int selected);
+	void selectEncr(int selected);
+	void generateSsid();
+	void generateNetKey();
+
+private:
+	char btoa(int b, bool capital = true);
+	bool checkInputs();
+
+private:
+	TestbedSta *wiz;
+};
+
+#endif // NETCONFIG_H
+
Index: testbed_sta/readnfcconfig.ui
===================================================================
--- testbed_sta/readnfcconfig.ui	(revision 0)
+++ testbed_sta/readnfcconfig.ui	(revision 2)
@@ -0,0 +1,86 @@
+<ui version="4.0" >
+ <class>ReadNfcConfig</class>
+ <widget class="QWidget" name="ReadNfcConfig" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>547</width>
+    <height>320</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>NFC Config method</string>
+   </property>
+  </widget>
+  <widget class="QProgressBar" name="progressBar" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>230</y>
+     <width>531</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="maximum" >
+    <number>300</number>
+   </property>
+   <property name="value" >
+    <number>0</number>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="format" >
+    <string>Touch NFC Token in 30 sec</string>
+   </property>
+  </widget>
+  <widget class="QLabel" name="lblComment" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>521</width>
+     <height>121</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>12</pointsize>
+    </font>
+   </property>
+   <property name="text" >
+    <string>TextLabel</string>
+   </property>
+   <property name="alignment" >
+    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/debugwindow.h
===================================================================
--- testbed_sta/debugwindow.h	(revision 0)
+++ testbed_sta/debugwindow.h	(revision 2)
@@ -0,0 +1,53 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: debugwindow.h
+//  Description: Debug window header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef DEBUGWINDOW_H
+#define DEBUGWINDOW_H
+
+#include "ui_debugwindow.h"
+
+#include <QTextEdit>
+
+class DebugWindow:
+public QWidget, public Ui::DebugWindow
+{
+Q_OBJECT
+public:
+	DebugWindow(QWidget *parent = 0, Qt::WindowFlags f = 0)
+		: QWidget(parent, f) {setupUi(this);};
+	~DebugWindow() {};
+	QTextEdit *textEdit;
+};
+
+#endif // DEBUGWINDOW_H
Index: testbed_sta/mainprocess.cpp
===================================================================
--- testbed_sta/mainprocess.cpp	(revision 0)
+++ testbed_sta/mainprocess.cpp	(revision 2)
@@ -0,0 +1,1155 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: mainprocess.cpp
+//  Description: main process control source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "mainprocess.h"
+#include "wpa_ctrl.h"
+
+#include <time.h>
+
+#define WAIT_FOR_PROCESS		3000 // [msec]
+
+#ifndef CONFIG_NATIVE_WINDOWS
+#define WPA_SUPPLICANT			"./wpa_supplicant"
+
+#define WPA_SUPPLICANT_CTRL_DIR	"/var/run/wpa_supplicant"
+#define WPA_SUPPLICANT_CONF		"./wpa_supplicant.conf"
+#else // CONFIG_NATIVE_WINDOWS
+#define WPA_SUPPLICANT			".\\wpa_supplicant"
+
+#define WPA_SUPPLICANT_CTRL_DIR	"\\var\\run\\wpa_supplicant"
+#define WPA_SUPPLICANT_CONF		".\\wpa_supplicant.conf"
+#endif // CONFIG_NATIVE_WINDOWS
+
+
+MainProcess::MainProcess()
+{
+}
+
+MainProcess::~MainProcess()
+{
+	terminate();
+
+	if (mtx) {
+		mtx->unlock();
+		delete mtx;
+		mtx = 0;
+	}
+
+	if (mainProcess) {
+		delete mainProcess;
+		mainProcess = 0;
+	}
+
+	if (iface) {
+		free(iface);
+	}
+
+	if (wirelessInterface) {
+		free(wirelessInterface);
+		wirelessInterface = 0;
+	}
+
+	if (wiredInterface) {
+		free(wiredInterface);
+		wiredInterface = 0;
+	}
+}
+
+bool MainProcess::setDebugOut(QObject *receiver, const char *method)
+{
+	bool ret = false;
+
+	do {
+		if (!mainProcess)
+			break;
+
+		mainProcess->setReadChannel(QProcess::StandardOutput);
+		mainProcess->setProcessChannelMode(QProcess::MergedChannels);
+		QObject::connect(mainProcess, SIGNAL(readyReadStandardOutput()),
+						 receiver, method);
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+QString MainProcess::readDebugMsg()
+{
+	QString out = "";
+	do {
+		if (!mainProcess)
+			break;
+		out = mainProcess->readLine();
+	} while (0);
+
+	return out;
+}
+
+bool MainProcess::start(const char *wi, const char *driver, const char *nfc)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+
+	do {
+		terminate();
+		if (!mainProcess)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "%s -C%s -c%s -i%s -D%s %s%s -ddd",
+					WPA_SUPPLICANT, WPA_SUPPLICANT_CTRL_DIR, WPA_SUPPLICANT_CONF,
+					wi, driver, nfc?"-n":"", nfc?nfc:"");
+		mainProcess->start(cmd);
+		if (!mainProcess->waitForStarted(WAIT_FOR_PROCESS))
+			break;
+
+		if (iface)
+			free(iface);
+		iface = strdup(wi);
+
+		srand(time(0));
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void MainProcess::terminate(bool enforced /* = false */)
+{
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+#ifndef CONFIG_NATIVE_WINDOWS
+	QProcess *rem = new QProcess();
+	char remCmd[BUFSIZ];
+#endif // CONFIG_NATIVE_WINDOWS
+
+	if (mainProcess &&
+		(QProcess::NotRunning != mainProcess->state())) {
+
+		(void)ctrlRequest("TERMINATE", res, &len);
+		if (!mainProcess->waitForFinished(WAIT_FOR_PROCESS)) {
+			mainProcess->kill();
+		}
+
+		disconnectMonitor(0, 0);
+
+		if (monitor) {
+			wpa_ctrl_detach(monitor);
+			wpa_ctrl_close(monitor);
+			monitor = 0;
+		}
+
+		if (ctrl) {
+			wpa_ctrl_close(ctrl);
+			ctrl = 0;
+		}
+
+#ifndef CONFIG_NATIVE_WINDOWS
+		os_snprintf(remCmd, sizeof(remCmd), "rem -rf %s",
+					WPA_SUPPLICANT_CTRL_DIR);
+		rem->start(remCmd);
+		rem->waitForFinished(-1);
+		delete rem;
+		rem = 0;
+#endif // CONFIG_NATIVE_WINDOWS
+	} else if (enforced) {
+		(void)ctrlRequest("TERMINATE", res, &len);
+
+		disconnectMonitor(0, 0);
+
+		if (monitor) {
+			wpa_ctrl_detach(monitor);
+			wpa_ctrl_close(monitor);
+			monitor = 0;
+		}
+
+		if (ctrl) {
+			wpa_ctrl_close(ctrl);
+			ctrl = 0;
+		}
+	}
+
+	if (iface) {
+		free(iface);
+		iface = 0;
+	}
+}
+
+bool MainProcess::connectMonitor(QObject *receiver, const char *method)
+{ bool ret = false;
+	char monitor_iface[BUFSIZ];
+
+	do {
+		if (!receiver || !method)
+			break;
+
+		if (msgNotifier) {
+			delete msgNotifier;
+			msgNotifier = 0;
+		}
+
+		if (!monitor) {
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+			snprintf(monitor_iface, sizeof(monitor_iface), "%s/%s",
+					 WPA_SUPPLICANT_CTRL_DIR, iface);
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+			int res;
+			size_t monitor_iface_len = sizeof(monitor_iface);
+			char *pos;
+
+			monitor = wpa_ctrl_open(0);
+			if (!monitor)
+				break;
+
+			res = wpa_ctrl_request(monitor, "INTERFACES", 10, monitor_iface, &monitor_iface_len, 0);
+			wpa_ctrl_close(monitor);
+			if (0 > res) {
+				monitor = 0;
+				break;
+			}
+
+			monitor_iface[monitor_iface_len] = 0;
+			if (0 != (pos = strchr(monitor_iface, '\n')))
+				*pos = 0;
+			if (0 != (pos = strchr(monitor_iface, '\r')))
+				*pos = 0;
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+
+			monitor = wpa_ctrl_open(monitor_iface);
+			if (!monitor)
+				break;
+			if (wpa_ctrl_attach(monitor))
+				break;
+		}
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+		msgNotifier = new QSocketNotifier(wpa_ctrl_get_fd(monitor),
+										  QSocketNotifier::Read, 0);
+		if (!msgNotifier)
+			break;
+
+		ret = QObject::connect(msgNotifier, SIGNAL(activated(int)), receiver, method);
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+		msgNotifier = new QTimer();
+		if (!msgNotifier)
+			break;
+
+		ret = QObject::connect(msgNotifier, SIGNAL(timeout()), receiver, method);		
+		if (ret) {
+			msgNotifier->setSingleShot(true);
+			msgNotifier->start(500);
+		}
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	} while (0);
+
+	if (!ret) {
+		printf("Could not connect with monitor.\n");
+		disconnectMonitor(receiver, method);
+	}
+
+	return ret;
+}
+
+bool MainProcess::reconnectMonitor()
+{
+#ifdef CONFIG_NATIVE_WINDOWS
+	bool ret = false;
+
+	do {
+		if (!msgNotifier)
+			break;
+
+		msgNotifier->start(100);
+		ret = true;
+	} while (0);
+
+	return ret;
+#else
+	return true;
+#endif // CONFIG_NATIVE_WINDOWS
+}
+
+bool MainProcess::disconnectMonitor(QObject *receiver, const char *method)
+{
+	if (msgNotifier && receiver && method) {
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+		QObject::disconnect(msgNotifier, SIGNAL(activated(int)), receiver, method);
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+		msgNotifier->stop();
+		QObject::disconnect(msgNotifier, SIGNAL(timeout()), receiver, method);
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	}
+
+	if (msgNotifier) {
+		delete msgNotifier;
+		msgNotifier = 0;
+	}
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	if (monitor) {
+		wpa_ctrl_detach(monitor);
+		wpa_ctrl_close(monitor);
+		monitor = 0;
+	}
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+
+	return true;
+}
+
+bool MainProcess::ctrlPending()
+{
+	return (monitor && (0 < wpa_ctrl_pending(monitor)));
+}
+
+bool MainProcess::receive(char *msg, size_t *len)
+{
+	int ret = false;
+	do {
+		if (!monitor || !msg || !len)
+			break;
+
+		ret = (0 == wpa_ctrl_recv(monitor, msg, len));
+		if (ret)
+			msg[*len] = 0;
+	} while (0);
+
+	return ret;
+}
+
+bool MainProcess::getCtrlRequelst(char *buf, size_t len, int *priority, char *req, char *msg)
+{
+	bool ret = false;
+	char *pos = buf, *pos2;
+	size_t req_len;
+
+	do {
+		if (!buf || !len)
+			break;
+
+		if (req) *req = 0;
+		if (msg) *msg = 0;
+
+		if (*pos == '<') {
+			pos++;
+			if (priority)
+				*priority = atoi(pos);
+			pos = strchr(pos, '>');
+			if (pos)
+				pos++;
+			else
+				pos = buf;
+		}
+
+		if (strncmp(pos, "CTRL-", 5) == 0) {
+			pos2 = strchr(pos, !strncmp(pos, WPA_CTRL_REQ, strlen(WPA_CTRL_REQ))?':':' ');
+			if (pos2) {
+				pos2++;
+				if (req) {
+					req_len = pos2 - (pos + strlen(WPA_CTRL_REQ) + 1);
+					strncpy(req, pos + strlen(WPA_CTRL_REQ), req_len);
+					req[req_len] = 0;
+				}
+				if (msg)
+					strcpy(msg, pos2);
+			} else {
+				pos2 = pos;
+				if (req)
+					*req = 0;
+				if (msg)
+					strcpy(msg, pos2);
+			}
+		} else
+			strcpy(msg, pos);
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+int MainProcess::ctrlRequest(char *cmd, char *res, size_t *len)
+{
+	int ret = 0;
+	char ctrl_iface[BUFSIZ];
+
+	do {
+		if (!ctrl) {
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+			os_snprintf(ctrl_iface, sizeof(ctrl_iface), "%s/%s",
+						WPA_SUPPLICANT_CTRL_DIR, iface);
+
+#elif defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
+			size_t ctrl_iface_len = sizeof(ctrl_iface);
+			char *pos;
+
+			ctrl = wpa_ctrl_open(0);
+			if (!ctrl) {
+				ret = -3;
+				break;
+			}
+
+			ret = wpa_ctrl_request(ctrl, "INTERFACES", 10, ctrl_iface, &ctrl_iface_len, 0);
+			wpa_ctrl_close(ctrl);
+			if (0 > ret) {
+				ctrl = 0;
+				break;
+			}
+
+			ctrl_iface[ctrl_iface_len] = 0;
+			if (0 != (pos = strchr(ctrl_iface, '\n')))
+				*pos = 0;
+			if (0 != (pos = strchr(ctrl_iface, '\r')))
+				*pos = 0;
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+			ctrl = wpa_ctrl_open(ctrl_iface);
+			if (!ctrl) {
+				ret = -3;
+				break;
+			}
+		}
+
+		if (mtx)
+			mtx->lock();
+
+		ret = wpa_ctrl_request(ctrl, cmd, strlen(cmd), res, len, 0);
+		if (0 > ret) {
+			wpa_ctrl_close(ctrl);
+			ctrl = 0;
+		}
+
+		if (mtx)
+			mtx->unlock();
+	} while (0);
+
+	if (0 > ret)
+		printf("Fail control-request : %d.\n", ret);
+
+	return ret;
+}
+
+bool MainProcess::scanRequest()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("SCAN", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail scan-request.\n");
+
+	return ret;
+}
+
+bool MainProcess::getScanResults(char *result, size_t *len)
+{
+	bool ret = false;
+
+	do {
+		if (!result && !len)
+			break;
+
+		if (0 > ctrlRequest("SCAN_RESULTS", result, len))
+			break;
+		result[*len] = 0;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to get scan-results.\n");
+
+	return ret;
+}
+
+int MainProcess::addNetwork()
+{
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+	int index = -1;
+
+	do {
+		if (0 > ctrlRequest("ADD_NETWORK", res, &len))
+			break;
+
+		if (!strncmp(res, "FAIL", 4))
+			break;
+
+		index = atoi(res);
+	} while (0);
+
+	if (0 > index)
+		printf("Fail to add network.\n");
+
+	return index;
+}
+
+bool MainProcess::removeNetwork(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > index)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "REMOVE_NETWORK %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		if (index == networkIndex)
+			networkIndex = -1;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to remove network.\n");
+
+	return ret;
+}
+
+bool MainProcess::setNetworkParam(int index, char *field, char *value, bool quote)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if ((0 > index) || !field || !value)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "SET_NETWORK %d %s %s%s%s",
+					index, field, quote ? "\"" : "", value, quote ? "\"" : "");
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while(0);
+
+	if (!ret)
+		printf("Fail to set network parameter : %s.\n", field);
+
+	return ret;
+}
+
+bool MainProcess::getNetworkParam(int index, char *field, char *value, bool quote)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if ((0 > index) || !field || !value)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "GET_NETWORK %d %s", index, field);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+		res[len] = 0;
+
+		if (!strncmp(res, "FAIL", 4))
+			break;
+
+		if (quote) {
+			if (('"' != res[0]) || !strchr(&res[1], '"'))
+				break;
+		}
+
+		len = strchr(&res[1], '"') - &res[1];
+		strncpy(value, &res[1], len);
+		value[len] = 0;
+
+		ret = true;
+	} while(0);
+
+	if (!ret)
+		printf("Fail to get network parameter : %s.\n", field);
+
+	return ret;
+}
+
+bool MainProcess::connectNetwork(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "SELECT_NETWORK %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		len = sizeof(res) - 1;
+		os_snprintf(cmd, sizeof(cmd), "ENABLE_NETWORK %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		len = sizeof(res) - 1;
+		if (0 > ctrlRequest("REASSOCIATE", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to connect network.\n");
+
+	return ret;
+}
+
+bool MainProcess::disableNetwork(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "DISABLE_NETWORK %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to disable network.\n");
+
+	return ret;
+}
+
+bool MainProcess::setRegMode(int regmode)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "WPS_SET_REGMODE %d", regmode);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::setWpsPassword(const char *pwd)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (!pwd)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "WPS_SET_PASSWORD %s", pwd);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to set WPS password.\n");
+
+	return ret;
+}
+
+bool MainProcess::setWpsConfiguration(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > index)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "WPS_SET_CONFIGURATION %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::clearWpsPassword()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WPS_CLEAR_PASSWORD", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to clear WPS password.\n");
+
+	return ret;
+}
+
+bool MainProcess::setUpnpInterface(const char *ifname)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (!ifname)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "UPNP_SET_IF %s", ifname);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to set UPnP interface.\n");
+
+	return ret;
+}
+
+bool MainProcess::isEnabledUpnp()
+{
+	return enabledUpnp;
+}
+
+bool MainProcess::setEnabledUpnp(bool enabled)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "UPNP_ENABLED %d", enabled?1:0);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		enabledUpnp = enabled;
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to be %s UPnP interface.\n", enabled?"enabled":"disabled");
+
+	return ret;
+}
+
+bool MainProcess::upnpScanRequest()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("UPNP_REFRESH 10", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail UPnP scan-request.\n");
+
+	return ret;
+}
+
+bool MainProcess::getUpnpScanResults(char *result, size_t *len)
+{
+	bool ret = false;
+
+	do {
+		if (!result && !len)
+			break;
+
+		if (0 > ctrlRequest("GET_UPNP_SCAN_RESULTS", result, len))
+			break;
+		result[*len] = 0;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to get UPnP scan-results.\n");
+
+	return ret;
+}
+
+bool MainProcess::sendUpnpGetDevInfo(const char *control_url)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (!control_url)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "SEND_UPNP_GETDEVINFO %s", control_url);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to send GetDeviceInfo thru UPnP.\n");
+
+	return ret;
+}
+
+bool MainProcess::sendSelectedRegistrar(const char *control_url, bool enabled)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (!control_url)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "SET_UPNP_SEL_REG %s %d", control_url, enabled?1:0);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to send Selected-Registrar thru UPnP.\n");
+
+	return ret;
+}
+
+bool MainProcess::writeNfcConfig(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "WRITE_CONFIG_TOKEN %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::readNfcConfig()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("READ_CONFIG_TOKEN", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::writeNfcPassword(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "WRITE_PASSWORD_TOKEN %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::readNfcPassword(int index)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "READ_PASSWORD_TOKEN %d", index);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::cancelScanNfcToken()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("CANCEL_NFC_COMMAND", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to cancel NFC command.\n");
+
+	return ret;
+}
+
+bool MainProcess::startPbc()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		len = sizeof(res) - 1;
+		if (0 > ctrlRequest("WPS_PBC_ENABLED 1", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to start PBC method.\n");
+
+	return ret;
+}
+
+bool MainProcess::stopPbc()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WPS_PBC_ENABLED 0", res, &len))
+			break;
+
+		if (strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to stop PBC method.\n");
+
+	return ret;
+}
+
+void MainProcess::generatePIN(char pwd[9])
+{
+	unsigned long pin;
+	unsigned char checksum;
+	unsigned long acc = 0;
+	unsigned long tmp;
+
+	if (!pwd) {
+		printf("Could not generate PIN with NULL-pointer.\n");
+		return;
+	}
+
+	pin = rand() % 10000000;
+	tmp = pin * 10;
+
+	acc += 3 * ((tmp / 10000000) % 10);
+	acc += 1 * ((tmp / 1000000) % 10);
+	acc += 3 * ((tmp / 100000) % 10);
+	acc += 1 * ((tmp / 10000) % 10);
+	acc += 3 * ((tmp / 1000) % 10);
+	acc += 1 * ((tmp / 100) % 10);
+	acc += 3 * ((tmp / 10) % 10);
+
+	checksum = (unsigned char)(10 - (acc % 10)) % 10;
+	os_snprintf(pwd, 9, "%08lu", pin * 10 + checksum);
+}
+
+bool MainProcess::validatePIN(const char pwd[9])
+{
+	bool ret = true;
+	unsigned long pin, check;
+	unsigned char checksum;
+	unsigned long acc = 0;
+	char *tmp = 0;
+
+	do {
+		pin = strtol(pwd, &tmp, 10);
+		if (!tmp || *tmp)
+			break;
+		check = (pin / 10) * 10;
+		acc += 3 * ((check / 10000000) % 10);
+		acc += 1 * ((check / 1000000) % 10);
+		acc += 3 * ((check / 100000) % 10);
+		acc += 1 * ((check / 10000) % 10);
+		acc += 3 * ((check / 1000) % 10);
+		acc += 1 * ((check / 100) % 10);
+		acc += 3 * ((check / 10) % 10);
+		checksum = (unsigned char)(10 - (acc % 10)) % 10;
+
+		if (checksum != (unsigned char)atoi(&pwd[7]))
+			ret = false;
+	} while (0);
+
+	return ret;
+}
+
Index: testbed_sta/sta_start
===================================================================
--- testbed_sta/sta_start	(revision 0)
+++ testbed_sta/sta_start	(revision 2)
@@ -0,0 +1,81 @@
+#!/bin/bash
+
+# check parameters
+if [ -z "$1" -o -z "$2" -o -z "$3" ]; then
+	echo "$0 [madwifi-interface] [ipaddress] [netmask] ([wired-interface] [ipaddress2] [netmask2])";
+	exit -1;
+fi
+
+# kill process if it is running
+kill_process()
+{
+	running_process=$(ps -A|grep ${1})
+	if [ -n "$running_process" ]; then
+		killall -s SIGTERM $running_process;
+		sleep 1;
+		return 0;
+	fi
+	return -1;
+}
+
+# set interface
+set_interface()
+{
+	ifconfig ${1} ${2} netmask ${3} up 2>/dev/null
+}
+
+# set local loopback
+lo=$(ifconfig|grep -i loopback|sed 's/[[:blank:]].*$//g')
+if [ -z $lo ]; then
+	ifup lo;
+fi
+
+# kill "wpa_supplicant" deamon if it is running
+main_daemon=wpa_supplicant
+kill_process $main_daemon
+
+# remove interface directory if it exists
+if [ -d /var/run/$main_daemon ]; then
+	rm -rf /var/run/$main_daemon
+fi
+
+# get index & current mode(0:sta, 1:ap, 53:monitor)
+index=$(echo $1|sed -ne "s:.*[^0-9*]::p")
+mode=$(iwpriv $1 get_uapsd 2>/dev/null|sed -ne "s:$1.*get_uapsd\:::p")
+
+# destroy madwifi-interface first
+if [ -z "$mode" ]; then
+	mode=-1
+elif [ $mode -ne 0 ]; then
+	wlanconfig $1 destroy >/dev/null;
+	sleep 1;
+fi
+
+# create madwifi-interface
+if [ $mode -ne 0 ]; then
+	res=$(wlanconfig $1 create wlandev wifi$index wlanmode sta nosbeacon)
+	if [ "$res" != "$1" ]; then
+		exit -1;
+	fi
+	sleep 1;
+fi
+iwpriv $1 wds 0
+
+# set wireless-mode to auto
+iwpriv $1 mode auto
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+sleep 1;
+
+# set IP address
+set_interface $1 $2 $3
+if [ $? -ne 0 ]; then
+	exit $?;
+elif [ -n "$4" -a -n "$5" -a -n "$6" ]; then
+	set_interface $4 $5 $6;
+	exit $?;
+else
+	exit 0;
+fi
+
Index: testbed_sta/selectmode.cpp
===================================================================
--- testbed_sta/selectmode.cpp	(revision 0)
+++ testbed_sta/selectmode.cpp	(revision 2)
@@ -0,0 +1,203 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: selectmode.cpp
+//  Description: Select mode source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "selectmode.h"
+#include "mainprocess.h"
+#include "testbedsta.h"
+
+#include <QMessageBox>
+
+
+SelectMode::SelectMode(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedSta *>(wizard);
+	setupUi(this);
+
+	connect(pbConfigAp, SIGNAL(clicked()), SLOT(selConfigAp())); 
+	connect(pbRegAp, SIGNAL(clicked()), SLOT(selRegAp())); 
+	connect(pbRegSta, SIGNAL(clicked()), SLOT(selRegSta())); 
+	connect(pbGetConfig, SIGNAL(clicked()), SLOT(selGetConfig())); 
+	connect(pbSetConfig, SIGNAL(clicked()), SLOT(selSetConfig())); 
+}
+
+SelectMode::~SelectMode()
+{
+}
+
+bool SelectMode::pre_back()
+{
+	MainProcess::setMode(MainProcess::MODE_ENR);
+
+	if (0 > MainProcess::getNetworkIndex()) {
+		pbConfigAp->setVisible(true);
+		lblConfigAp->setVisible(true);
+		pbRegAp->setVisible(false);
+		lblRegAp->setVisible(false);
+		pbRegSta->setVisible(false);
+		lblRegSta->setVisible(false);
+		pbGetConfig->setVisible(true);
+		lblGetConfig->setVisible(true);
+		pbSetConfig->setVisible(true);
+		lblSetConfig->setVisible(true);
+		pbConfigAp->setFocus();
+		wiz->pbBack->setEnabled(true);
+	} else {
+		pbConfigAp->setVisible(false);
+		lblConfigAp->setVisible(false);
+		pbRegAp->setVisible(false);
+		lblRegAp->setVisible(false);
+		pbRegSta->setVisible(true);
+		lblRegSta->setVisible(true);
+		pbGetConfig->setVisible(false);
+		lblGetConfig->setVisible(false);
+		pbSetConfig->setVisible(false);
+		lblSetConfig->setVisible(false);
+		pbRegSta->setFocus();
+		wiz->pbBack->setEnabled(false);
+	}
+
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool SelectMode::pre_next()
+{
+	MainProcess::setMode(MainProcess::MODE_ENR);
+
+	if (0 > MainProcess::getNetworkIndex()) {
+		pbConfigAp->setVisible(true);
+		lblConfigAp->setVisible(true);
+		pbRegAp->setVisible(false);
+		lblRegAp->setVisible(false);
+		pbRegSta->setVisible(false);
+		lblRegSta->setVisible(false);
+		pbGetConfig->setVisible(true);
+		lblGetConfig->setVisible(true);
+		pbSetConfig->setVisible(true);
+		lblSetConfig->setVisible(true);
+		pbConfigAp->setFocus();
+		wiz->pbBack->setEnabled(true);
+	} else {
+		pbConfigAp->setVisible(false);
+		lblConfigAp->setVisible(false);
+		pbRegAp->setVisible(false);
+		lblRegAp->setVisible(false);
+		pbRegSta->setVisible(true);
+		lblRegSta->setVisible(true);
+		pbGetConfig->setVisible(false);
+		lblGetConfig->setVisible(false);
+		pbSetConfig->setVisible(false);
+		lblSetConfig->setVisible(false);
+		pbRegSta->setFocus();
+		wiz->pbBack->setEnabled(false);
+	}
+
+	wiz->pbNext->setEnabled(false);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool SelectMode::post_next()
+{
+	int regmode;
+
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_ENR:
+	case MainProcess::MODE_MANUAL:
+		regmode = 0;
+		break;
+	case MainProcess::MODE_REG_CONFAP:
+		regmode = 1;
+		break;
+	case MainProcess::MODE_REG_REGAP:
+		regmode = 2;
+		break;
+	case MainProcess::MODE_REG_REGSTA:
+		regmode = 3;
+		break;
+	default:
+		return false;
+	}
+
+	if (!MainProcess::setRegMode(regmode)) {
+		QMessageBox::warning(this, label->text(),
+							 "Could not set WPS registrar mode\n");
+		return false;
+	}
+
+	return true;
+}
+
+void SelectMode::cancel()
+{
+	wiz->close();
+}
+
+void SelectMode::selConfigAp()
+{
+	MainProcess::setMode(MainProcess::MODE_REG_CONFAP);
+	MainProcess::setArea(MainProcess::AREA_BOTH_INBAND_UPNP);
+	wiz->next();
+}
+
+void SelectMode::selRegAp()
+{
+	MainProcess::setMode(MainProcess::MODE_REG_REGAP);
+	MainProcess::setArea(MainProcess::AREA_INBAND_ONLY);
+	wiz->next();
+}
+
+void SelectMode::selRegSta()
+{
+	MainProcess::setMode(MainProcess::MODE_REG_REGSTA);
+	MainProcess::setArea(MainProcess::AREA_UPNP_ONLY);
+	wiz->next();
+}
+
+void SelectMode::selGetConfig()
+{
+	MainProcess::setMode(MainProcess::MODE_ENR);
+	MainProcess::setArea(MainProcess::AREA_INBAND_ONLY);
+	wiz->next();
+}
+
+void SelectMode::selSetConfig()
+{
+	MainProcess::setMode(MainProcess::MODE_MANUAL);
+	wiz->next();
+}
+
Index: testbed_sta/selectap.ui
===================================================================
--- testbed_sta/selectap.ui	(revision 0)
+++ testbed_sta/selectap.ui	(revision 2)
@@ -0,0 +1,141 @@
+<ui version="4.0" >
+ <class>SelectAp</class>
+ <widget class="QWidget" name="SelectAp" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>547</width>
+    <height>321</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QFrame" name="frame" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>270</y>
+     <width>531</width>
+     <height>41</height>
+    </rect>
+   </property>
+   <property name="frameShape" >
+    <enum>QFrame::NoFrame</enum>
+   </property>
+   <property name="frameShadow" >
+    <enum>QFrame::Plain</enum>
+   </property>
+   <widget class="QPushButton" name="pbUpdate" >
+    <property name="geometry" >
+     <rect>
+      <x>410</x>
+      <y>5</y>
+      <width>120</width>
+      <height>30</height>
+     </rect>
+    </property>
+    <property name="font" >
+     <font>
+      <pointsize>9</pointsize>
+     </font>
+    </property>
+    <property name="text" >
+     <string>Update</string>
+    </property>
+   </widget>
+   <widget class="QProgressBar" name="progressBar" >
+    <property name="geometry" >
+     <rect>
+      <x>0</x>
+      <y>5</y>
+      <width>400</width>
+      <height>31</height>
+     </rect>
+    </property>
+    <property name="font" >
+     <font>
+      <pointsize>9</pointsize>
+     </font>
+    </property>
+    <property name="maximum" >
+     <number>10</number>
+    </property>
+    <property name="value" >
+     <number>0</number>
+    </property>
+    <property name="orientation" >
+     <enum>Qt::Horizontal</enum>
+    </property>
+    <property name="format" >
+     <string>%v sec / %m sec</string>
+    </property>
+   </widget>
+  </widget>
+  <widget class="QTreeWidget" name="apList" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>90</y>
+     <width>531</width>
+     <height>171</height>
+    </rect>
+   </property>
+  </widget>
+  <widget class="QWidget" name="horizontalLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>261</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <layout class="QHBoxLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>6</number>
+    </property>
+    <item>
+     <widget class="QComboBox" name="cmbSelArea" >
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>501</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Select AP</string>
+   </property>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>cmbSelArea</tabstop>
+  <tabstop>pbUpdate</tabstop>
+  <tabstop>apList</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_sta/sta_end
===================================================================
--- testbed_sta/sta_end	(revision 0)
+++ testbed_sta/sta_end	(revision 2)
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+# kill process if it is running
+kill_process()
+{
+	running_process=$(ps -A|grep ${1})
+	if [ -n "$running_process" ]; then
+		killall -s SIGTERM $running_process;
+		sleep 1;
+		return 0;
+	fi
+	return -1;
+}
+
+down_interface()
+{
+	ifconfig ${1} down 2>/dev/null
+}
+
+# kill "wpa_supplicant" deamon if it is running
+main_daemon=wpa_supplicant
+kill_process $main_daemon
+
+# remove interface directory if it exists
+if [ -d /var/run/$main_daemon ]; then
+	rm -rf /var/run/$main_daemon
+fi
+
+if [ -n "$1" ]; then
+	down_interface $1;
+fi
+
+if [ -n "$2" ]; then
+	down_interface $2;
+fi
+
Index: testbed_sta/readnfcconfig.h
===================================================================
--- testbed_sta/readnfcconfig.h	(revision 0)
+++ testbed_sta/readnfcconfig.h	(revision 2)
@@ -0,0 +1,73 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: readnfcconfig.h
+//  Description: Read NFC config token header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef READNFCCONFIG_H
+#define READNFCCONFIG_H
+
+#include "ui_readnfcconfig.h"
+#include "pagetemplate.h"
+
+class TestbedSta;
+class QTimer;
+
+
+class ReadNfcConfig:
+public PageTemplate, public Ui::ReadNfcConfig
+{
+Q_OBJECT
+public:
+	ReadNfcConfig(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~ReadNfcConfig();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+private:
+	void processCtrlRequest(char *msg, size_t len);
+
+private slots:
+	void receiveMsgs();
+	void increment();
+
+private:
+	TestbedSta *wiz;
+	QTimer *timer;
+};
+
+#endif // READNFCCONFIG_H
Index: ctrl_iface.c
===================================================================
--- ctrl_iface.c	(revision 1)
+++ ctrl_iface.c	(revision 2)
@@ -28,7 +28,22 @@
 #include "wpa_ctrl.h"
 #include "eap.h"
 
+#ifdef EAP_WPS
+#include "wps_config.h"
+#include "wps_parser.h"
+#ifndef USE_INTEL_SDK
+#include "eap_wps.h"
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_UPNP
+#include "upnp_wps_ctrlpt.h"
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+#include "wps_opt_nfc.h"
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
 
+
 static int wpa_supplicant_global_iface_interfaces(struct wpa_global *global,
 						  char *buf, int len);
 
@@ -261,6 +276,15 @@
 		pos += ret;
 	}
 
+#ifdef MODIFIED_BY_SONY
+	ret = os_snprintf(pos, end - pos, "mac_address=%02X:%02X:%02X:%02X:%02X:%02X\n",
+				   wpa_s->own_addr[0], wpa_s->own_addr[1], wpa_s->own_addr[2],
+				   wpa_s->own_addr[3], wpa_s->own_addr[4], wpa_s->own_addr[5]);
+	if (ret < 0 || ret >= end - pos)
+		return pos - buf;
+	pos += ret;
+#endif	/* MODIFIED_BY_SONY */
+
 	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X ||
 	    wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
 		res = eapol_sm_get_status(wpa_s->eapol, pos, end - pos,
@@ -423,11 +447,63 @@
 	pos += ret;
 
 	if (wpa_parse_wpa_ie(ie, ie_len, &data) < 0) {
+#ifdef EAP_WPS
+		struct wps_data *wps = 0;
+		if (wps_create_wps_data(&wps) < 0 ||
+		    wps_parse_wps_ie(ie, ie_len, wps) < 0) {
+			if (wps)
+				wps_destroy_wps_data(&wps);
+#endif /* EAP_WPS */
 		ret = os_snprintf(pos, end - pos, "?]");
 		if (ret < 0 || ret >= end - pos)
 			return pos;
 		pos += ret;
 		return pos;
+#ifdef EAP_WPS
+		} else {
+			u8 scState;
+			Boolean selReg;
+			u16 devPwdId;
+			first = 1;
+			do {
+				if (!wps_get_value(wps, WPS_TYPE_WPSSTATE, &scState, NULL)) {
+					ret = os_snprintf(pos, end - pos, "%s%s",
+								   first ? "" : "+",
+								   (WPS_WPSSTATE_UNCONFIGURED == scState) ?
+								   "Unconf" : "Conf");
+					if (ret < 0 || ret >= end - pos)
+						break;
+					pos += ret;
+					first = 0;
+				}
+				if (!wps_get_value(wps, WPS_TYPE_SEL_REGISTRAR, &selReg, NULL)) {
+					if (selReg) {
+						ret = os_snprintf(pos, end - pos, "%sSR",
+									   first ? "" : "+");
+						if (ret < 0 || ret >= end - pos)
+							break;
+						pos += ret;
+						first = 0;
+					}
+					if (selReg &&
+						!wps_get_value(wps, WPS_TYPE_DEVICE_PWD_ID, &devPwdId, NULL)) {
+						if (WPS_DEVICEPWDID_PUSH_BTN == devPwdId) {
+							ret = os_snprintf(pos, end - pos, "%sPBC",
+										   first ? "" : "+");
+							if (ret < 0 || ret >= end - pos)
+								break;
+							pos += ret;
+							first = 0;
+						}
+					}
+				}
+				ret = os_snprintf(pos, end - pos, "]");
+				pos += ret;
+			} while (0);
+			wps_destroy_wps_data(&wps);
+			return pos;
+		}
+#endif /* EAP_WPS */
 	}
 
 	first = 1;
@@ -509,6 +585,13 @@
 						    res->rsn_ie,
 						    res->rsn_ie_len);
 		}
+#ifdef EAP_WPS
+		if (res->wps_ie_len) {
+			pos = wpa_supplicant_ie_txt(pos, end, "WPS",
+						    res->wps_ie,
+						    res->wps_ie_len);
+		}
+#endif /* EAP_WPS */
 		if (!res->wpa_ie_len && !res->rsn_ie_len &&
 		    res->caps & IEEE80211_CAP_PRIVACY) {
 			ret = os_snprintf(pos, end - pos, "[WEP]");
@@ -571,6 +654,19 @@
 	if (ssid != wpa_s->current_ssid && wpa_s->current_ssid)
 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	if (wpa_s->conf->wps->enabled_pbc &&
+		(id != wpa_s->conf->wps->nwid_trying_wps)) {
+		if (eap_wps_enabled_pbc(wpa_s, wpa_s->conf->wps, 0)) {
+			wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not cancel "
+				   "EAP-WPS PBC methods");
+			return -1;
+		}
+	}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	/* Mark all other networks disabled and trigger reassociation */
 	ssid = wpa_s->conf->ssid;
 	while (ssid) {
@@ -1064,6 +1160,433 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static int wpa_supplicant_ctrl_iface_wps_pbc_enabed(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int enabled;
+	enabled = atoi(cmd);
+
+	if (eap_wps_enabled_pbc(wpa_s, wpa_s->conf->wps, enabled))
+		return -1;
+
+	if (enabled) {
+		if (wpa_s->current_ssid)
+			wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+		if (wpa_s->disconnected)
+			wpa_s->disconnected = 0;
+		wpa_s->scan_req = 2;
+		wpa_supplicant_req_scan(wpa_s, 0, 0);
+	} else {
+		wpa_s->current_ssid = NULL;
+		wpa_s->disconnected = 1;
+		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+	}
+
+	return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_wps_set_regmode(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+	int regmode = atoi(cmd);
+	int prev_regmode;
+
+	do {
+		if (!wps)
+			break;
+
+		prev_regmode = wps->reg_mode;
+		if (0 == regmode)
+			wps->reg_mode = WPS_REGMODE_NONE;
+		else if (1 == regmode)
+			wps->reg_mode = WPS_REGMODE_CONFIGURE_AP;
+		else if (2 == regmode)
+			wps->reg_mode = WPS_REGMODE_REGISTER_AP;
+		else if (3 == regmode)
+			wps->reg_mode = WPS_REGMODE_REGISTER_STA;
+		else
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_wps_set_configuration(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+	struct wpa_ssid *ssid;
+	int index = atoi(cmd);
+	u8 *config = 0;
+	size_t config_len = 0;
+
+	do {
+		if (!wps)
+			break;
+
+		if (wps->config) {
+			os_free(wps->config);
+			wps->config = 0;
+			wps->config_len = 0;
+		}
+
+		ssid = wpa_config_get_network(wpa_s->conf, index);
+		if (!ssid)
+			break;
+		if (wps->reg_mode == WPS_REGMODE_CONFIGURE_AP)
+			ssid->disabled = 1;
+
+		if (wps_get_ssid_configuration(wpa_s, index, &config, &config_len))
+			break;
+
+		wps->config = config;
+		wps->config_len = config_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && config)
+		os_free(config);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_wps_clear_password(
+	struct wpa_supplicant *wpa_s)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+
+	do {
+		os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+		wps->dev_pwd_len = 0;
+		wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+		if (wps->set_pub_key) {
+			if (wps->dh_secret)
+				eap_wps_free_dh(&wps->dh_secret);
+			os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+			wps->set_pub_key = 0;
+		}
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+#endif /* USE_INTEL_SDK */
+
+
+#ifdef WPS_OPT_UPNP
+static  int wpa_supplicant_ctrl_iface_upnp_enabled(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	int enabled;
+	struct wps_config *wps = wpa_s->conf->wps;
+
+	do {
+		if (!cmd)
+			break;
+
+		enabled = atoi(cmd);
+		if (enabled) {
+			if (wps_opt_upnp_sm_start(wpa_s->wps_opt_upnp, wps->upnp_iface))
+				break;
+		} else {
+			if (wps_opt_upnp_sm_stop(wpa_s->wps_opt_upnp))
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static  int wpa_supplicant_ctrl_iface_upnp_set_if(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+
+	do {
+		if (!cmd)
+			break;
+
+		if(wps->upnp_iface)
+			os_free(wps->upnp_iface);
+		wps->upnp_iface = os_strdup(cmd);
+		if(!wps->upnp_iface)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_wps_set_current_upnp_device(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+
+	do {
+		if (!cmd)
+			break;
+
+		if (wps->cur_upnp_device)
+			os_free(wps->cur_upnp_device);
+
+		wps->cur_upnp_device = os_strdup(cmd);
+		if(!wps->cur_upnp_device)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_wps_set_password(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = wpa_s->conf->wps;
+	char *password;
+	size_t pwd_len;
+
+	do {
+		if (!wps)
+			break;
+
+		password = strchr(cmd, '\n');
+		if (password)
+			*password = 0;
+		password = cmd;
+		pwd_len = os_strlen(password);
+
+		os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+		wps->dev_pwd_len = pwd_len;
+		os_memcpy(wps->dev_pwd, password, wps->dev_pwd_len);
+
+		if (pwd_len) {
+			if ((8 == pwd_len) &&
+				!eap_wps_device_password_validation((u8 *)password, pwd_len))
+				wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			else
+				wps->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+
+			if (wps->set_pub_key) {
+				if (wps->dh_secret)
+					eap_wps_free_dh(&wps->dh_secret);
+				os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+				wps->set_pub_key = 0;
+			}
+
+			if (wps->reg_mode == WPS_REGMODE_REGISTER_STA) {
+				(void)wps_opt_upnp_set_selected_registrar(wpa_s->wps_opt_upnp,
+														wps->cur_upnp_device, 1);
+			} else if (wps->cur_upnp_device) {
+				os_free(wps->cur_upnp_device);
+				wps->cur_upnp_device = 0;;
+			}
+		} else {
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+			if (wps->set_pub_key) {
+				if (wps->dh_secret)
+					eap_wps_free_dh(&wps->dh_secret);
+				os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+				wps->set_pub_key = 0;
+			}
+		}
+
+		ret = 0;
+	} while(0);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_reflesh_device(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int timeout;
+
+	timeout = atoi(cmd);
+
+	if (wps_opt_upnp_refresh_device(wpa_s->wps_opt_upnp, timeout))
+		return -1;
+	else
+		return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_get_upnp_scan_results(
+	struct wpa_supplicant *wpa_s, char *buf, size_t buflen)
+{
+	int ret = 0;
+	int res;
+	char *pos, *end;
+	struct upnp_wps_ctrlpt_device_list *list = 0, *cur;
+	struct upnp_wps_ctrlpt_device *device;
+
+	do {
+		if (wps_opt_upnp_get_scan_result(wpa_s->wps_opt_upnp,
+										 &list))
+			break;
+
+		pos = buf;
+		end = buf + buflen;
+		res = os_snprintf(pos, end - pos, "control_url / udn / "
+					   "manufacturer / model name / model number / "
+					   "serial_number\n");
+		if (ret < 0 || res >= end - pos)
+			break;
+		pos += res;
+
+		cur = list;
+		while (cur) {
+			device = &cur->device;
+
+			res = os_snprintf(pos, end - pos, "%s\t%s\t%s\t%s\t%s\t%s\n",
+						   device->control_url, device->udn,
+						   device->manufacturer, device->model_name,
+						   device->model_number, device->serial_number);
+			if (res < 0 || res >= end - pos)
+				break;
+			pos += res;
+
+			cur = cur->next;
+		}
+		ret = pos - buf;
+	} while (0);
+
+	(void)upnp_wps_ctrlpt_destroy_device_list(list);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_send_upnp_get_device_info(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+
+	do {
+		if (wps_opt_upnp_get_device_info(wpa_s->wps_opt_upnp, cmd))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int wpa_supplicant_ctrl_iface_set_upnp_selected_registrar(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int ret = -1;
+	char ctrl_url[NAME_SIZE];
+	int selected;
+
+	do {
+		if (2 != sscanf(cmd, "%s %d", ctrl_url, &selected))
+			break;
+
+		if (wps_opt_upnp_set_selected_registrar(wpa_s->wps_opt_upnp,
+												ctrl_url, selected))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+#endif /* WPS_OPT_UPNP */
+
+
+#ifdef WPS_OPT_NFC
+static int wpa_supplicant_ctrl_iface_cancel_nfc_command(
+	struct wpa_supplicant *wpa_s)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: CANCEL_NFC_COMMAND");
+
+	if (wps_opt_nfc_cancel_nfc_comand(wpa_s->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_read_password_token(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int id;
+
+	id = atoi(cmd);
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: READ_PASSWORD_TOKEN id=%d", id);
+
+	if (wps_opt_nfc_read_password_token(wpa_s->wps_opt_nfc, id))
+		return -1;
+	return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_write_password_token(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int id;
+
+	id = atoi(cmd);
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: WRITE_PASSWORD_TOKEN id=%d", id);
+
+	if (wps_opt_nfc_write_password_token(wpa_s->wps_opt_nfc, id))
+		return -1;
+	return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_read_config_token(
+	struct wpa_supplicant *wpa_s)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: READ_CONFIG_TOKEN");
+
+	if (wps_opt_nfc_read_config_token(wpa_s->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int wpa_supplicant_ctrl_iface_write_config_token(
+	struct wpa_supplicant *wpa_s, char *cmd)
+{
+	int id;
+
+	id = atoi(cmd);
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: WRITE_CONFIG_TOKEN id=%d", id);
+
+	if (wps_opt_nfc_write_config_token(wpa_s->wps_opt_nfc, id))
+		return -1;
+	return 0;
+}
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
+
+
 char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 					 char *buf, size_t *resp_len)
 {
@@ -1076,6 +1599,12 @@
 	    os_strncmp(buf, "SET_NETWORK ", 12) == 0) {
 		wpa_hexdump_ascii_key(MSG_DEBUG, "RX ctrl_iface",
 				      (const u8 *) buf, os_strlen(buf));
+#ifdef MODIFIED_BY_SONY
+	} else if ((0 == os_strncmp(buf, "PING", 4)) ||
+			   (0 == os_strncmp(buf, "STATUS", 6))) {
+		wpa_hexdump_ascii(MSG_MSGDUMP, "RX ctrl_iface",
+				  (const u8 *) buf, os_strlen(buf));
+#endif /* MODIFIED_BY_SONY */
 	} else {
 		wpa_hexdump_ascii(MSG_DEBUG, "RX ctrl_iface",
 				  (const u8 *) buf, os_strlen(buf));
@@ -1188,6 +1717,65 @@
 	} else if (os_strcmp(buf, "INTERFACES") == 0) {
 		reply_len = wpa_supplicant_global_iface_interfaces(
 			wpa_s->global, reply, reply_size);
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	} else if (os_strncmp(buf, "WPS_PBC_ENABLED ", 16) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_pbc_enabed(wpa_s, buf + 16))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_REGMODE ", 16) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_set_regmode(wpa_s, buf + 16))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_CONFIGURATION ", 22) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_set_configuration(wpa_s, buf + 22))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_CLEAR_PASSWORD", 18) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_clear_password(wpa_s))
+			reply_len = -1;
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_UPNP
+	} else if (os_strncmp(buf, "UPNP_ENABLED ", 13) == 0) {
+		if (wpa_supplicant_ctrl_iface_upnp_enabled(wpa_s, buf + 13))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "UPNP_SET_IF ", 12) == 0) {
+		if (wpa_supplicant_ctrl_iface_upnp_set_if(wpa_s, buf + 12))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_UPNP_DEVICE ", 20) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_set_current_upnp_device(wpa_s, buf + 20))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_PASSWORD ", 17) == 0) {
+		if (wpa_supplicant_ctrl_iface_wps_set_password(wpa_s, buf + 17))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "UPNP_REFRESH ", 13) == 0) {
+		if (wpa_supplicant_ctrl_iface_reflesh_device(wpa_s, buf + 13))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "GET_UPNP_SCAN_RESULTS", 21) == 0) {
+		reply_len = wpa_supplicant_ctrl_iface_get_upnp_scan_results(
+			wpa_s, reply, reply_size);
+	} else if (os_strncmp(buf, "SEND_UPNP_GETDEVINFO ", 21) == 0) {
+		if (wpa_supplicant_ctrl_iface_send_upnp_get_device_info(wpa_s, buf + 21))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "SET_UPNP_SEL_REG ", 17) == 0) {
+		if (wpa_supplicant_ctrl_iface_set_upnp_selected_registrar(wpa_s, buf + 17))
+			reply_len = -1;
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+	} else if (os_strncmp(buf, "CANCEL_NFC_COMMAND", 18) == 0) {
+		if (wpa_supplicant_ctrl_iface_cancel_nfc_command(wpa_s))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "READ_PASSWORD_TOKEN ", 20) == 0) {
+		if (wpa_supplicant_ctrl_iface_read_password_token(wpa_s, buf + 20))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WRITE_PASSWORD_TOKEN ", 21) == 0) {
+		if (wpa_supplicant_ctrl_iface_write_password_token(wpa_s, buf + 21))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "READ_CONFIG_TOKEN", 17) == 0) {
+		if (wpa_supplicant_ctrl_iface_read_config_token(wpa_s))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WRITE_CONFIG_TOKEN ", 19) == 0) {
+		if (wpa_supplicant_ctrl_iface_write_config_token(wpa_s, buf + 19))
+			reply_len = -1;
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
Index: driver_madwifi.c
===================================================================
--- driver_madwifi.c	(revision 1)
+++ driver_madwifi.c	(revision 2)
@@ -39,6 +39,12 @@
 #define MADWIFI_NG
 #endif /* IEEE80211_IOCTL_SETWMMPARAMS */
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 struct wpa_driver_madwifi_data {
 	void *wext; /* private data for driver_wext */
 	void *ctx;
@@ -58,6 +64,14 @@
 		/*
 		 * Argument data fits inline; put it there.
 		 */
+#ifdef EAP_WPS
+#ifdef ATH_WPS_IE
+		if (op == IEEE80211_IOCTL_SET_APPIEBUF) {
+			iwr.u.data.pointer = data;
+			iwr.u.data.length = len;
+		} else
+#endif /* ATH_WPS_IE */
+#endif /* EAP_WPS */
 		os_memcpy(iwr.u.name, data, len);
 	} else {
 		/*
@@ -160,7 +174,28 @@
 	return 0;
 }
 
+#ifdef MODIFIED_BY_SONY
 static int
+get80211param(struct wpa_driver_madwifi_data *drv, int op, int *arg,
+	      int show_err)
+{
+	struct iwreq iwr;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.mode = op;
+
+	if (ioctl(drv->sock, IEEE80211_IOCTL_GETPARAM, &iwr) < 0) {
+		if (show_err) 
+			perror("ioctl[IEEE80211_IOCTL_GETPARAM]");
+		return -1;
+	}
+	os_memcpy(arg, &iwr.u.param.value, sizeof(arg));
+	return 0;
+}
+#endif /* MODIFIED_BY_SONY */
+
+static int
 wpa_driver_madwifi_set_wpa_ie(struct wpa_driver_madwifi_data *drv,
 			      const u8 *wpa_ie, size_t wpa_ie_len)
 {
@@ -338,6 +373,10 @@
 
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
 
+#ifdef MODIFIED_BY_SONY
+		(void)wpa_driver_wext_auth_alg_fallback(drv->wext, params);
+#endif /* MODIFIED_BY_SONY */
+
 	/*
 	 * NB: Don't need to set the freq or cipher-related state as
 	 *     this is implied by the bssid which is used to locate
@@ -476,9 +515,56 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static int
+madwifi_set_wps_ie(void *priv, u8 *iebuf, int iebuflen, u32 frametype)
+{
+	u8 buf[256];
+	struct ieee80211req_getset_appiebuf * beac_ie;
+	// int i;
+
+	wpa_printf(MSG_DEBUG, "%s buflen = %d\n", __func__, iebuflen);
+
+	beac_ie = (struct ieee80211req_getset_appiebuf *) buf;
+	beac_ie->app_frmtype = frametype;
+	beac_ie->app_buflen = iebuflen;
+	os_memcpy(&(beac_ie->app_buf[0]), iebuf, iebuflen);
+	
+	return set80211priv(priv, IEEE80211_IOCTL_SET_APPIEBUF, beac_ie,
+			sizeof(struct ieee80211req_getset_appiebuf) + iebuflen, 1);
+}
+
+
+static int wpa_driver_madwifi_set_wps_probe_req_ie(
+			     void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wps_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_PROBE_REQ);
+}
+
+
+static int wpa_driver_madwifi_set_wps_assoc_req_ie(
+			     void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wps_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_ASSOC_REQ);
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
 static void * wpa_driver_madwifi_init(void *ctx, const char *ifname)
 {
 	struct wpa_driver_madwifi_data *drv;
+#ifdef MODIFIED_BY_SONY
+	int caps = 0;
+#endif /* MODIFIED_BY_SONY */
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	int ret = -1;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
 	drv = os_zalloc(sizeof(*drv));
 	if (drv == NULL)
@@ -493,6 +579,14 @@
 	if (drv->sock < 0)
 		goto fail2;
 
+#ifdef MODIFIED_BY_SONY
+	if (get80211param(drv, IEEE80211_PARAM_DRIVER_CAPS, &caps, 1) < 0) {
+		wpa_printf(MSG_DEBUG, "%s: failed to get driver capabilities"
+			   "device_caps", __FUNCTION__);
+	}
+	wpa_printf(MSG_DEBUG, "driver capabilities : 0x%08X", caps);
+#endif /* MODIFIED_BY_SONY */
+
 	if (set80211param(drv, IEEE80211_PARAM_ROAMING, 2, 1) < 0) {
 		wpa_printf(MSG_DEBUG, "%s: failed to set wpa_supplicant-based "
 			   "roaming", __FUNCTION__);
@@ -505,6 +599,29 @@
 		goto fail3;
 	}
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	do {
+		/* Clear WPS ProbeResp IE */
+		if (wpa_driver_madwifi_set_wps_probe_req_ie(drv, 0, 0)) {
+			wpa_printf(MSG_DEBUG, "%s: failed to clear WPS ProbeReq IE",
+				   __FUNCTION__);
+			break;
+		}
+		/* Clear WPS AssocReq IE */
+		if (wpa_driver_madwifi_set_wps_assoc_req_ie(drv, 0, 0)) {
+			wpa_printf(MSG_DEBUG, "%s: failed to clear WPS AssocReq IE",
+				   __FUNCTION__);
+			break;
+		}
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		goto fail3;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	return drv;
 
 fail3:
@@ -562,4 +679,10 @@
 	.associate		= wpa_driver_madwifi_associate,
 	.set_auth_alg		= wpa_driver_madwifi_set_auth_alg,
 	.set_operstate		= wpa_driver_madwifi_set_operstate,
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	.set_wps_probe_req_ie	= wpa_driver_madwifi_set_wps_probe_req_ie,
+	.set_wps_assoc_req_ie	= wpa_driver_madwifi_set_wps_assoc_req_ie,
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
Index: wps_config.c
===================================================================
--- wps_config.c	(revision 0)
+++ wps_config.c	(revision 2)
@@ -0,0 +1,945 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_config.c
+//  Description: EAP-WPS config source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "wpa_supplicant.h"
+#include "wpa_supplicant_i.h"
+#include "wpa.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wps_parser.h"
+
+extern int eap_wps_free_dh(void **dh);
+
+int wps_config_free_dh(void **dh)
+{
+	return eap_wps_free_dh(dh);
+}
+
+extern int is_hex(const u8 *data, size_t len);
+
+int wps_get_ssid_configuration(void *ctx, int index, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct wpa_supplicant *wpa_s = ctx;
+	struct wpa_ssid *ssid;
+	struct wps_data *wps = 0;
+	u16 auth, encr;
+	Boolean enabled8021x = 0;
+	u8 nwKeyIdx = -1;
+	u8 nwKey[64 + 1];
+	Boolean blval;
+	u16 length;
+	u8 nwIdx;
+
+	do {
+		if (!buf || !len)
+			break;
+		*buf = 0;
+		*len = 0;
+
+		ssid = wpa_config_get_network(wpa_s->conf, index);
+		if (!ssid)
+			break;
+
+		if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
+			if (ssid->proto & WPA_PROTO_RSN)
+				auth = WPS_AUTHTYPE_WPA2;
+			else
+				auth = WPS_AUTHTYPE_WPA;
+
+			if (ssid->pairwise_cipher & WPA_CIPHER_CCMP)
+				encr = WPS_ENCRTYPE_AES;
+			else
+				encr = WPS_ENCRTYPE_TKIP;
+			enabled8021x = 1;
+		} else if (ssid->key_mgmt & WPA_KEY_MGMT_PSK) {
+			if (ssid->proto & WPA_PROTO_RSN)
+				auth = WPS_AUTHTYPE_WPA2PSK;
+			else
+				auth = WPS_AUTHTYPE_WPAPSK;
+
+			if (ssid->pairwise_cipher & WPA_CIPHER_CCMP)
+				encr = WPS_ENCRTYPE_AES;
+			else
+				encr = WPS_ENCRTYPE_TKIP;
+			nwKeyIdx = 0;
+		} else if (ssid->key_mgmt & WPA_KEY_MGMT_NONE) {
+			if (ssid->auth_alg & WPA_AUTH_ALG_SHARED) {
+				auth = WPS_AUTHTYPE_SHARED;
+				nwKeyIdx = ssid->wep_tx_keyidx + 1;
+			} else
+				auth = WPS_AUTHTYPE_OPEN;
+
+			if ((ssid->pairwise_cipher & (WPA_CIPHER_WEP40|WPA_CIPHER_WEP104)) ||
+				(ssid->group_cipher & (WPA_CIPHER_WEP40|WPA_CIPHER_WEP104))) {
+				encr = WPS_ENCRTYPE_WEP;
+				nwKeyIdx = ssid->wep_tx_keyidx + 1;
+			} else
+				encr = WPS_ENCRTYPE_NONE;
+		} else if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
+			auth = WPS_AUTHTYPE_OPEN;
+			encr = WPS_ENCRTYPE_WEP;
+			enabled8021x = 1;
+		}
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Network Index */
+		nwIdx = ssid->id;
+		if (wps_set_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, 0))
+			break;
+
+		/* SSID */
+		if (wps_set_value(wps, WPS_TYPE_SSID, ssid->ssid, ssid->ssid_len))
+			break;
+
+		/* Authentication Type */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE, &auth, 0))
+			break;
+
+		/* Encryption Type */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE, &encr, 0))
+			break;
+
+		if (nwKeyIdx != (u8)-1) {
+			if (encr == WPS_ENCRTYPE_WEP) {
+				if ((1 > nwKeyIdx) || (4 < nwKeyIdx)) {
+					wpa_printf(MSG_WARNING, "Network Key Index is fixed. %d -> 1\n", nwKeyIdx);
+					nwKeyIdx = 1;
+				}
+
+				/* Network Key Index (Option) */
+				if (wps_set_value(wps, WPS_TYPE_NW_KEY_INDEX, &nwKeyIdx, 0))
+					break;
+			}
+
+			/* Network Key */
+			if (ssid->passphrase) {
+				length = os_strlen(ssid->passphrase);
+				strncpy((char *)nwKey, ssid->passphrase, length);
+				nwKey[length] = 0;
+			} else if (ssid->psk_set) {
+				length = PMK_LEN * 2;
+				wpa_snprintf_hex_uppercase((char *)nwKey, sizeof(nwKey), ssid->psk, length);
+				nwKey[length] = 0;
+			} else {
+				if (is_hex(ssid->wep_key[nwKeyIdx - 1], ssid->wep_key_len[nwKeyIdx - 1])) {
+					length = (u16)ssid->wep_key_len[nwKeyIdx - 1] * 2;
+					wpa_snprintf_hex_uppercase((char *)nwKey, sizeof(nwKey), ssid->wep_key[nwKeyIdx - 1], length);
+					nwKey[length] = 0;
+				} else {
+					length = (u16)ssid->wep_key_len[nwKeyIdx - 1];
+					strncpy((char *)nwKey, (char *)ssid->wep_key[nwKeyIdx - 1], length);
+					nwKey[length] = 0;
+				}
+			}
+			if (wps_set_value(wps, WPS_TYPE_NW_KEY, nwKey, length))
+				break;
+		} else {
+			/* Network Key (No Key) */
+			if (wps_set_value(wps, WPS_TYPE_NW_KEY, 0, 0)) {
+				break;
+			}
+		}
+
+		/* MAC Address */
+		if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, wpa_s->own_addr, ETH_ALEN))
+			break;
+
+		if (enabled8021x) {
+			char *value;
+
+			/* EAP Type (Option) */
+			value = wpa_config_get(ssid, "eap");
+			if (value) {
+				if (wps_set_value(wps, WPS_TYPE_EAP_TYPE, value, os_strlen(value))) {
+					free(value);
+					break;
+				}
+				free(value);
+			}
+
+			/* EAP Identity (Option) */
+			value = wpa_config_get(ssid, "identity");
+			if (value) {
+				if (wps_set_value(wps, WPS_TYPE_EAP_IDENTITY, value, os_strlen(value))) {
+					free(value);
+					break;
+				}
+				free(value);
+			}
+
+			/* Key Provided Automaticaly (Option) */
+			blval = 1;
+			if (wps_set_value(wps, WPS_TYPE_KEY_PROVIDED_AUTO, &blval, 0))
+				break;
+
+			/* 802.1X Enabled (Option) */
+			if (wps_set_value(wps, WPS_TYPE_8021X_ENABLED, &enabled8021x, 0))
+				break;
+		}
+
+		if (wps_write_wps_data(wps, buf, (u16 *)len))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (buf && *buf) {
+			free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_set_ssid_configuration(void *ctx, u8 *buf, size_t len)
+{
+	int ret = -1;
+	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)ctx;
+	struct wpa_ssid *ssid = 0;
+	struct wps_data *wps = 0;
+	u8 str_ssid[33];
+	u16 ssid_length;
+	u16 auth, encr;
+	u8 nwKeyIdx;
+	u8 *nwKey = 0;
+	u16 nwKey_length;
+	u8 macAddr[6];
+	char *eapType = 0;
+	char *eapIdentity = 0;
+	Boolean keyProvideAuto;
+	Boolean enabled8021X;
+	Boolean passphrase = 0;
+	u16 length;
+	char *var, *value;
+
+	do {
+		if (!wpa_s)
+			break;
+
+		ssid = wpa_config_add_network(wpa_s->conf);
+		if (!ssid)
+			break;
+		wpa_config_set_network_defaults(ssid);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* SSID */
+		ssid_length = sizeof(str_ssid);
+		if(wps_get_value(wps, WPS_TYPE_SSID, str_ssid, &ssid_length))
+			break;
+		str_ssid[ssid_length] = 0;
+
+		/* Authentication Type */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE, &auth, NULL))
+			break;
+
+		/* Encryption Type */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE, &encr, NULL))
+			break;
+
+		/* Network Key Index (Option) */
+		if(wps_get_value(wps, WPS_TYPE_NW_KEY_INDEX, &nwKeyIdx, NULL))
+			nwKeyIdx = 1;
+		if ((1 > nwKeyIdx) || (4 < nwKeyIdx)) { /* warning */
+			wpa_printf(MSG_WARNING, "Network Key Index is fixed. %d -> 1\n", nwKeyIdx);
+			nwKeyIdx = 1;
+		}
+
+		/* Network Key */
+		nwKey_length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_NW_KEY, NULL, &nwKey_length);
+		if (nwKey_length) {
+			nwKey = (u8 *)calloc(1, nwKey_length + 1);
+			if (!nwKey)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_NW_KEY, nwKey, &nwKey_length)) {
+				break;
+			}
+			nwKey[nwKey_length] = 0;
+		}
+
+		/* MAC Address */
+		length = sizeof(macAddr);
+		if(wps_get_value(wps, WPS_TYPE_MAC_ADDR, macAddr, &length))
+			break;
+
+		/* EAP Type (Option) */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_EAP_TYPE, NULL, &length);
+		if (length) {
+			eapType = (char *)calloc(1, length + 1);
+			if (!eapType)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_EAP_TYPE, eapType, &length)) {
+				break;
+			}
+			eapType[length] = 0;
+		}
+
+		/* EAP Identity (Option) */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_EAP_IDENTITY, NULL, &length);
+		if (length) {
+			eapIdentity = (char *)calloc(1, length + 1);
+			if (!eapIdentity)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_EAP_IDENTITY, eapIdentity, &length)) {
+				break;
+			}
+			eapIdentity[length] = 0;
+		}
+
+		/* Key Provided Automaticaly (Option) */
+		if(wps_get_value(wps, WPS_TYPE_KEY_PROVIDED_AUTO, &keyProvideAuto, NULL))
+			keyProvideAuto = 0;
+
+		/* 802.1X Enabled (Option) */
+		if(wps_get_value(wps, WPS_TYPE_8021X_ENABLED, &enabled8021X, NULL))
+			enabled8021X = 0;
+
+		/* Set Configuration */
+		ssid->disabled = 1;
+		/* ssid */
+		var = "ssid";
+		value = (char *)os_malloc(os_strlen((char *)str_ssid) + 3);
+		if (!value)
+			break;
+		os_snprintf(value, os_strlen((char *)str_ssid) + 3, "\"%s\"", str_ssid);
+		if (wpa_config_set(ssid, var, value, 0))
+			break;
+		free(value);
+
+		/* auth_alg */
+		var = "auth_alg";
+		if (WPS_AUTHTYPE_SHARED == auth)
+			value = "SHARED";
+		else
+			value = "OPEN";
+		if (wpa_config_set(ssid, var, value, 0))
+			break;
+
+		/* key_mgmt */
+		var = "key_mgmt";
+		switch (auth) {
+		case WPS_AUTHTYPE_OPEN:
+		case WPS_AUTHTYPE_SHARED:
+			if (enabled8021X)
+				value = "IEEE8021X";
+			else
+				value = "NONE";
+			break;
+		case WPS_AUTHTYPE_WPAPSK:
+		case WPS_AUTHTYPE_WPA2PSK:
+			if (enabled8021X)
+				value = "WPA-PSK IEEE8021X";
+			else
+				value = "WPA-PSK";
+			break;
+		case WPS_AUTHTYPE_WPA:
+		case WPS_AUTHTYPE_WPA2:
+			if (enabled8021X)
+				value = "WPA-EAP IEEE8021X";
+			else
+				value = "WPA-EAP";
+			break;
+		default:
+			value = 0;
+			break;
+		}
+		if (!value | wpa_config_set(ssid, var, value, 0))
+			break;
+
+		/* proto */
+		var = "proto";
+		switch (auth) {
+		case WPS_AUTHTYPE_WPA:
+		case WPS_AUTHTYPE_WPAPSK:
+			value = "WPA";
+			break;
+		case WPS_AUTHTYPE_WPA2:
+		case WPS_AUTHTYPE_WPA2PSK:
+			value = "RSN";
+			break;
+		default:
+			ssid->proto = 0;
+			value = 0;
+			break;
+		}
+		if (value && wpa_config_set(ssid, var, value, 0))
+			break;
+
+		/* pariwise */
+		var = "pairwise";
+		switch (encr) {
+		case WPS_ENCRTYPE_NONE:
+			ssid->pairwise_cipher = WPA_CIPHER_NONE;
+			value = 0;
+			break;
+		case WPS_ENCRTYPE_TKIP:
+			value = "TKIP";
+			break;
+		case WPS_ENCRTYPE_AES:
+			value = "CCMP";
+			break;
+		default:
+			value = 0;
+			break;
+		}
+		if (value && wpa_config_set(ssid, var, value, 0))
+			break;
+
+		/* group */
+		var = "group";
+		switch (encr) {
+		case WPS_ENCRTYPE_NONE:
+			ssid->group_cipher = WPA_CIPHER_NONE;
+			value = 0;
+			break;
+		case WPS_ENCRTYPE_WEP:
+			value = "WEP104 WEP40";
+			break;
+		case WPS_ENCRTYPE_TKIP:
+			value = "TKIP";
+			break;
+		case WPS_ENCRTYPE_AES:
+			value = "CCMP";
+			break;
+		default:
+			value = 0;
+			break;
+		}
+		if (value && wpa_config_set(ssid, var, value, 0))
+			break;
+
+		/* wep_tx_keyidx */
+		var = "wep_tx_keyidx";
+		switch (encr) {
+		case WPS_ENCRTYPE_WEP:
+			value = (char *)os_malloc(2);
+			if (!value)
+				break;
+			os_snprintf(value, 2, "%d", nwKeyIdx - 1);
+			break;
+		default:
+			value = 0;
+			break;
+		}
+		if (value && wpa_config_set(ssid, var, value, 0)) {
+			free(value);
+			break;
+		} else if (value)
+			free(value);
+		if (!value && (WPS_ENCRTYPE_WEP == encr))
+			break;
+
+		/* wep_keyn */
+		switch (encr) {
+		case WPS_ENCRTYPE_WEP:
+			var = (char *)os_malloc(9);
+			if (!var)
+				break;
+			os_snprintf(var, 9, "wep_key%d", nwKeyIdx - 1);
+			if (is_hex(nwKey, nwKey_length)) {
+				value = (char *)os_malloc(nwKey_length * 2 + 1);
+				if (!value)
+					break;
+				wpa_snprintf_hex_uppercase(value, nwKey_length * 2 + 1,
+										   nwKey, nwKey_length);
+				value[nwKey_length * 2] = 0;
+			} else if ((5 == nwKey_length) || (13 == nwKey_length)) {
+				value = (char *)os_malloc(nwKey_length + 3);
+				if (!value)
+					break;
+				os_snprintf(value, nwKey_length + 3, "\"%s\"", nwKey);
+			} else if ((nwKey_length) || (13 == nwKey_length)) {
+				value = (char *)os_malloc(nwKey_length + 1);
+				if (!value)
+					break;
+				os_memcpy(value, nwKey, nwKey_length);
+				value[nwKey_length] = 0;
+			}
+			break;
+		default:
+			var = 0;
+			value = 0;
+			break;
+		}
+		if (var && value && wpa_config_set(ssid, var, value, 0))
+			break;
+		if (var)
+			free(var);
+		if (value)
+			free(value);
+		if ((!var || !value) && (WPS_ENCRTYPE_WEP == encr))
+			break;
+
+		/* psk */
+		var = "psk";
+		switch (auth) {
+		case WPS_AUTHTYPE_WPA:
+		case WPS_AUTHTYPE_WPA2:
+		case WPS_AUTHTYPE_WPAPSK:
+		case WPS_AUTHTYPE_WPA2PSK:
+			if (nwKey_length) {
+				value = (char *)os_malloc(nwKey_length + 3);
+				if (!value)
+					break;
+				if (64 > nwKey_length) {
+					os_snprintf(value, nwKey_length + 3, "\"%s\"", nwKey);
+					passphrase = 1;
+				} else if (64 == nwKey_length) {
+					os_memcpy(value, nwKey, nwKey_length);
+					value[nwKey_length] = 0;
+				} else {
+					free(value);
+					value = 0;
+					break;
+				}
+			} else
+				value = 0;
+			break;
+		default:
+			value = 0;
+			break;
+		}
+		if (value && wpa_config_set(ssid, var, value, 0)) {
+			free(value);
+			break;
+		} else if (value)
+			free(value);
+		if (nwKey_length && !value &&
+			((WPS_AUTHTYPE_WPA == auth) ||
+			 (WPS_AUTHTYPE_WPA2 == auth) ||
+			 (WPS_AUTHTYPE_WPAPSK == auth) ||
+			 (WPS_AUTHTYPE_WPA2PSK == auth)))
+			break;
+		
+		/* eap */
+		if (eapType && os_strlen(eapType)) {
+			var = "eap";
+			value = (char *)eapType;
+			if (wpa_config_set(ssid, var, value, 0))
+				break;
+		}
+
+		/* identity */
+		if (eapIdentity && os_strlen(eapIdentity)) {
+			var = "identity";
+			value = (char *)eapIdentity;
+			if (wpa_config_set(ssid, var, value, 0))
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (ssid)
+			(void)wpa_config_remove_network(wpa_s->conf, ssid->id);
+	} else {
+		if (passphrase)
+			wpa_config_update_psk(ssid);
+	}
+
+	if (nwKey)
+		free(nwKey);
+	if (eapType)
+		free(eapType);
+	if (eapIdentity)
+		free(eapIdentity);
+
+	return ret?ret:ssid->id;
+}
+
+
+struct wpa_scan_result *wps_select_pbc_ssid(struct wpa_supplicant *wpa_s,
+									 struct wpa_scan_result *results,
+									 int num, struct wpa_ssid **ssid)
+{
+	struct wpa_scan_result *selected = 0, *bss;
+	struct wpa_ssid *tmp;
+	int ret = -1;
+	char *var, *value;
+	int num_pbc_enabled;
+	struct wps_data *data = 0;
+	char bssid_str[18+1];
+	char ssid_str[32+3];
+	struct wps_config *wps;
+	int i;
+
+	do {
+		if (!wpa_s || !wpa_s->conf || !results || !num || !ssid)
+			break;
+
+		wps = wpa_s->conf->wps;
+
+		if (wps->nwid_trying_wps != -1) {
+			(void)wpa_config_remove_network(wpa_s->conf, wps->nwid_trying_wps);
+			wps->nwid_trying_wps = -1;
+		}
+
+		*ssid = 0;
+
+		num_pbc_enabled = 0;
+		for (i = 0; i < num; i++) {
+			bss = &results[i];
+			if (bss->wps_ie_len) {
+				u16 dev_pwd_id;
+
+				do {
+					if (wps_create_wps_data(&data))
+						break;
+
+					if (wps_parse_wps_ie(bss->wps_ie, bss->wps_ie_len, data))
+						break;
+
+					if (wps_get_value(data, WPS_TYPE_DEVICE_PWD_ID, &dev_pwd_id, 0))
+						break;
+
+					if (WPS_DEVICEPWDID_PUSH_BTN != dev_pwd_id)
+						break;
+
+					selected = bss;
+					num_pbc_enabled++;
+				} while (0);
+
+				(void)wps_destroy_wps_data(&data);
+			}
+		}
+
+		if (num_pbc_enabled != 1) {
+			selected = 0;
+			if (num_pbc_enabled > 1) {
+				wpa_msg(wpa_s, MSG_INFO, "There are multiple APs which is enabled WPS-PBC");
+			}
+		}
+
+		if (!selected)
+			break;
+
+		*ssid = wpa_config_add_network(wpa_s->conf);
+		if (!*ssid)
+			break;
+		wpa_config_set_network_defaults(*ssid);
+		(*ssid)->disabled = 1;
+
+		/* bssid */
+		var = "bssid";
+		os_snprintf(bssid_str, sizeof(bssid_str), "%02X:%02X:%02X:%02X:%02X:%02X",
+					selected->bssid[0], selected->bssid[1],
+					selected->bssid[2], selected->bssid[3],
+					selected->bssid[4], selected->bssid[5]);
+		bssid_str[18] = 0;
+		if (wpa_config_set(*ssid, var, bssid_str, 0))
+			break;
+
+		/* ssid */
+		var = "ssid";
+		ssid_str[0] = '"';
+		os_memcpy(ssid_str + 1, selected->ssid, selected->ssid_len);
+		ssid_str[selected->ssid_len + 1] = '"';
+		ssid_str[selected->ssid_len + 2] = 0;
+		if (wpa_config_set(*ssid, var, ssid_str, 0))
+			break;
+
+		/* auth_alg */
+		var = "auth_alg";
+		value = "OPEN";
+		if (wpa_config_set(*ssid, var, value, 0))
+			break;
+
+		/* key_mgmt */
+		var = "key_mgmt";
+		value = "IEEE8021X";
+		if (wpa_config_set(*ssid, var, value, 0))
+			break;
+
+		/* eap */
+		var = "eap";
+		value = "WPS";
+		if (wpa_config_set(*ssid, var, value, 0))
+			break;
+
+		/* identity */
+		var = "identity";
+		free((*ssid)->identity);
+		switch (wps->reg_mode) {
+		case WPS_REGMODE_NONE:
+			value = WPS_IDENTITY_ENROLLEE;
+			break;
+		default:
+			value = WPS_IDENTITY_REGISTRAR;
+			break;
+		}
+		(*ssid)->identity = (u8 *)os_strdup(value);
+		(*ssid)->identity_len = os_strlen(value);
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (*ssid)
+			(void)wpa_config_remove_network(wpa_s->conf, (*ssid)->id);
+		selected = 0;
+	} else {
+		wpa_msg(wpa_s, MSG_INFO, "Found AP enabled WPS-PBC [%*s]", (*ssid)->ssid_len,(*ssid)->ssid);
+
+		switch (wps->reg_mode) {
+		case WPS_REGMODE_NONE:
+			if (wps->config) {
+				free(wps->config);
+				wps->config = 0;
+				wps->config_len = 0;
+			}
+			break;
+		case WPS_REGMODE_CONFIGURE_AP:
+			break;
+		case WPS_REGMODE_REGISTER_AP:
+		case WPS_REGMODE_REGISTER_STA:
+			if (wps->config) {
+				free(wps->config);
+				wps->config = 0;
+				wps->config_len = 0;
+			}
+
+			(void)wps_get_ssid_configuration(wpa_s, (*ssid)->id, &wps->config, &wps->config_len);
+			break;
+		default:
+			break;
+		}
+
+		if (wpa_s->current_ssid)
+			wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+
+		tmp = wpa_s->conf->ssid;
+		while (tmp) {
+			tmp->disabled = (*ssid)->id != tmp->id;
+			tmp = tmp->next;
+		}
+
+		wps->nwid_trying_wps = (*ssid)->id;
+
+		wpa_s->reassociate = 1;
+		wpa_supplicant_req_scan(wpa_s, 0, 0);
+	}
+
+	return selected;
+}
+
+
+int wps_config_remove_network(struct wpa_supplicant *wpa_s, int network_id)
+{
+	if (0 > network_id)
+		return -1;
+	return wpa_config_remove_network(wpa_s->conf, network_id);
+}
+
+
+int wps_config_create_probe_req_ie(void *ctx, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct wpa_supplicant *wpa_s = ctx;
+	struct wps_config *wps;
+	struct wps_data *wps_ie;
+	u16 uuid_type;
+	u8 u8val;
+	u16 u16val;
+	u16 length;
+
+	do {
+		if (!wpa_s || !wpa_s->conf || !buf || !len)
+			break;
+
+		*buf = 0;
+		*len = 0;
+
+		wps = wpa_s->conf->wps;
+		if (!wps)
+			break;
+
+		if (wps_create_wps_data(&wps_ie))
+			break;
+
+		/* Version */
+		if (!wps->version)
+			u8val = WPS_VERSION;
+		else
+			u8val = wps->version;
+		if (wps_set_value(wps_ie, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Request Type */
+		if (WPS_REGMODE_NONE == wps->reg_mode)
+			u8val = WPS_REQTYPE_ENROLLEE_INFO_ONLY;
+		else
+			u8val = WPS_REQTYPE_REGISTRAR;
+		if (wps_set_value(wps_ie, WPS_TYPE_REQ_TYPE, &u8val, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps_ie, WPS_TYPE_CONFIG_METHODS, &wps->config_methods, 0))
+			break;
+
+		/* UUID-(E or R) */
+		if (!wps->uuid_set)
+			break;
+		if (wps->reg_mode == WPS_REGMODE_NONE)
+			uuid_type = WPS_TYPE_UUID_E;
+		else
+			uuid_type = WPS_TYPE_UUID_R;
+		if (wps_set_value(wps_ie, uuid_type, wps->uuid, sizeof(wps->uuid)))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps_ie, WPS_TYPE_PRIM_DEV_TYPE, wps->prim_dev_type, sizeof(wps->prim_dev_type)))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps_ie, WPS_TYPE_RF_BANDS, &wps->rf_bands, 0))
+			break;
+
+		/* Association State */
+		u16val = WPS_ASSOC_NOT_ASSOCIATED;
+		if (wps_set_value(wps_ie, WPS_TYPE_ASSOC_STATE, &u16val, 0))
+			break;
+
+		/* Configuration Error */
+		u16val = WPS_ERROR_NO_ERROR;
+		if (wps_set_value(wps_ie, WPS_TYPE_CONFIG_ERROR, &u16val, 0))
+			break;
+
+		/* Device Password ID */
+		if (wps_set_value(wps_ie, WPS_TYPE_DEVICE_PWD_ID, &wps->dev_pwd_id, 0))
+			break;
+
+		length = 0;
+		if (wps_write_wps_ie(wps_ie, buf, &length))
+			break;
+		*len = (size_t)length;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (buf && *buf) {
+			free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+int wps_config_create_assoc_req_ie(void *ctx, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct wpa_supplicant *wpa_s = ctx;
+	struct wps_config *wps;
+	struct wps_data *wps_ie;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!wpa_s || !wpa_s->conf || !buf || !len)
+			break;
+
+		*buf = 0;
+		*len = 0;
+
+		wps = wpa_s->conf->wps;
+		if (!wps)
+			break;
+
+		if (wps_create_wps_data(&wps_ie))
+			break;
+
+		/* Version */
+		if (!wps->version)
+			u8val = WPS_VERSION;
+		else
+			u8val = wps->version;
+		if (wps_set_value(wps_ie, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Request Type */
+		if (WPS_REGMODE_NONE == wps->reg_mode)
+			u8val = WPS_REQTYPE_ENROLLEE_INFO_ONLY;
+		else
+			u8val = WPS_REQTYPE_REGISTRAR;
+		if (wps_set_value(wps_ie, WPS_TYPE_REQ_TYPE, &u8val, 0))
+			break;
+
+		length = 0;
+		if (wps_write_wps_ie(wps_ie, buf, &length))
+			break;
+		*len = (size_t)length;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (buf && *buf) {
+			free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
Index: wps_config.h
===================================================================
--- wps_config.h	(revision 0)
+++ wps_config.h	(revision 2)
@@ -0,0 +1,428 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_config.h
+//  Description: EAP-WPS config source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_CONFIG_H
+#define WPS_CONFIG_H
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+/* Wi-Fi Protected Setup Version */
+#define WPS_VERSION		0x10
+#define WPS_VERSION_EX	0x11
+
+/* Data Element Definitions */
+#define WPS_TYPE_AP_CHANNEL				0x1001
+#define WPS_TYPE_ASSOC_STATE			0x1002
+#define WPS_TYPE_AUTH_TYPE				0x1003
+#define WPS_TYPE_AUTH_TYPE_FLAGS		0x1004
+#define WPS_TYPE_AUTHENTICATOR			0x1005
+#define WPS_TYPE_CONFIG_METHODS			0x1008
+#define WPS_TYPE_CONFIG_ERROR			0x1009
+#define WPS_TYPE_CONF_URL4				0x100A
+#define WPS_TYPE_CONF_URL6				0x100B
+#define WPS_TYPE_CONN_TYPE				0x100C
+#define WPS_TYPE_CONN_TYPE_FLAGS		0x100D
+#define WPS_TYPE_CREDENTIAL				0x100E
+#define WPS_TYPE_DEVICE_NAME			0x1011
+#define WPS_TYPE_DEVICE_PWD_ID			0x1012
+#define WPS_TYPE_E_HASH1				0x1014
+#define WPS_TYPE_E_HASH2				0x1015
+#define WPS_TYPE_E_SNONCE1				0x1016
+#define WPS_TYPE_E_SNONCE2				0x1017
+#define WPS_TYPE_ENCR_SETTINGS			0x1018
+#define WPS_TYPE_ENCR_TYPE				0x100F
+#define WPS_TYPE_ENCR_TYPE_FLAGS		0x1010
+#define WPS_TYPE_ENROLLEE_NONCE			0x101A
+#define WPS_TYPE_FEATURE_ID				0x101B
+#define WPS_TYPE_IDENTITY				0x101C
+#define WPS_TYPE_IDENTITY_PROOF			0x101D
+#define WPS_TYPE_KEY_WRAP_AUTH			0x101E
+#define WPS_TYPE_KEY_IDENTIFIER			0x101F
+#define WPS_TYPE_MAC_ADDR				0x1020
+#define WPS_TYPE_MANUFACTURER			0x1021
+#define WPS_TYPE_MSG_TYPE				0x1022
+#define WPS_TYPE_MODEL_NAME				0x1023
+#define WPS_TYPE_MODEL_NUMBER			0x1024
+#define WPS_TYPE_NW_INDEX				0x1026
+#define WPS_TYPE_NW_KEY					0x1027
+#define WPS_TYPE_NW_KEY_INDEX			0x1028
+#define WPS_TYPE_NEW_DEVICE_NAME		0x1029
+#define WPS_TYPE_NEW_PWD				0x102A
+#define WPS_TYPE_OOB_DEV_PWD			0x102C
+#define WPS_TYPE_OS_VERSION				0x102D
+#define WPS_TYPE_POWER_LEVEL			0x102F
+#define WPS_TYPE_PSK_CURRENT			0x1030
+#define WPS_TYPE_PSK_MAX				0x1031
+#define WPS_TYPE_PUBLIC_KEY				0x1032
+#define WPS_TYPE_RADIO_ENABLED			0x1033
+#define WPS_TYPE_REBOOT					0x1034
+#define WPS_TYPE_REGISTRAR_CURRENT		0x1035
+#define WPS_TYPE_REGISTRAR_ESTBLSHD		0x1036
+#define WPS_TYPE_REGISTRAR_LIST			0x1037
+#define WPS_TYPE_REGISTRAR_MAX			0x1038
+#define WPS_TYPE_REGISTRAR_NONCE		0x1039
+#define WPS_TYPE_REQ_TYPE				0x103A
+#define WPS_TYPE_RESP_TYPE				0x103B
+#define WPS_TYPE_RF_BANDS				0x103C
+#define WPS_TYPE_R_HASH1				0x103D
+#define WPS_TYPE_R_HASH2				0x103E
+#define WPS_TYPE_R_SNONCE1				0x103F
+#define WPS_TYPE_R_SNONCE2				0x1040
+#define WPS_TYPE_SEL_REGISTRAR			0x1041
+#define WPS_TYPE_SERIAL_NUM				0x1042
+#define WPS_TYPE_WPSSTATE				0x1044
+#define WPS_TYPE_SSID					0x1045
+#define WPS_TYPE_TOT_NETWORKS			0x1046
+#define WPS_TYPE_UUID_E					0x1047
+#define WPS_TYPE_UUID_R					0x1048
+#define WPS_TYPE_VENDOR_EXT				0x1049
+#define WPS_TYPE_VERSION				0x104A
+#define WPS_TYPE_X509_CERT_REQ			0x104B
+#define WPS_TYPE_X509_CERT				0x104C
+#define WPS_TYPE_EAP_IDENTITY			0x104D
+#define WPS_TYPE_MSG_COUNTER			0x104E
+#define WPS_TYPE_PUBKEY_HASH			0x104F
+#define WPS_TYPE_REKEY_KEY				0x1050
+#define WPS_TYPE_KEY_LIFETIME			0x1051
+#define WPS_TYPE_PERM_CFG_METHODS		0x1052
+#define WPS_TYPE_SEL_REG_CFG_METHODS	0x1053
+#define WPS_TYPE_PRIM_DEV_TYPE			0x1054
+#define WPS_TYPE_SEC_DEV_TYPE_LIST		0x1055
+#define WPS_TYPE_PORTABLE_DEVICE		0x1056
+#define WPS_TYPE_AP_SETUP_LOCKED		0x1057
+#define WPS_TYPE_APP_EXT				0x1058
+#define WPS_TYPE_EAP_TYPE				0x1059
+#define WPS_TYPE_INIT_VECTOR			0x1060
+#define WPS_TYPE_KEY_PROVIDED_AUTO		0x1061
+#define WPS_TYPE_8021X_ENABLED			0x1062
+#define WPS_TYPE_APP_SESS_KEY			0x1063
+#define WPS_TYPE_WEP_TX_KEY				0x1064
+
+/* Association states */
+#define WPS_ASSOC_NOT_ASSOCIATED	0
+#define WPS_ASSOC_CONN_SUCCESS		1
+#define WPS_ASSOC_CONFIG_FAIL		2
+#define WPS_ASSOC_ASSOC_FAIL		3
+#define WPS_ASSOC_IP_FAIL			4
+
+/* Authentication types */
+#define WPS_AUTHTYPE_OPEN		0x0001
+#define WPS_AUTHTYPE_WPAPSK		0x0002
+#define WPS_AUTHTYPE_SHARED		0x0004
+#define WPS_AUTHTYPE_WPA		0x0008
+#define WPS_AUTHTYPE_WPA2		0x0010
+#define WPS_AUTHTYPE_WPA2PSK	0x0020
+
+/* Config methods */
+#define WPS_CONFMET_USBA		0x0001
+#define WPS_CONFMET_ETHERNET	0x0002
+#define WPS_CONFMET_LABEL		0x0004
+#define WPS_CONFMET_DISPLAY		0x0008
+#define WPS_CONFMET_EXT_NFC_TOK	0x0010
+#define WPS_CONFMET_INT_NFC_TOK	0x0020
+#define WPS_CONFMET_NFC_INTF	0x0040
+#define WPS_CONFMET_PBC			0x0080
+#define WPS_CONFMET_KEYPAD		0x0100
+
+/* WPS error messages */
+#define WPS_ERROR_NO_ERROR				0
+#define WPS_ERROR_OOB_INT_READ_ERR		1
+#define WPS_ERROR_DECRYPT_CRC_FAIL		2
+#define WPS_ERROR_CHAN24_NOT_SUPP		3
+#define WPS_ERROR_CHAN50_NOT_SUPP		4
+#define WPS_ERROR_SIGNAL_WEAK			5
+#define WPS_ERROR_NW_AUTH_FAIL			6
+#define WPS_ERROR_NW_ASSOC_FAIL			7
+#define WPS_ERROR_NO_DHCP_RESP			8
+#define WPS_ERROR_FAILED_DHCP_CONF		9
+#define WPS_ERROR_IP_ADDR_CONFLICT		10
+#define WPS_ERROR_FAIL_CONN_REGISTRAR	11
+#define WPS_ERROR_MULTI_PBC_DETECTED	12
+#define WPS_ERROR_ROGUE_SUSPECTED		13
+#define WPS_ERROR_DEVICE_BUSY			14
+#define WPS_ERROR_SETUP_LOCKED			15
+#define WPS_ERROR_MSG_TIMEOUT			16
+#define WPS_ERROR_REG_SESSION_TIMEOUT	17
+#define WPS_ERROR_DEV_PWD_AUTH_FAIL		18
+
+/* Connection types */
+#define WPS_CONNTYPE_ESS	0x01
+#define WPS_CONNTYPE_IBSS	0x02
+
+/* Device password ID */
+#define WPS_DEVICEPWDID_DEFAULT			0x0000
+#define WPS_DEVICEPWDID_USER_SPEC		0x0001
+#define WPS_DEVICEPWDID_MACHINE_SPEC	0x0002
+#define WPS_DEVICEPWDID_REKEY			0x0003
+#define WPS_DEVICEPWDID_PUSH_BTN		0x0004
+#define WPS_DEVICEPWDID_REG_SPEC		0x0005
+
+/* Device type */
+/*
+#define WPS_DEVICETYPE_COMPUTER			"Computer"
+#define WPS_DEVICETYPE_AP				"Access_Point"
+#define WPS_DEVICETYPE_ROUTER_AP		"Router_AP"
+#define WPS_DEVICETYPE_PRINTER			"Printer"
+#define WPS_DEVICETYPE_PRINTER_BRIDGE	"Printer_Brigde"
+#define WPS_DEVICETYPE_ELECT_PIC_FRAME	"Electronic_Picture_Frame"
+#define WPS_DEVICETYPE_DIG_AUDIO_RECV	"Digital_Audio_Receiver"
+#define WPS_DEVICETYPE_WIN_MCE			"Windows_Media_Center_Extender"
+#define WPS_DEVICETYPE_WIN_MOBILE		"Windows_Mobile"
+#define WPS_DEVICETYPE_PVR				"Personal_Video_Recorder"
+#define WPS_DEVICETYPE_VIDEO_STB		"Video_STB"
+#define WPS_DEVICETYPE_PROJECTOR		"Projector"
+#define WPS_DEVICETYPE_IP_TV			"IP_TV"
+#define WPS_DEVICETYPE_DIG_STILL_CAM	"Digital_Still_Camera"
+#define WPS_DEVICETYPE_PHONE			"Phone"
+#define WPS_DEVICETYPE_VOID_PHONE		"VoIP_Phone"
+#define WPS_DEVICETYPE_GAME_CONSOLE		"Game_console"
+#define WPS_DEVICETYPE_OTHER			"Other"
+*/
+
+/* Encryption type */
+#define WPS_ENCRTYPE_NONE	0x0001
+#define WPS_ENCRTYPE_WEP	0x0002
+#define WPS_ENCRTYPE_TKIP	0x0004
+#define WPS_ENCRTYPE_AES	0x0008
+
+
+/* WPS Message Types */
+#define WPS_MSGTYPE_BEACON		0x01
+#define WPS_MSGTYPE_PROBE_REQ	0x02
+#define WPS_MSGTYPE_PROBE_RESP	0x03
+#define WPS_MSGTYPE_M1			0x04
+#define WPS_MSGTYPE_M2			0x05
+#define WPS_MSGTYPE_M2D			0x06
+#define WPS_MSGTYPE_M3			0x07
+#define WPS_MSGTYPE_M4			0x08
+#define WPS_MSGTYPE_M5			0x09
+#define WPS_MSGTYPE_M6			0x0A
+#define WPS_MSGTYPE_M7			0x0B
+#define WPS_MSGTYPE_M8			0x0C
+#define WPS_MSGTYPE_ACK			0x0D
+#define WPS_MSGTYPE_NACK		0x0E
+#define WPS_MSGTYPE_DONE		0x0F
+
+/*Device Type categories for primary and secondary device types */
+#define WPS_DEVICE_TYPE_CAT_COMPUTER		1
+#define WPS_DEVICE_TYPE_CAT_INPUT_DEVICE	2
+#define WPS_DEVICE_TYPE_CAT_PRINTER			3
+#define WPS_DEVICE_TYPE_CAT_CAMERA			4
+#define WPS_DEVICE_TYPE_CAT_STORAGE			5
+#define WPS_DEVICE_TYPE_CAT_NW_INFRA		6
+#define WPS_DEVICE_TYPE_CAT_DISPLAYS		7
+#define WPS_DEVICE_TYPE_CAT_MM_DEVICES		8
+#define WPS_DEVICE_TYPE_CAT_GAME_DEVICES	9
+#define WPS_DEVICE_TYPE_CAT_TELEPHONE		10
+
+/* Device Type sub categories for primary and secondary device types */
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_PC			1
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_SERVER		2
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_MEDIA_CTR	3
+#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_PRINTER	1
+#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_SCANNER	2
+#define WPS_DEVICE_TYPE_SUB_CAT_CAM_DGTL_STILL	1
+#define WPS_DEVICE_TYPE_SUB_CAT_STOR_NAS		1
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_AP			1
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_ROUTER		2
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_SWITCH		3
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_TV			1
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PIC_FRAME	2
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PROJECTOR	3
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_DAR			1
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_PVR			2
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_MCX			3
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX		1
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX_360	2
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_PS			3
+#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_WM		1
+
+/* Device request type */
+#define WPS_REQTYPE_ENROLLEE_INFO_ONLY	0x00
+#define WPS_REQTYPE_ENROLLEE_OPEN_8021X	0x01
+#define WPS_REQTYPE_REGISTRAR			0x02
+#define WPS_REQTYPE_AP_WLAN_MGR			0x03
+
+/* Device response type */
+#define WPS_RESTYPE_ENROLLEE_INFO_ONLY	0x00
+#define WPS_RESTYPE_ENROLLEE_OPEN_8021X	0x01
+#define WPS_RESTYPE_REGISTRAR			0x02
+#define WPS_RESTYPE_AP					0x03
+
+/* RF Band */
+#define WPS_RFBAND_24GHZ	0x01
+#define WPS_RFBAND_50GHZ	0x02
+
+/* Wi-Fi Protected Setup State */
+#define WPS_WPSSTATE_UNCONFIGURED	0x01
+#define WPS_WPSSTATE_CONFIGURED		0x02
+
+/* WPS OUI for primary and secondary device type sub-category */
+#define WPS_DEVTYPE_OUI	0x0050f204
+
+#define SIZE_1_BYTE		1
+#define SIZE_2_BYTES		2
+#define SIZE_4_BYTES		4
+#define SIZE_6_BYTES		6
+#define SIZE_8_BYTES		8
+#define SIZE_16_BYTES		16
+#define SIZE_20_BYTES		20
+#define SIZE_32_BYTES		32
+#define SIZE_64_BYTES		64
+#define SIZE_80_BYTES		80
+#define SIZE_128_BYTES		128
+#define SIZE_192_BYTES		192
+
+
+#define SIZE_64_BITS		SIZE_8_BYTES
+#define SIZE_128_BITS		SIZE_16_BYTES
+#define SIZE_160_BITS		SIZE_20_BYTES
+#define SIZE_256_BITS		SIZE_32_BYTES
+#define SIZE_512_BITS		SIZE_64_BYTES
+#define SIZE_1024_BITS		SIZE_128_BYTES
+#define SIZE_1536_BITS		SIZE_192_BYTES
+
+#define SIZE_ENCR_IV			SIZE_128_BITS
+#define ENCR_DATA_BLOCK_SIZE		SIZE_128_BITS
+#define SIZE_DATA_HASH			SIZE_160_BITS
+#define SIZE_PUB_KEY_HASH		SIZE_160_BITS
+#define SIZE_UUID				SIZE_16_BYTES
+#define SIZE_MAC_ADDR			SIZE_6_BYTES
+#define SIZE_PUB_KEY			SIZE_1536_BITS
+#define SIZE_NONCE				SIZE_128_BITS
+
+#define WPS_PERSONALIZATION_STRING "Wi-Fi Easy and Secure Key Derivation"
+#define PRF_DIGEST_SIZE         SIZE_256_BITS
+#define KDF_KEY_BITS            640
+
+#define WPS_IDENTITY_ENROLLEE	"WFA-SimpleConfig-Enrollee-1-0"
+#define WPS_IDENTITY_REGISTRAR	"WFA-SimpleConfig-Registrar-1-0"
+
+enum wps_reg_mode {
+	WPS_REGMODE_NONE = 0,
+	WPS_REGMODE_CONFIGURE_AP,
+	WPS_REGMODE_REGISTER_AP,
+	WPS_REGMODE_REGISTER_STA
+};
+
+struct wps_config {
+	u8		version;
+
+	u8		uuid[SIZE_UUID];
+	int		uuid_set;
+
+	u8		mac[SIZE_MAC_ADDR];
+	int		mac_set;
+
+	u16		auth_type_flags;
+
+	u16		encr_type_flags;
+
+	u8		conn_type_flags;
+
+	u16		config_methods;
+
+	u8		wps_state;
+
+	u8		*manufacturer;
+	size_t	manufacturer_len;
+
+	u8		*model_name;
+	size_t	model_name_len;
+
+	u8		*model_number;
+	size_t	model_number_len;
+
+	u8		*serial_number;
+	size_t	serial_number_len;
+
+	u16		dev_category;
+	u16		dev_sub_category;
+	u8		dev_oui[SIZE_4_BYTES];
+	u8		prim_dev_type[SIZE_8_BYTES];
+
+	u8		*dev_name;
+	size_t	dev_name_len;
+
+	u8		rf_bands;
+
+	u32		os_version;
+
+	int		nwid_trying_wps;
+
+	u16		dev_pwd_id;
+	u8		dev_pwd[SIZE_64_BYTES];
+	size_t	dev_pwd_len;
+
+	u8		pub_key[SIZE_PUB_KEY];
+	u8		set_pub_key;
+	void	*dh_secret;
+
+	enum wps_reg_mode reg_mode;
+	u8		*config;
+	size_t	config_len;
+
+	u8		enabled_pbc;
+	struct os_time end_pbc_time;
+
+#ifdef WPS_OPT_UPNP
+	char	*upnp_iface;
+	char	*cur_upnp_device;
+#endif /* WPS_OPT_UPNP */
+};
+
+
+struct wpa_supplicant;
+struct wpa_ssid;
+struct wpa_scan_result;
+
+int wps_config_free_dh(void **dh);
+
+int wps_get_ssid_configuration(void *ctx, int index, u8 **buf, size_t *len);
+int wps_set_ssid_configuration(void *ctx, u8 *buf, size_t len);
+struct wpa_scan_result *wps_select_pbc_ssid(struct wpa_supplicant *wpa_s,
+									 struct wpa_scan_result *results,
+									 int num, struct wpa_ssid **ssid);
+int wps_config_remove_network(struct wpa_supplicant *wpa_s, int network_id);
+
+int wps_config_create_probe_req_ie(void *ctx, u8 **buf, size_t *len);
+int wps_config_create_assoc_req_ie(void *ctx, u8 **buf, size_t *len);
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+#endif /* WPS_CONFIG_H */
Index: Changes_WPS
===================================================================
--- Changes_WPS	(revision 0)
+++ Changes_WPS	(revision 2)
@@ -0,0 +1,47 @@
+1. Changed files
+config.c
+config_file.c
+config.h
+ctrl_iface.c
+defconfig
+driver.h
+driver_madwifi.c
+driver_ndis.c
+driver_wext.c
+driver_wext.h
+eap.c
+eap.h
+eap_i.h
+eap_methods.c
+eapol_sm.c
+eapol_sm.h
+events.c
+libtommath.c
+main.c
+Makefile
+os_win32.c
+wpa.c
+wpa_supplicant.c
+wpa_supplicant_i.h
+
+2. Added files
+eap_wps.c
+eap_wps.h
+intel_eap_wps.c
+intel_eap_wps.h
+intel_ie_wps.c
+intel_ie_wps.h
+testbed_sta
+upnp_wps_common.c
+upnp_wps_common.h
+upnp_wps_ctrlpt.c
+upnp_wps_ctrlpt_win.c
+upnp_wps_ctrlpt.h
+wps_config.c
+wps_config.h
+wps_opt_nfc.c
+wps_opt_nfc.h
+wps_opt_upnp.c
+wps_opt_upnp.h
+wps_parser.c
+wps_parser.h
Index: upnp_wps_common.c
===================================================================
--- upnp_wps_common.c	(revision 0)
+++ upnp_wps_common.c	(revision 2)
@@ -0,0 +1,281 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_common.c
+//  Description: EAP-WPS UPnP common source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+#include "os.h"
+
+#include <upnp/ithread.h>
+#include <upnp/upnp.h>
+#include <upnp/upnptools.h>
+#include <upnp/ixml.h>
+
+int
+upnp_get_element_value(IXML_Element *element, char **value)
+{
+	int ret = -1;
+	IXML_Node *child;
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!element)
+			break;
+
+		child = ixmlNode_getFirstChild((IXML_Node *)element);
+		if (!child)
+			break;
+
+		if (eTEXT_NODE != ixmlNode_getNodeType(child))
+			break;
+
+		*value = os_strdup(ixmlNode_getNodeValue(child));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+IXML_NodeList *
+upnp_get_first_service_list(IXML_Document *doc)
+{
+	IXML_NodeList *service_list = 0;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *node = 0;
+
+	do {
+		if (!doc)
+			break;
+
+		node_list = ixmlDocument_getElementsByTagName(doc, "serviceList");
+		if (!node_list)
+			break;
+
+		if (!ixmlNodeList_length(node_list))
+			break;
+		node = ixmlNodeList_item(node_list, 0);
+
+		service_list = ixmlElement_getElementsByTagName((IXML_Element *)node,
+													    "service");
+		if (!service_list)
+			break;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	return service_list;
+}
+
+
+int
+upnp_get_first_document_item(IXML_Document *doc,
+							 const char *item,
+							 char **value)
+{
+	int ret = -1;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *item_node;
+	IXML_Node *txt_node;
+
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!doc || !item)
+			break;
+
+		node_list = ixmlDocument_getElementsByTagName(doc, (char *)item);
+		if (!node_list)
+			break;
+
+		item_node = ixmlNodeList_item(node_list, 0);
+		if (!item_node)
+			break;
+
+		txt_node = ixmlNode_getFirstChild(item_node);
+		*value = os_strdup(ixmlNode_getNodeValue(txt_node));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+int
+upnp_get_first_element_item(IXML_Element *element,
+							const char *item,
+							char **value)
+{
+	int ret = -1;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *item_node;
+	IXML_Node *txt_node;
+
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!element || !item)
+			break;
+
+		node_list = ixmlElement_getElementsByTagName(element, (char *)item);
+		if (!node_list)
+			break;
+
+		item_node = ixmlNodeList_item(node_list, 0);
+		if (!item_node)
+			break;
+
+		txt_node = ixmlNode_getFirstChild(item_node);
+		*value = os_strdup(ixmlNode_getNodeValue(txt_node));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+int
+upnp_find_service(IXML_Document *desc_doc,
+				  char *location,
+				  char *service_type,
+				  char **service_id,
+				  char **scpd_url,
+				  char **control_url,
+				  char **event_url)
+{
+	char *base_url = 0;
+	char *base;
+	char *type = 0;
+	char *scpd = NULL, *ctrl_url = NULL, *ev_url = NULL;
+	IXML_NodeList *service_list = NULL;
+	IXML_Element *service = NULL;
+	int i, length, found = 0;
+
+	(void)upnp_get_first_document_item(desc_doc, "URLBase", &base_url);
+	if(base_url)
+		base = base_url;
+	else
+		base = location;
+
+	service_list = upnp_get_first_service_list(desc_doc);
+	length = ixmlNodeList_length(service_list);
+	for( i = 0; i < length; i++ ) {
+		service = (IXML_Element *)ixmlNodeList_item(service_list, i);
+		(void)upnp_get_first_element_item(service, "serviceType", &type);
+		if(0 == strcmp(type, service_type)) {
+			(void)upnp_get_first_element_item(service, "serviceId", service_id);
+			(void)upnp_get_first_element_item(service, "SCPDURL", &scpd);
+			(void)upnp_get_first_element_item(service, "controlURL", &ctrl_url);
+			(void)upnp_get_first_element_item(service, "eventSubURL", &ev_url);
+			*scpd_url = os_malloc(os_strlen(base) + os_strlen(scpd) + 1);
+			if (*scpd_url) {
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, scpd, *scpd_url))
+					;
+			}
+
+			*control_url = os_malloc(os_strlen(base) + os_strlen(ctrl_url) + 1);
+			if(*control_url) {
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, ctrl_url, *control_url))
+					;
+			}
+
+			*event_url = os_malloc(os_strlen(base) + os_strlen(ev_url) + 1);
+			if(*event_url) {
+				
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, ev_url, *event_url))
+					;
+			}
+
+			if (scpd)
+				os_free(scpd);
+			if (ctrl_url)
+				os_free(ctrl_url);
+			if (ev_url)
+				os_free(ev_url);
+			scpd = ctrl_url = ev_url = 0;
+
+			found = 1;
+			break;
+		}
+	}
+
+	if(type)
+		os_free(type);
+    if(service_list)
+        ixmlNodeList_free(service_list);
+    if(base_url)
+        os_free(base_url);
+
+    return found;
+}
+
Index: wpa.c
===================================================================
--- wpa.c	(revision 1)
+++ wpa.c	(revision 2)
@@ -1935,6 +1935,7 @@
 		return -1;
 	}
 
+#ifndef EAP_WPS
 	if ((ie->wpa_ie && sm->ap_wpa_ie &&
 	     (ie->wpa_ie_len != sm->ap_wpa_ie_len ||
 	      os_memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len) != 0)) ||
@@ -1947,6 +1948,43 @@
 				       ie->rsn_ie, ie->rsn_ie_len);
 		return -1;
 	}
+#else /* EAP_WPS */
+	if ((ie->wpa_ie && sm->ap_wpa_ie &&
+	     (ie->wpa_ie_len != sm->ap_wpa_ie_len ||
+	      os_memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len) != 0)) ||
+	    (ie->rsn_ie && sm->ap_rsn_ie &&
+	     (ie->rsn_ie_len != sm->ap_rsn_ie_len ||
+	      os_memcmp(ie->rsn_ie, sm->ap_rsn_ie, ie->rsn_ie_len) != 0))) {
+		/* Ignore mismatch of capability [WME] in IE */
+		if ((ie->wpa_ie && sm->ap_wpa_ie &&
+			 (ie->wpa_ie_len != sm->ap_wpa_ie_len ||
+			  os_memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len - 2) != 0)) ||
+			(ie->rsn_ie && sm->ap_rsn_ie &&
+			 (ie->rsn_ie_len != sm->ap_rsn_ie_len ||
+			  os_memcmp(ie->rsn_ie, sm->ap_rsn_ie, ie->rsn_ie_len - 2) != 0))) {
+			wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match "
+						   "with IE in Beacon/ProbeResp",
+						   src_addr, ie->wpa_ie, ie->wpa_ie_len,
+						   ie->rsn_ie, ie->rsn_ie_len);
+			return -1;
+		} else {
+			const u8 *cap, *ap_cap;
+			if (ie->wpa_ie && sm->ap_wpa_ie) {
+				cap = &ie->wpa_ie[ie->wpa_ie_len - 2];
+				ap_cap = &sm->ap_wpa_ie[sm->ap_wpa_ie_len - 2];
+			} else {
+				cap = &ie->rsn_ie[ie->rsn_ie_len - 2];
+				ap_cap = &sm->ap_rsn_ie[sm->ap_rsn_ie_len - 2];
+			}
+			wpa_printf(MSG_INFO, "IE in 3/4 msg does not match "
+								 "with IE in Beacon/ProbeResp.\n"
+								 "But only capability in IE does not match, "
+								 "so ignore this mismatch in this case.\n"
+								 "[%02x%02x] in Beacon/ProbeResp -> [%02x%02x] in EAPOL_KEY",
+								 *cap, *(cap+1), *ap_cap, *(ap_cap+1));
+		}
+	}
+#endif /* EAP_WPS */
 
 	if (sm->proto == WPA_PROTO_WPA &&
 	    ie->rsn_ie && sm->ap_rsn_ie == NULL &&
Index: upnp_wps_common.h
===================================================================
--- upnp_wps_common.h	(revision 0)
+++ upnp_wps_common.h	(revision 2)
@@ -0,0 +1,57 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_common.h
+//  Description: EAP-WPS UPnP common source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef UPNP_WPS_COMMON_H
+#define UPNP_WPS_COMMON_H
+int
+upnp_get_element_value(IXML_Element *element, char **value);
+IXML_NodeList *
+upnp_get_first_service_list(IXML_Document *doc);
+int
+upnp_get_first_document_item(IXML_Document *doc,
+							 const char *item,
+							 char **value);
+int
+upnp_get_first_element_item(IXML_Element *element,
+							const char *item,
+							char **value);
+int
+upnp_find_service(IXML_Document *desc_doc,
+				  char *location,
+				  char *service_type,
+				  char **service_id,
+				  char **scpd_url,
+				  char **control_url,
+				  char **event_url);
+#endif /* UPNP_WPS_COMMON_H */
Index: eap.c
===================================================================
--- eap.c	(revision 1)
+++ eap.c	(revision 2)
@@ -2030,7 +2030,22 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
 /**
+ * eap_get_wps_config - Get a wps configuration
+ * @sm: Pointer to EAP state machine allocated with eap_sm_init()
+ * Returns: Pointer to wps config data or %NULL if not found
+ */
+const struct wps_config *eap_get_wps_config(struct eap_sm *sm)
+{
+	return sm->eapol_cb->get_wps_config(sm->eapol_ctx);
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
+/**
  * eap_set_force_disabled - Set force_disabled flag
  * @sm: Pointer to EAP state machine allocated with eap_sm_init()
  * @disabled: 1 = EAP disabled, 0 = EAP enabled
Index: eap.h
===================================================================
--- eap.h	(revision 1)
+++ eap.h	(revision 2)
@@ -23,6 +23,12 @@
 struct wpa_ssid;
 struct wpa_config_blob;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+struct wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 struct eap_method_type {
 	int vendor;
 	u32 method;
@@ -200,7 +206,18 @@
 	const struct wpa_config_blob * (*get_config_blob)(void *ctx,
 							  const char *name);
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
 	/**
+	 * get_wps_config - Get a wps configuration
+	 * @ctx: eapol_ctx from eap_sm_init() call
+	 * Returns: Pointer to blob data or %NULL if not found
+	 */
+	const struct wps_config * (*get_wps_config)(void *sm);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+	/**
 	 * notify_pending - Notify that a pending request can be retried
 	 * @ctx: eapol_ctx from eap_sm_init() call
 	 *
Index: intel_ie_wps.c
===================================================================
--- intel_ie_wps.c	(revision 0)
+++ intel_ie_wps.c	(revision 2)
@@ -0,0 +1,259 @@
+/*
+ * wpa_supplicant / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WPS and COPYING for more details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <time.h>
+#include <errno.h>
+
+#include "common.h"
+#include "driver.h"
+#include "driver_wext.h"
+#include "eloop.h"
+#include "wpa_supplicant.h"
+#include "wpa.h"
+#include "wpa_supplicant_i.h"
+#include "wireless_copy.h"
+
+#include "intel_udplib.h"
+#include "intel_ie_wps.h"
+
+static WPS_IE_DATA * g_wps_ie_data;
+
+static void wps_ie_read_callback(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	WPS_IE_DATA * data = eloop_ctx;
+	WPS_IE_COMMAND_DATA * cmdData;
+	char readBuf[WPS_WLAN_DATA_MAX_LENGTH];
+	int recvBytes;
+	struct sockaddr_in from;
+	u8 * bufPtr;
+	int retval;
+	char ssid[36];
+
+	wpa_printf(MSG_INFO, "WPS_IE: Entered wps_ie_read_callback. "
+			"sock = %d", sock);
+
+	recvBytes = udp_read(data->udpFdCom, readBuf,
+			WPS_WLAN_DATA_MAX_LENGTH, &from);
+
+	if (recvBytes == -1)
+	{
+		wpa_printf(MSG_ERROR, "WPS_IE: Reading Command message "
+				"from upper layer failed");
+		return;
+	}
+
+	cmdData = (WPS_IE_COMMAND_DATA *) readBuf;
+
+	if (cmdData->type == WPS_IE_TYPE_SET_PROBE_REQUEST_IE)
+	{
+		wpa_printf(MSG_INFO, "WPS_IE: SET_PROBE_REQUEST_IE from upper layer");
+		bufPtr = (u8 *) &(cmdData->data[0]);
+		wpa_drv_set_wps_probe_request_ie(data->wpa_s, bufPtr, cmdData->length);
+	}
+	else if (cmdData->type == WPS_IE_TYPE_SEND_BEACONS_UP)
+	{
+		wpa_printf(MSG_INFO, "WPS_IE: SEND_BEACONS_UP from upper layer");
+		bufPtr = (u8 *) &(cmdData->data[0]);
+		if (bufPtr[0] == 1)
+		{
+			g_wps_ie_data->sendUp = 1;
+			wpa_printf(MSG_INFO, "WPS_IE: Activate = 1\n");
+			retval = wpa_drv_start_receive_beacons(data->wpa_s);
+			printf("\n\n*** wpa_drv_start_receive_beacons return val = %d\n\n", retval);
+		}
+		else
+		{
+			g_wps_ie_data->sendUp = 0;
+			wpa_printf(MSG_INFO, "WPS_IE: Activate = 0\n");
+			retval = wpa_drv_stop_receive_beacons(data->wpa_s);
+			// printf("wpa_drv_stop_receive_beacons return val = %d\n", retval);
+		}
+	}
+	else if (cmdData->type == WPS_IE_TYPE_SEND_PR_RESPS_UP)
+	{
+		wpa_printf(MSG_INFO, "WPS_IE: SEND_PR_RESPS_UP from upper layer");
+		bufPtr = (u8 *) &(cmdData->data[0]);
+		if (bufPtr[0] == 1)
+		{
+			wpa_printf(MSG_INFO, "WPS_IE: Activate = 1\n");
+			retval = wpa_drv_start_receive_pr_resps(data->wpa_s);
+			printf("wpa_drv_start_receive_pr_resps return val = %d\n", retval);
+		}
+		else
+		{
+			wpa_printf(MSG_INFO, "WPS_IE: Activate = 0\n");
+			retval = wpa_drv_stop_receive_pr_resps(data->wpa_s);
+			printf("wpa_drv_stop_receive_pr_resps return val = %d\n", retval);
+		}
+	}
+	else if (cmdData->type == WPS_IE_TYPE_SEND_PROBE_REQUEST)
+	{
+		wpa_printf(MSG_INFO, "WPS_IE: SEND_PROBE_REQUEST from upper layer");
+		bufPtr = (u8 *) &(cmdData->data[0]);
+		strcpy(ssid, (char *) bufPtr);
+
+		wpa_printf(MSG_INFO, "WPS_IE: SSID received from up = %s\n", ssid);
+		retval = wpa_drv_scan(data->wpa_s, (const u8 *)ssid, os_strlen(ssid));
+		printf("wpa_drv_scan return val = %d\n", retval);
+	}
+	else
+	{
+		wpa_printf(MSG_ERROR, "WPS_IE: Wrong command type from upper layer");
+		return;
+	}
+	return;
+}
+
+static void
+wps_handle_frames(void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len)
+{
+	u8 newbuf[256];
+	int newlen;
+	WPS_IE_COMMAND_DATA * cmdData;
+	struct sockaddr_in to;
+	u8 frameType = 0;
+
+
+	cmdData = (WPS_IE_COMMAND_DATA *) newbuf;
+	newlen = 0;
+	if (wpa_drv_process_frame(g_wps_ie_data->wpa_s, ctx, src_addr, 
+				buf, len, newbuf + sizeof(WPS_IE_COMMAND_DATA), &newlen, 
+				&frameType) < 0)
+	{
+		wpa_printf(MSG_ERROR, "process_frame was not called or successful\n");
+		return;
+	}
+
+//	printf("Process frames done; newlen = %d, frameType = %d\n", 
+//			newlen, frameType);
+
+	if (frameType != 1 && frameType != 3)
+	{
+		wpa_printf(MSG_ERROR, "Not a Beacon or Probe-Response\n");
+		return;
+	}
+
+	if (newlen)
+	{
+		if (frameType == 1) {
+			if (! g_wps_ie_data->sendUp) 
+				return;
+			if ( (g_wps_ie_data->sendCounter % 50) != 0) {
+				g_wps_ie_data->sendCounter++;
+				return; // only send up 1 in 50 beacons
+			}
+			g_wps_ie_data->sendCounter++;
+			cmdData->type = WPS_IE_TYPE_BEACON_IE_DATA;
+			wpa_printf(MSG_INFO, "\n\nWPS_IE: sending up WPS beacon\\nn");
+		}
+		else {
+			cmdData->type = WPS_IE_TYPE_PROBE_RESPONSE_IE_DATA;
+			wpa_printf(MSG_INFO, "WPS_IE: sending up WPS probe response\n");
+		}
+
+		cmdData->length = newlen;
+
+		to.sin_addr.s_addr = inet_addr(WPS_WLAN_UDP_ADDR);
+		to.sin_family = AF_INET;
+		to.sin_port = host_to_be16(WPS_WLAN_UDP_PORT);
+
+		newlen += sizeof(WPS_IE_COMMAND_DATA);
+
+		if (udp_write(g_wps_ie_data->udpFdCom, (char *) newbuf, 
+				newlen, &to) < newlen)
+		{
+			wpa_printf(MSG_INFO, "WPS_IE: Sending Beacon Data to "
+					"upper Layer failed");
+			return;
+		}
+
+		// printf("udp_write done\n");
+	}
+}
+
+
+int wps_ie_init(struct wpa_supplicant *wpa_s)
+{
+	struct sockaddr_in to;
+	char sendBuf[5];
+
+	wpa_printf(MSG_INFO, "\n\n******WPS_IE: In wps_ie_init\n\n");
+	
+	g_wps_ie_data = malloc(sizeof(WPS_IE_DATA));
+	
+	if (g_wps_ie_data == NULL)
+	{
+		return -1;
+	}
+
+	os_memset(g_wps_ie_data, 0, sizeof(WPS_IE_DATA));
+
+	g_wps_ie_data->wpa_s = wpa_s;
+	g_wps_ie_data->sendUp = 0;
+	g_wps_ie_data->sendCounter = 0;
+	g_wps_ie_data->udpFdCom = udp_open();
+
+	eloop_register_read_sock(g_wps_ie_data->udpFdCom, wps_ie_read_callback,
+				 g_wps_ie_data, NULL);
+	/* Send a start packet */
+	strcpy(sendBuf, "PORT");
+	to.sin_addr.s_addr = inet_addr(WPS_WLAN_UDP_ADDR);
+	to.sin_family = AF_INET;
+	to.sin_port = host_to_be16(WPS_WLAN_UDP_PORT);
+
+	if (udp_write(g_wps_ie_data->udpFdCom, sendBuf, 5, &to) < 5)
+	{
+		wpa_printf(MSG_ERROR, "WPS_IE: Sending Port message to "
+				"upper Layer failed");
+		return -1;
+	}
+
+	// register to get l2_packets
+	wpa_drv_init_l2_packet(wpa_s, wps_handle_frames);
+
+	return 0;
+}
+
+int wps_ie_deinit(struct wpa_supplicant *wpa_s)
+{
+	wpa_drv_deinit_l2_packet(wpa_s);
+
+	if ( g_wps_ie_data )
+	{
+		if (g_wps_ie_data->udpFdCom != -1)
+		{
+			eloop_unregister_read_sock(g_wps_ie_data->udpFdCom);
+			udp_close(g_wps_ie_data->udpFdCom);
+			g_wps_ie_data->udpFdCom = -1;
+		}
+
+		g_wps_ie_data->wpa_s = NULL;
+
+		free(g_wps_ie_data);
+		g_wps_ie_data = NULL;
+	}
+
+	return 0;
+}
+
Index: wps_opt_nfc.c
===================================================================
--- wps_opt_nfc.c	(revision 0)
+++ wps_opt_nfc.c	(revision 2)
@@ -0,0 +1,1165 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_nfc.c
+//  Description: EAP-WPS NFC option source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "wpa_supplicant.h"
+#include "wpa.h"
+#include "eloop.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wpa_ctrl.h"
+#include "state_machine.h"
+#include "wps_parser.h"
+#include "wps_opt_nfc.h"
+#include "eap_wps.h"
+#include "WpsNfcType.h"
+#include "WpsNfc.h"
+#ifdef WPS_OPT_UPNP
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+
+#define STATE_MACHINE_DATA struct wps_opt_nfc_sm
+#define STATE_MACHINE_DEBUG_PREFIX "OPT_NFC"
+
+#ifndef WPSNFCLIB_VERSION
+#ifndef LIB_VERSION
+#define WPSNFCLIB_VERSION 0
+#define LIB_VERSION(a, b, c) 1
+#else
+#define WPSNFCLIB_VERSION LIB_VERSION(1, 0, 0) /* 1.0.0 */
+#endif /* LIB_VERSION */
+#endif /* WPSNFCLIB_VERSION */
+
+/**
+ * struct wps_opt_nfc_sm - Internal data for NFC state machines
+ */
+
+typedef enum {
+	OPT_NFC_INACTIVE = 0,
+	OPT_NFC_IDLE,
+	OPT_NFC_SCANNING,
+	OPT_NFC_SCAN_TIMEOUT,
+	OPT_NFC_FOUND_TOKEN,
+} opt_nfc_states;
+
+struct wps_opt_nfc_sm {
+ 	opt_nfc_states OPT_NFC_state;
+	Boolean changed;
+ 	struct wps_opt_nfc_sm_ctx *ctx;
+	const char *nfcname;
+	Boolean initialized;
+	Boolean isOpenedDevice;
+	Boolean existing;
+	Boolean enablePort;
+#define NFC_LOOP_PERIOD_SEC		1 /* [sec] */
+#define NFC_LOOP_PERIOD_USEC	0 /* [usec] */
+#define SCAN_TIMEOUT_SEC		30 /* [sec] */
+#define SCAN_TIMEOUT_USEC		0 /* [usec] */
+	struct os_time scanTimeout;
+	Boolean foundToken;
+	Boolean cancelCmd;
+	enum {
+		OPT_NFC_CMD_NONE = 0,
+		OPT_NFC_CMD_READ,
+		OPT_NFC_CMD_WRITE,
+	} OPT_NFC_CMD_state;
+	u8 *readBuf;
+	u32 readBufLen;
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+	int (*readCallback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len);
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+	int (*readCallback)(struct wps_opt_nfc_sm *sm);
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+	void (*readTimeoutCallback)(struct wps_opt_nfc_sm *sm);
+	u8 *writeBuf;
+	u32 writeBufLen;
+	int (*writeCallback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len);
+	void (*writeTimeoutCallback)(struct wps_opt_nfc_sm *sm);
+ };
+
+enum wps_opt_nfc_ctrl_req_type {
+	CTRL_REQ_TYPE_READ_TIMEOUT,
+	CTRL_REQ_TYPE_WRITE_TIMEOUT,
+	CTRL_REQ_TYPE_FAIL_READ,
+	CTRL_REQ_TYPE_COMP_READ,
+	CTRL_REQ_TYPE_COMP_WRITE,
+	CTRL_REQ_TYPE_ADD_NEW_AP
+};
+
+
+static int wps_opt_nfc_sm_is_timeout(struct wps_opt_nfc_sm *sm)
+{
+	struct os_time now;
+	os_get_time(&now);
+
+	if (now.sec > sm->scanTimeout.sec)
+		return 1;
+	else if ((now.sec == sm->scanTimeout.sec) &&
+			 (now.usec >= sm->scanTimeout.usec))
+		return 1;
+	else
+		return 0;
+}
+
+
+static void wps_opt_nfc_sm_request(struct wps_opt_nfc_sm *sm,
+			   enum wps_opt_nfc_ctrl_req_type type,
+			   const char *msg, size_t msglen)
+{
+	char *buf;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (sm == NULL)
+		return;
+
+	switch (type) {
+	case CTRL_REQ_TYPE_READ_TIMEOUT:
+		field = "NFC_READ_TIMEOUT";
+		txt = "Request Timeout";
+		break;
+	case CTRL_REQ_TYPE_WRITE_TIMEOUT:
+		field = "NFC_WRITE_TIMEOUT";
+		txt = "Request Timeout";
+		break;
+	case CTRL_REQ_TYPE_FAIL_READ:
+		field = "NFC_FAIL_READ";
+		txt = "Fail Reading Token";
+		break;
+	case CTRL_REQ_TYPE_COMP_READ:
+		field = "NFC_COMP_READ";
+		txt = "Complete Reading Token";
+		break;
+	case CTRL_REQ_TYPE_COMP_WRITE:
+		field = "NFC_COMP_WRITE";
+		txt = "Complete Writing Token";
+		break;
+	case CTRL_REQ_TYPE_ADD_NEW_AP:
+		field = "NFC_ADD_NEW_AP";
+		txt = "Added New AP";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	wpa_msg(sm->ctx->msg_ctx, MSG_INFO, "%s", buf);
+	free(buf);
+}
+
+static void wps_opt_nfc_port_timer_tick(void *wps_opt_nfc_ctx, void *timeout_ctx)
+{
+	struct wps_opt_nfc_sm *sm = timeout_ctx;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_port_timer_tick, wps_opt_nfc_ctx, sm);
+	wps_opt_nfc_sm_step(sm);
+}
+
+SM_STATE(OPT_NFC, INACTIVE)
+{
+	SM_ENTRY(OPT_NFC, INACTIVE);
+
+	if (sm->isOpenedDevice) {
+		WpsNfcCloseDevice();
+		sm->isOpenedDevice = 0;
+	}
+}
+
+
+SM_STATE(OPT_NFC, IDLE)
+{
+	SM_ENTRY(OPT_NFC, IDLE);
+
+	if (!sm->isOpenedDevice && sm->nfcname &&
+		(WPS_NFCLIB_ERR_SUCCESS ==
+		 WpsNfcOpenDevice((const int8 * const)sm->nfcname)))
+		 sm->isOpenedDevice = 1;
+}
+
+
+SM_STATE(OPT_NFC, SCANNING)
+{
+	uint32 nfcRet;
+	SM_ENTRY(OPT_NFC, SCANNING)
+
+	do {
+		nfcRet = WpsNfcTokenDiscovery();
+		if (WPS_NFCLIB_ERR_SUCCESS == nfcRet) {
+			sm->foundToken = 1;
+			break;
+		}
+
+		if (WPS_NFCLIB_ERR_TARGET_NOT_FOUND != nfcRet)
+			sm->enablePort = 0;
+
+		sm->foundToken = 0;
+	} while (0);
+}
+
+
+SM_STATE(OPT_NFC, SCAN_TIMEOUT)
+{
+	SM_ENTRY(OPT_NFC, SCAN_TIMEOUT);
+	switch (sm->OPT_NFC_CMD_state) {
+	case OPT_NFC_CMD_READ:
+		free(sm->readBuf);
+		sm->readBuf = 0;
+		sm->readBufLen = 0;
+		if (!sm->cancelCmd && sm->readTimeoutCallback)
+			sm->readTimeoutCallback(sm);
+		break;
+	case OPT_NFC_CMD_WRITE:
+		free(sm->writeBuf);
+		sm->writeBuf = 0;
+		sm->writeBufLen = 0;
+		if (!sm->cancelCmd && sm->writeTimeoutCallback)
+			sm->writeTimeoutCallback(sm);
+		break;
+	default:
+		break;
+	}
+	sm->cancelCmd = 0;
+	sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+}
+
+
+SM_STATE(OPT_NFC, FOUND_TOKEN)
+{
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+	uint32 buf_len = 0;
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+
+	SM_ENTRY(OPT_NFC, FOUND_TOKEN)
+
+	switch (sm->OPT_NFC_CMD_state) {
+	case OPT_NFC_CMD_READ:
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+		if (WPS_NFCLIB_ERR_SUCCESS ==
+			WpsNfcReadToken((int8 * const)sm->readBuf,
+				            (uint32 * const)&buf_len)) {
+			sm->readBufLen = buf_len;
+			if (sm->readCallback)
+				sm->readCallback(sm, sm->readBuf, sm->readBufLen);
+			free(sm->readBuf);
+			sm->readBuf = 0;
+			sm->readBufLen = 0;
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		} else
+			sm->foundToken = 0;
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		if (sm->readCallback && sm->readCallback(sm)) {
+			sm->foundToken = 0;
+			break;
+		}
+		free(sm->readBuf);
+		sm->readBuf = 0;
+		sm->readBufLen = 0;
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		break;
+	case OPT_NFC_CMD_WRITE:
+		if (WPS_NFCLIB_ERR_SUCCESS ==
+			WpsNfcWriteToken((int8 * const)sm->writeBuf, sm->writeBufLen)) {
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+			if (sm->writeCallback)
+				sm->writeCallback(sm, sm->writeBuf, sm->writeBufLen);
+			free(sm->writeBuf);
+			sm->writeBuf = 0;
+			sm->writeBufLen = 0;
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		} else
+			sm->foundToken = 0;
+		break;
+	default:
+		if (sm->readBuf) {
+			free(sm->readBuf);
+			sm->readBuf = 0;
+			sm->readBufLen = 0;
+		}
+		if (sm->writeBuf) {
+			free(sm->writeBuf);
+			sm->writeBuf = 0;
+			sm->writeBufLen = 0;
+		}
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		break;
+	}
+}
+
+
+SM_STEP(OPT_NFC)
+{
+	if (sm->existing)
+		sm->enablePort = 0;
+	else if (!sm->initialized) {
+		if (WPS_NFCLIB_ERR_SUCCESS == WpsNfcInit()) {
+			sm->initialized = 1;
+			sm->isOpenedDevice = 0;
+		}
+	}
+
+	if (!sm->initialized)
+		return;
+
+	do {
+		sm->changed = 0;
+
+		if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state) {
+			if (sm->cancelCmd || wps_opt_nfc_sm_is_timeout(sm))
+				SM_ENTER_GLOBAL(OPT_NFC, SCAN_TIMEOUT);
+		}
+
+		switch(sm->OPT_NFC_state) {
+		case OPT_NFC_INACTIVE:
+			if (sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		case OPT_NFC_IDLE:
+			if (!sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			else if (sm->OPT_NFC_CMD_state != OPT_NFC_CMD_NONE) {
+				SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+				if (OPT_NFC_SCANNING == sm->OPT_NFC_state)
+					sm->changed = 0;
+			}
+			break;
+		case OPT_NFC_SCANNING:
+			if (!sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			else {
+				if (sm->foundToken)
+					SM_ENTER_GLOBAL(OPT_NFC, FOUND_TOKEN);
+				else if (OPT_NFC_CMD_NONE == sm->OPT_NFC_CMD_state)
+					SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+				else
+					SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+			}
+			break;
+		case OPT_NFC_SCAN_TIMEOUT:
+			SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		case OPT_NFC_FOUND_TOKEN:
+			wpa_printf(MSG_DEBUG, "WPS_OPT_NFC: Found Token");
+			if (!sm->enablePort) {
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+				break;
+			} else if (!sm->foundToken)
+				SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+			else
+				SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		default:
+			sm->enablePort = 0;
+			SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			break;
+		}
+	} while (sm->changed);
+
+	if ((sm->existing) && (sm->initialized)) {
+			WpsNfcDeinit();
+			sm->initialized = 0;
+			sm->existing = 0;
+	}
+}
+
+
+void wps_opt_nfc_sm_step(struct wps_opt_nfc_sm *sm)
+{
+	SM_STEP_RUN(OPT_NFC);
+}
+
+void wps_opt_nfc_sm_set_ifname(struct wps_opt_nfc_sm *sm, const char *nfcname)
+{
+	if (sm) {
+		sm->nfcname = nfcname;
+	}
+}
+
+struct wps_opt_nfc_sm *wps_opt_nfc_sm_init(struct wps_opt_nfc_sm_ctx *ctx)
+{
+	struct wps_opt_nfc_sm *sm;
+
+	sm = wpa_zalloc(sizeof(*sm));
+	if (sm == NULL)
+		return NULL;
+	sm->ctx = ctx;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_port_timer_tick, NULL, sm);
+
+	return sm;
+}
+
+void wps_opt_nfc_sm_deinit(struct wps_opt_nfc_sm *sm)
+{
+	if (sm == NULL)
+		return;
+	eloop_cancel_timeout(wps_opt_nfc_port_timer_tick, NULL, sm);
+	sm->existing = 1;
+	wps_opt_nfc_sm_step(sm);
+	free(sm->ctx);
+	free(sm);
+}
+
+
+static void wps_opt_nfc_sm_command(void *wps_opt_nfc_ctx, void *timeout_ctx)
+{
+	struct wps_opt_nfc_sm *sm = (struct wps_opt_nfc_sm *)wps_opt_nfc_ctx;
+	struct wps_opt_nfc_sm *cmd = (struct wps_opt_nfc_sm *)timeout_ctx;
+
+	if ((OPT_NFC_INACTIVE == sm->OPT_NFC_state) ||
+		(OPT_NFC_IDLE == sm->OPT_NFC_state)) {
+		switch (cmd->OPT_NFC_CMD_state) {
+		case OPT_NFC_CMD_READ:
+			sm->readBuf = cmd->readBuf;
+			sm->readBufLen = cmd->readBufLen;
+			sm->readCallback = cmd->readCallback;
+			sm->readTimeoutCallback = cmd->readTimeoutCallback;
+			break;
+		case OPT_NFC_CMD_WRITE:
+			sm->writeBuf = cmd->writeBuf;
+			sm->writeBufLen = cmd->writeBufLen;
+			sm->writeCallback = cmd->writeCallback;
+			sm->writeTimeoutCallback = cmd->writeTimeoutCallback;
+			break;
+		default:
+			break;
+		}
+		os_get_time(&sm->scanTimeout);
+		sm->scanTimeout.sec += SCAN_TIMEOUT_SEC;
+		sm->scanTimeout.usec += SCAN_TIMEOUT_USEC;
+		sm->OPT_NFC_CMD_state = cmd->OPT_NFC_CMD_state;
+
+		free(cmd);
+		if (!sm->enablePort)
+			sm->enablePort = 1;
+	} else
+		eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+}
+
+
+static int wps_opt_nfc_sm_read_command(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+		int (*callback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len),
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		int (*callback)(struct wps_opt_nfc_sm *sm),
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		void (*timeout)(struct wps_opt_nfc_sm *sm))
+{
+	struct wps_opt_nfc_sm *cmd;
+
+	if (sm->cancelCmd)
+		sm->cancelCmd = 0;
+
+	cmd = (struct wps_opt_nfc_sm *)calloc(sizeof(struct wps_opt_nfc_sm), 1);
+	if (!cmd)
+		return -1;
+
+	cmd->readBuf = buf;
+	cmd->readBufLen = len;
+	cmd->OPT_NFC_CMD_state = OPT_NFC_CMD_READ;
+	cmd->readCallback = callback;
+	cmd->readTimeoutCallback = timeout;
+
+	if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state)
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+
+	return 0;
+}
+
+
+static int wps_opt_nfc_sm_write_command(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len,
+		int (*callback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len),
+		void (*timeout)(struct wps_opt_nfc_sm *sm))
+{
+	struct wps_opt_nfc_sm *cmd;
+
+	if (sm->cancelCmd)
+		sm->cancelCmd = 0;
+
+	cmd = (struct wps_opt_nfc_sm *)calloc(sizeof(struct wps_opt_nfc_sm), 1);
+	if (!cmd)
+		return -1;
+
+	cmd->writeBuf = buf;
+	cmd->writeBufLen = len;
+	cmd->OPT_NFC_CMD_state = OPT_NFC_CMD_WRITE;
+	cmd->writeCallback = callback;
+	cmd->writeTimeoutCallback = timeout;
+
+	if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state)
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+
+	return 0;
+}
+
+
+static int wps_opt_nfc_read_password_callback(struct wps_opt_nfc_sm *sm, u8 *buf, size_t len)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	struct wps_config *conf;
+	u8 version;
+	u8 *oobdevpwd = 0;
+	u16 length;
+	u8 *pwd;
+	size_t pwd_len;
+	u8 dev_pwd[SIZE_64_BYTES + 1];
+	char msg[32];
+#ifdef WPS_OPT_UPNP
+	struct wps_opt_upnp_sm *upnp_sm;
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+		if (!conf)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* OOB Device Password */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, NULL, &length);
+		if (!length)
+			break;
+		oobdevpwd = (u8 *)calloc(1, length);
+		if (!oobdevpwd)
+			break;
+		if(wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, oobdevpwd, &length))
+			break;
+
+		if (length < 20 + 2 + 6)
+			break;
+
+		os_memcpy(conf->pub_key, oobdevpwd, 20);
+		conf->set_pub_key = 1;
+		conf->dev_pwd_id = WPA_GET_BE16(oobdevpwd + 20);
+		pwd = oobdevpwd + 22;
+		pwd_len = length - 22;
+		conf->dev_pwd_len = wpa_snprintf_hex_uppercase((char *)dev_pwd, sizeof(dev_pwd), pwd, pwd_len);
+		os_memcpy(conf->dev_pwd, dev_pwd, sizeof(conf->dev_pwd));
+
+#ifdef WPS_OPT_UPNP
+		upnp_sm = sm->ctx->get_upnp_sm(sm->ctx->ctx);
+		if (upnp_sm && conf->cur_upnp_device &&
+			conf->reg_mode == WPS_REGMODE_REGISTER_STA) {
+			(void)wps_opt_upnp_set_selected_registrar(upnp_sm,
+													conf->cur_upnp_device, 1);
+		}
+#endif /* WPS_OPT_UPNP */
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (oobdevpwd)
+		free(oobdevpwd);
+
+	os_snprintf(msg, sizeof(msg), "Password Token:%d", conf->nwid_trying_wps);
+	if (ret) {
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_FAIL_READ, msg, os_strlen(msg));
+	} else {
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_READ, msg, os_strlen(msg));
+	}
+
+	return ret;
+}
+
+#if WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1)
+static int wps_opt_nfc_read_password_callback2(struct wps_opt_nfc_sm *sm)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u16 length;
+	int8 *buf = 0;
+	uint32 len = 0;
+	uint32 num = 0;
+	uint32 i;
+
+	do {
+		if (WPS_NFCLIB_ERR_SUCCESS != WpsNfcReadTokenMessage(&num))
+			break;
+
+		do {
+			if (!num)
+				break;
+
+			for (i = 0; (i < num) && ret; i++) {
+				len = 0;
+				if (WPS_NFCLIB_ERR_SUCCESS !=
+					WpsNfcGetRecordFromMessage(i, &buf, &len))
+					continue;
+
+				do {
+					if (wps_create_wps_data(&wps))
+						break;
+
+					if(wps_parse_wps_data((uint8 *)buf, len, wps))
+						break;
+
+					/* Version */
+					if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+						break;
+					if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+						break;
+
+					/* OOB Device Password */
+					length = 0;
+					(void)wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, NULL, &length);
+					if (!length)
+						break;
+
+					ret = 0;
+				} while (0);
+
+				(void)wps_destroy_wps_data(&wps);
+
+				if (ret) {
+					if (buf) os_free(buf);
+					buf = 0;
+				}
+			}
+		} while (0);
+		(void)wps_opt_nfc_read_password_callback(sm, (uint8 *)buf, len);
+		ret = 0;
+	} while (0);
+
+	if (buf) os_free(buf);
+
+	return ret;
+}
+#endif /* WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1) */
+
+
+static void wps_opt_nfc_read_password_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	struct wps_config *conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+	os_snprintf(msg, sizeof(msg), "Password Token:%d", conf->nwid_trying_wps);
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_READ_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_write_password_callback(struct wps_opt_nfc_sm *sm, u8 *buf, size_t len)
+{
+	char msg[32];
+	struct wps_config *conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+	os_snprintf(msg, sizeof(msg), "Password Token:%d", conf->nwid_trying_wps);
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_WRITE, msg, os_strlen(msg));
+	return 0;
+}
+
+
+static void wps_opt_nfc_write_password_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	struct wps_config *conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+	os_snprintf(msg, sizeof(msg), "Password Token:%d", conf->nwid_trying_wps);
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_WRITE_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_read_config_callback(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 *credential = 0;
+	u8 nwIdx;
+	u16 length;
+	int id = -1;
+
+	do {
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Creadential */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, NULL, &length);
+		if (!length)
+			break;
+		credential = (u8 *)calloc(1, length);
+		if (!credential)
+			break;
+		if(wps_get_value(wps, WPS_TYPE_CREDENTIAL, credential, &length))
+			break;
+
+		(void)wps_destroy_wps_data(&wps);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(credential, length, wps))
+			break;
+
+		/* Network Index */
+		if(!wps_get_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, 0))
+			/** Ignore Network Index **/
+			(void)wps_remove_value(wps, WPS_TYPE_NW_INDEX);
+
+		if (credential) {
+			free(credential);
+			credential = 0;
+		}
+		length = 0;
+
+		if (wps_write_wps_data(wps, &credential, &length))
+			break;
+
+		if (-1 == (id = wps_set_ssid_configuration(sm->ctx->ctx, credential, length)))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (credential)
+		free(credential);
+
+	if (ret) {
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_ADD_NEW_AP, "-1", 2);
+	} else if (0 <= id) {
+		char msg[8];
+		os_snprintf(msg, 4, "%d", id);
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_ADD_NEW_AP, msg, os_strlen(msg));
+	}
+
+	return ret;
+}
+
+
+#if WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1)
+static int wps_opt_nfc_read_config_callback2(struct wps_opt_nfc_sm *sm)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u16 length;
+	int8 *buf = 0;
+	uint32 len = 0;
+	uint32 num = 0;
+	uint32 i;
+
+	do {
+		if (WPS_NFCLIB_ERR_SUCCESS != WpsNfcReadTokenMessage(&num))
+			break;
+
+		do {
+			if (!num)
+				break;
+
+			for (i = 0; (i < num) && ret; i++) {
+				len = 0;
+				if (WPS_NFCLIB_ERR_SUCCESS !=
+					WpsNfcGetRecordFromMessage(i, &buf, &len))
+					continue;
+
+				do {
+					if (wps_create_wps_data(&wps))
+						break;
+
+					if(wps_parse_wps_data((uint8 *)buf, len, wps))
+						break;
+
+					/* Version */
+					if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+						break;
+					if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+						break;
+
+					/* Creadential */
+					length = 0;
+					(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, NULL, &length);
+					if (!length)
+						break;
+
+					ret = 0;
+				} while (0);
+
+				(void)wps_destroy_wps_data(&wps);
+
+				if (ret) {
+					if (buf) os_free(buf);
+					buf = 0;
+				}
+			}
+		} while (0);
+		(void)wps_opt_nfc_read_config_callback(sm, (uint8 *)buf, len);
+		ret = 0;
+	} while (0);
+
+	if (buf) os_free(buf);
+
+	return ret;
+}
+#endif /* WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1) */
+
+
+static void wps_opt_nfc_read_config_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char *msg = "Config Token";
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_READ_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_write_config_callback(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len)
+{
+	char msg[32];
+	struct wps_config *conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+	os_snprintf(msg, sizeof(msg), "Config Token:%d", conf->nwid_trying_wps);
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_WRITE, msg, os_strlen(msg));
+	return 0;
+}
+
+
+static void wps_opt_nfc_write_config_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	struct wps_config *conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+	os_snprintf(msg, sizeof(msg), "Config Token:%d", conf->nwid_trying_wps);
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_WRITE_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+int wps_opt_nfc_cancel_nfc_comand(struct wps_opt_nfc_sm *sm)
+{
+	sm->cancelCmd = 1;
+	return 0;
+}
+
+
+static int wps_opt_nfc_generate_oob_device_password(
+	struct wps_opt_nfc_sm *sm, u8 *hash,
+	u16 *dev_pwd_id, u8 *pwd, int pwd_len)
+{
+	int ret = -1;
+	struct wpa_config *conf;
+	struct wps_config *wps = 0;
+	u8 dev_pwd[SIZE_64_BYTES + 1];
+	int dev_pwd_len;
+	u8 tmp[SIZE_256_BITS];
+
+	do {
+		if (!hash || !dev_pwd_id || !pwd )
+			break;
+
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf && !conf->wps)
+			break;
+		wps = conf->wps;
+		if ((16 > pwd_len) || ((pwd_len * 2) > sizeof(wps->dev_pwd)))
+			break;
+
+		if (eap_wps_generate_public_key(&wps->dh_secret, wps->pub_key))
+			break;
+		wps->set_pub_key = 1;
+
+		if (eap_wps_generate_sha256hash(wps->pub_key, sizeof(wps->pub_key), tmp))
+			break;
+		os_memcpy(hash, tmp, SIZE_20_BYTES);
+
+		if (eap_wps_generate_device_password_id(dev_pwd_id))
+			break;
+
+		if (eap_wps_generate_device_password(pwd, pwd_len))
+			break;
+
+		dev_pwd_len = wpa_snprintf_hex_uppercase((char *)dev_pwd, sizeof(dev_pwd), pwd, pwd_len);
+		if (dev_pwd_len != (pwd_len * 2))
+			break;
+
+		wps->dev_pwd_id = *dev_pwd_id;
+		os_memcpy(wps->dev_pwd, dev_pwd, dev_pwd_len);
+		wps->dev_pwd_len = dev_pwd_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (wps) {
+			if (wps->dh_secret)
+				eap_wps_free_dh(&wps->dh_secret);
+			wps->set_pub_key = 0;
+
+			wps->dev_pwd_len = 0;
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+		}
+	}
+
+	return ret;
+}
+
+
+u16 wps_opt_nfc_read_password_token(struct wps_opt_nfc_sm *sm, int nwIdx)
+{
+#define DEFAULT_READ_BUF_SIZE 0x800
+	int ret = -1;
+	struct wpa_config *conf;
+	u8 * buf = 0;
+	size_t len;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		buf = (u8 *)calloc(1, DEFAULT_READ_BUF_SIZE);
+		if (!buf)
+			break;
+		len = DEFAULT_READ_BUF_SIZE;
+		if (wps_opt_nfc_sm_read_command(sm, buf, len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+										wps_opt_nfc_read_password_callback,
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_password_callback2,
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_password_timeout_callback))
+			break;
+
+		conf->wps->nwid_trying_wps = nwIdx;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && buf) {
+		free(buf);
+		buf = 0;
+		len = 0;
+	}
+
+	return ret;
+#undef DEFAULT_READ_BUF_SIZE
+}
+
+
+int wps_opt_nfc_write_password_token(struct wps_opt_nfc_sm *sm, int nwIdx)
+{
+	int ret = -1;
+	struct wpa_config *conf;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 pub_key_hash[20];
+	u16 dev_pwd_id;
+	u8 dev_pwd[32];
+	u8 oob_dev_pwd[sizeof(pub_key_hash) + sizeof(dev_pwd_id) + sizeof(dev_pwd)];
+	u8 *tmp;
+	u8 *buf = 0;
+	u16 buf_len;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_opt_nfc_generate_oob_device_password(sm, pub_key_hash,
+					&dev_pwd_id, dev_pwd, sizeof(dev_pwd)))
+			break;
+		tmp = oob_dev_pwd;
+		os_memcpy(tmp, pub_key_hash, sizeof(pub_key_hash));
+		tmp += sizeof(pub_key_hash);
+		WPA_PUT_BE16(tmp, dev_pwd_id);
+		tmp += sizeof(dev_pwd_id);
+		os_memcpy(tmp, dev_pwd, sizeof(dev_pwd));
+		tmp += sizeof(dev_pwd);
+
+		/* Version */
+		if (conf->wps && conf->wps->version)
+			version = conf->wps->version;
+		else
+			version = WPS_VERSION;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+
+		/* OOB Device Password */
+		if (wps_set_value(wps, WPS_TYPE_OOB_DEV_PWD, oob_dev_pwd, sizeof(oob_dev_pwd)))
+			break;
+
+		if(wps_write_wps_data(wps, &buf, &buf_len))
+			break;
+
+		if (wps_opt_nfc_sm_write_command(sm, buf, buf_len,
+										 wps_opt_nfc_write_password_callback,
+										 wps_opt_nfc_write_password_timeout_callback))
+			break;
+
+		conf->wps->nwid_trying_wps = nwIdx;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (ret && buf) {
+		free(buf);
+		buf = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_opt_nfc_read_config_token(struct wps_opt_nfc_sm *sm)
+{
+#define DEFAULT_READ_BUF_SIZE 0x800
+	int ret = -1;
+	u8 * buf = 0;
+	size_t len;
+
+	do {
+		buf = (u8 *)calloc(1, DEFAULT_READ_BUF_SIZE);
+		if (!buf)
+			break;
+		len = DEFAULT_READ_BUF_SIZE;
+		if (wps_opt_nfc_sm_read_command(sm, buf, len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+										wps_opt_nfc_read_config_callback,
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_config_callback2,
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_config_timeout_callback))
+			break;
+		ret = 0;
+	} while (0);
+
+	if (ret && buf) {
+		free(buf);
+		buf = 0;
+		len = 0;
+	}
+
+	return ret;
+#undef DEFAULT_READ_BUF_SIZE
+}
+
+
+int wps_opt_nfc_write_config_token(struct wps_opt_nfc_sm *sm, int nwIdx)
+{
+	int ret = -1;
+	struct wpa_config *conf;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 *buf = 0;
+	size_t buf_len;
+	u16 length;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		/* Make Creadential Attribute */
+		if(wps_get_ssid_configuration(sm->ctx->ctx, nwIdx, &buf, &buf_len))
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (conf->wps && conf->wps->version)
+			version = conf->wps->version;
+		else
+			version = WPS_VERSION;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+
+		/* Credential */
+		if (wps_set_value(wps, WPS_TYPE_CREDENTIAL, buf, (u16)buf_len))
+			break;
+
+		free(buf);
+		buf = 0;
+		length = 0;
+		if(wps_write_wps_data(wps, &buf, &length))
+			break;
+
+		if (wps_opt_nfc_sm_write_command(sm, buf, length,
+										 wps_opt_nfc_write_config_callback,
+										 wps_opt_nfc_write_config_timeout_callback))
+			break;
+
+		conf->wps->nwid_trying_wps = nwIdx;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (ret && buf) {
+		free(buf);
+		buf = 0;
+	}
+
+	return ret;
+}
+
+
Index: main.c
===================================================================
--- main.c	(revision 1)
+++ main.c	(revision 2)
@@ -22,6 +22,9 @@
 
 
 extern const char *wpa_supplicant_version;
+#ifdef MODIFIED_BY_SONY
+extern const char *modified_by_sony_version;
+#endif /* MODIFIED_BY_SONY */
 extern const char *wpa_supplicant_license;
 #ifndef CONFIG_NO_STDOUT_DEBUG
 extern const char *wpa_supplicant_full_license1;
@@ -79,6 +82,9 @@
 	       "  -v = show version\n"
 	       "  -w = wait for interface to be added, if needed\n"
 	       "  -W = wait for a control interface monitor before starting\n"
+#ifdef WPS_OPT_NFC
+	       "  -n = nfc interface name\n"
+#endif /* WPS_OPT_NFC */
 	       "  -N = start describing new interface\n");
 
 	printf("example:\n"
@@ -129,6 +135,16 @@
 	struct wpa_params params;
 	struct wpa_global *global;
 
+#ifdef MODIFIED_BY_SONY
+#ifndef CONFIG_NATIVE_WINDOWS
+	setvbuf(stdout, 0, _IOLBF, 0);
+	setvbuf(stderr, 0, _IOLBF, 0);
+#else /* CONFIG_NATIVE_WINDOWS */
+	setbuf(stdout, 0);
+	setbuf(stderr, 0);
+#endif /* CONFIG_NATIVE_WINDOWS */
+#endif /* MODIFIED_BY_SONY */
+
 	if (os_program_init())
 		return -1;
 
@@ -143,7 +159,11 @@
 	wpa_supplicant_fd_workaround();
 
 	for (;;) {
+#ifndef WPS_OPT_NFC
 		c = getopt(argc, argv, "b:Bc:C:D:dg:hi:KLNp:P:qtuvwW");
+#else /* WPS_OPT_NFC */
+		c = getopt(argc, argv, "b:Bc:C:D:dg:hi:KLn:Np:P:qtuvwW");
+#endif /* WPS_OPT_NFC */
 		if (c < 0)
 			break;
 		switch (c) {
@@ -209,6 +229,9 @@
 #endif /* CONFIG_CTRL_IFACE_DBUS */
 		case 'v':
 			printf("%s\n", wpa_supplicant_version);
+#ifdef MODIFIED_BY_SONY
+			printf("%s\n", modified_by_sony_version);
+#endif /* MODIFIED_BY_SONY */
 			exitcode = 0;
 			goto out;
 		case 'w':
@@ -217,6 +240,11 @@
 		case 'W':
 			params.wait_for_monitor++;
 			break;
+#ifdef WPS_OPT_NFC
+		case 'n':
+			iface->nfcname = optarg;
+			break;
+#endif /* WPS_OPT_NFC */
 		case 'N':
 			iface_count++;
 			iface = os_realloc(ifaces, iface_count *
Index: wps_parser.c
===================================================================
--- wps_parser.c	(revision 0)
+++ wps_parser.c	(revision 2)
@@ -0,0 +1,711 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_parser.c
+//  Description: EAP-WPS parser source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "wps_config.h"
+#include "wps_parser.h"
+
+#define GENERIC_INFO_ELEM 0xdd
+#define RSN_INFO_ELEM 0x30
+
+#define WPS_LENTYPE_FIX		0
+#define WPS_LENTYPE_MAX		1
+#define WPS_LENTYPE_MIN		2
+
+struct wps_tlv {
+	u16		type;
+	u16		length;
+	u16		value_type;
+	union _value {
+		Boolean	bool_;
+		u8		u8_;
+		u16		u16_;
+		u32		u32_;
+		u8 *	ptr_;
+	} value;
+};
+
+struct wps_tlv_set {
+	u16		type;
+	u16		length;
+	u16		length_type;
+	u16		value_type;
+};
+
+const struct wps_tlv_set wps_tlv_sets [] = {
+	{WPS_TYPE_AP_CHANNEL,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ASSOC_STATE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTH_TYPE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTH_TYPE_FLAGS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTHENTICATOR,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONFIG_METHODS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_CONFIG_ERROR,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_CONF_URL4,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONF_URL6,			76,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONN_TYPE,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_CONN_TYPE_FLAGS,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_CREDENTIAL,			0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_DEVICE_NAME,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_DEVICE_PWD_ID,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_E_HASH1,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_HASH2,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_SNONCE1,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_SNONCE2,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_ENCR_SETTINGS,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_ENCR_TYPE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ENCR_TYPE_FLAGS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ENROLLEE_NONCE,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_FEATURE_ID,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_IDENTITY,				80,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_IDENTITY_PROOF,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_WRAP_AUTH,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_IDENTIFIER,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MAC_ADDR,				6,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MANUFACTURER,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MSG_TYPE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_MODEL_NAME,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MODEL_NUMBER,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NW_INDEX,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_NW_KEY,				64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NW_KEY_INDEX,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_NEW_DEVICE_NAME,		32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NEW_PWD,				64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_OOB_DEV_PWD,			58,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_OS_VERSION,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_POWER_LEVEL,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PSK_CURRENT,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PSK_MAX,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PUBLIC_KEY,			192,	WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_RADIO_ENABLED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REBOOT,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REGISTRAR_CURRENT,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_REGISTRAR_ESTBLSHD,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REGISTRAR_LIST,		512,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REGISTRAR_MAX,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_REGISTRAR_NONCE,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REQ_TYPE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_RESP_TYPE,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_RF_BANDS,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_R_HASH1,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_HASH2,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_SNONCE1,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_SNONCE2,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_SEL_REGISTRAR,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_SERIAL_NUM,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_WPSSTATE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_SSID,					32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_TOT_NETWORKS,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_UUID_E,				16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_UUID_R,				16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_VENDOR_EXT,			1024,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_VERSION,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_X509_CERT_REQ,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_X509_CERT,			0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_EAP_IDENTITY,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MSG_COUNTER,			8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_PUBKEY_HASH,			20,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REKEY_KEY,			32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_LIFETIME,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_PERM_CFG_METHODS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_SEL_REG_CFG_METHODS,	2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_PRIM_DEV_TYPE,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_SEC_DEV_TYPE_LIST,	128,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_PORTABLE_DEVICE,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_AP_SETUP_LOCKED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_APP_EXT,				512,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_EAP_TYPE,				8,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_INIT_VECTOR,			32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_PROVIDED_AUTO,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_8021X_ENABLED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_APP_SESS_KEY,			128,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_WEP_TX_KEY,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{0, 0, 0, 0},
+};
+
+static int wps_create_tlv(struct wps_tlv **tlv)
+{
+	if (!tlv)
+		return -1;
+
+	*tlv = (struct wps_tlv *)calloc(1, sizeof(struct wps_tlv));
+	if (!*tlv)
+		return -1;	/* Memory allocation error */
+
+	return 0;
+}
+
+static int wps_destroy_tlv(struct wps_tlv **tlv)
+{
+	if (!tlv || !*tlv)
+		return -1;
+
+	if (WPS_VALTYPE_PTR == (*tlv)->value_type) {
+		if ((*tlv)->value.ptr_)
+			free((*tlv)->value.ptr_);
+	}
+
+	free(*tlv);
+	*tlv = 0;
+
+	return 0;
+}
+
+static const struct wps_tlv_set *wps_get_tlv_set(
+	const u16 type)
+{
+	const struct wps_tlv_set *set = wps_tlv_sets;
+
+	while (set->type) {
+		if (type == set->type)
+			break;
+		set++;
+	}
+
+	if (!set->type)
+		return 0;	/* Invalidate tlv */
+
+	return set;
+}
+
+static const struct wps_tlv_set *wps_match_tlv(
+	const u16 type, const u16 length)
+{
+	const struct wps_tlv_set *set = wps_tlv_sets;
+
+	while (set->type) {
+		if (type == set->type) {
+			if (WPS_LENTYPE_FIX == set->length_type) {
+				if (length == set->length)
+					break;
+			} else if (WPS_LENTYPE_MAX == set->length_type) {
+				if (length <= set->length)
+					break;
+			} else if (WPS_LENTYPE_MIN == set->length_type) {
+				if (length < set->length)
+					break;
+			} else
+				return 0;	/* Application Error */
+		}
+		set++;
+	}
+
+	if (!set->type)
+		return 0;	/* Invalidate tlv */
+
+	return set;
+}
+
+static int wps_get_tlv(const u8 *buf, size_t len,
+	struct wps_tlv **tlv)
+{
+	const u8 *pos = buf;
+	const struct wps_tlv_set *set;
+	u16 type;
+	size_t length;
+	Boolean b_value = FALSE;
+	u8 u8_value = 0;
+	u16 u16_value = 0;
+	u32 u32_value = 0;
+	u8 *ptr_value = 0;
+
+	if (!buf || 4 >= len || !tlv)
+		return -1;
+
+	*tlv = 0;
+
+	type = WPA_GET_BE16(pos);
+	length = WPA_GET_BE16(pos+2);
+
+	set = wps_match_tlv(type, length);
+	if (!set)
+		return -1;	/* Invalidate tlv */
+
+	if (length + 4 > len)
+		return -1;	/* Buffer too short */
+
+	switch (set->value_type) {
+	case WPS_VALTYPE_BOOL:
+		if (length != 1)
+			return -1;
+		b_value = (Boolean)*(pos+4);
+		break;
+	case WPS_VALTYPE_U8:
+		if (length != 1)
+			return -1;
+		u8_value = *(pos+4);
+		break;
+	case WPS_VALTYPE_U16:
+		if (length != 2)
+			return -1;
+		u16_value = WPA_GET_BE16(pos+4);
+		break;
+	case WPS_VALTYPE_U32:
+		if (length != 4)
+			return -1;
+		u32_value = WPA_GET_BE32(pos+4);
+		break;
+	case WPS_VALTYPE_PTR:
+		ptr_value = (u8 *)os_malloc(length);
+		if (!ptr_value)
+			return -1; /* Memory allocation error */
+		os_memcpy(ptr_value, pos+4, length);
+		break;
+	default:
+		return -1;
+	}
+
+	if (0 != wps_create_tlv(tlv)) {
+		if (ptr_value)
+			free(ptr_value);
+		return -1; /* Memory allocation error */
+	}
+
+	(*tlv)->type = type;
+	(*tlv)->length = length;
+	(*tlv)->value_type = set->value_type;
+	switch ((*tlv)->value_type) {
+	case WPS_VALTYPE_BOOL:
+		(*tlv)->value.bool_ = (u8)b_value;
+		break;
+	case WPS_VALTYPE_U8:
+		(*tlv)->value.u8_ = u8_value;
+		break;
+	case WPS_VALTYPE_U16:
+		(*tlv)->value.u16_ = u16_value;
+		break;
+	case WPS_VALTYPE_U32:
+		(*tlv)->value.u32_ = u32_value;
+		break;
+	case WPS_VALTYPE_PTR:
+		(*tlv)->value.ptr_ = ptr_value;
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static int wps_add_tlv(struct wps_data *data, struct wps_tlv *tlv, Boolean allocate)
+{
+	const struct wps_tlv_set *set;
+
+	set = wps_match_tlv(tlv->type, tlv->length);
+	if (!set)
+		return -1;	/* Invalid tlv */
+
+	data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+				sizeof(struct wpa_tlv *) * (data->count + 1));
+
+	if (!data->tlvs)
+		return -1;	/* Memory allocation error */
+
+	if (allocate) {
+		Boolean fail_adding = 1;
+		struct wps_tlv * newTlv = (struct wps_tlv *)os_malloc(sizeof(struct wps_tlv));
+		do {
+			if (wps_create_tlv(&newTlv))
+				break;
+			os_memcpy(newTlv, tlv, sizeof(struct wps_tlv));
+			if (WPS_VALTYPE_PTR == set->value_type) {
+				if (tlv->length) {
+					newTlv->value.ptr_ = (u8 *)os_malloc(tlv->length);
+					if (!newTlv->value.ptr_) {
+						free(newTlv);
+						newTlv = 0;
+						break;
+					}
+					os_memcpy(newTlv->value.ptr_, tlv->value.ptr_, tlv->length);
+				} else
+					newTlv->value.ptr_ = 0;
+			}
+			data->tlvs[data->count++] = newTlv;
+			fail_adding = 0;
+		} while (0);
+
+		if (fail_adding) {
+			if (data->count)
+				data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+							sizeof(struct wpa_tlv *) * data->count);
+			else {
+				free(data->tlvs);
+				data->tlvs = 0;
+			}
+			return -1;
+		}
+	} else
+		data->tlvs[data->count++] = tlv;
+
+	return 0;
+}
+
+static int wps_del_tlv(struct wps_data *data, const u16 type)
+{
+	struct wps_tlv *tlv;
+	int index, found = 0;
+
+	for ( index = 0; index < data->count; index++, tlv++) {
+		tlv = data->tlvs[index];
+		if (tlv->type == type) {
+			wps_destroy_tlv(&tlv);
+			found = 1;
+			break;
+		}
+	}
+
+	if (found) {
+		for ( index++; index < data->count; index++, tlv++) {
+			data->tlvs[index-1] = data->tlvs[index];
+		}
+
+		if (0 < data->count - 1) {
+			data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+							sizeof(struct wps_tlv *) * (--data->count));
+			if (!data->tlvs)
+				return -1;
+		} else {
+			free(data->tlvs);
+			data->tlvs = 0;
+			data->count = 0;
+		}
+	}
+
+	return found?0:-1;
+}
+
+int wps_create_wps_data(struct wps_data **data)
+{
+	if (!data)
+		return -1;
+
+	*data = calloc(1, sizeof(struct wps_data));
+	if (!*data)
+		return -1;
+
+	return 0;
+}
+
+int wps_destroy_wps_data(struct wps_data **data)
+{
+	if (!data | !*data)
+		return -1;
+
+	while((*data)->count--)
+		wps_destroy_tlv(&((*data)->tlvs[(*data)->count]));
+
+	free((*data)->tlvs);
+	(*data)->tlvs = 0;
+
+	free(*data);
+	*data = 0;
+
+	return 0;
+}
+
+int wps_parse_wps_ie(const u8 *wps_ie, size_t wps_ie_len,
+	struct wps_data *data)
+{
+	const u8 *pos = wps_ie;
+
+	if (!wps_ie || 4 >= wps_ie_len || !data)
+		return -1;
+
+	if (pos[0] == GENERIC_INFO_ELEM && pos[1] >= 4 &&
+		os_memcmp(pos + 2, "\x00\x50\xf2\x04", 4) == 0) {
+		pos += 6;
+		return wps_parse_wps_data(pos, wps_ie_len - 6, data);
+	}
+
+	return -1;
+}
+
+int wps_parse_wps_data(const u8 *buf, size_t len,
+	struct wps_data *data)
+{
+	const u8 *pos = buf;
+	const u8 *end = buf + len;
+	struct wps_tlv *tlv;
+
+	if (!buf || 4 >= len || !data)
+		return -1;
+
+	data->count = 0;
+	while (pos + 4 < end) {
+		if (0 != wps_get_tlv(pos, end - pos, &tlv))
+			return -1;
+
+		wps_add_tlv(data, tlv, 0);
+
+		pos += 4 + tlv->length;
+	}
+
+	return 0;
+}
+
+int wps_write_wps_ie(struct wps_data * data, u8 **ie, u16 *length)
+{
+	int ret = -1;
+	u8 *buf = 0;
+	u16 len;
+
+	do {
+		if (!data || !ie || !length)
+			break;
+
+		*ie = 0;
+		*length = 0;
+
+		if (wps_write_wps_data(data, &buf, &len))
+			break;
+
+		if ((len + 4) > 255)
+			break;
+
+		*ie = (u8 *)os_malloc(len + 6);
+		if (!*ie)
+			break;
+		*(*ie) = GENERIC_INFO_ELEM;
+		*((*ie)+1) = (u8)(len + 4);
+		os_memcpy((*ie)+2, "\x00\x50\xf2\x04", 4);
+		os_memcpy((*ie)+6, buf, len);
+		*length = len + 6;
+
+		ret = 0;
+	} while (0);
+
+	if (buf)
+		free(buf);
+
+	if (ret) {
+		if (ie && *ie) {
+			free(*ie);
+			*ie = 0;
+		}
+		if (length)
+			*length = 0;
+	}
+
+	return ret;
+}
+
+int wps_write_wps_data(struct wps_data * data, u8 **buf, u16 *length)
+{
+	Boolean err = 0;
+	u8 index;
+	u8 *tmp;
+	struct wps_tlv *tlv;
+	if (!buf | !length)
+		return -1;
+
+	*buf = 0;
+	*length = 0;
+
+	if (!data)
+		return -1;
+
+	for (index = 0; index < data->count && !err; index++) {
+		tlv = data->tlvs[index];
+		*buf = (u8 *)os_realloc(*buf, *length + 4 + tlv->length);
+		if (!*buf) {
+			err = -1;
+			break;
+		}
+		tmp = *buf + *length;
+		*length += 4 + tlv->length;
+
+		WPA_PUT_BE16(tmp, tlv->type);
+		WPA_PUT_BE16(tmp+2, tlv->length);
+		switch(tlv->value_type) {
+		case WPS_VALTYPE_BOOL:
+			*(tmp+4) = (u8)tlv->value.bool_;
+			break;
+		case WPS_VALTYPE_U8:
+			*(tmp+4) = tlv->value.u8_;
+			break;
+		case WPS_VALTYPE_U16:
+			WPA_PUT_BE16(tmp+4, tlv->value.u16_);
+			break;
+		case WPS_VALTYPE_U32:
+			WPA_PUT_BE32(tmp+4, tlv->value.u32_);
+			break;
+		case WPS_VALTYPE_PTR:
+			os_memcpy(tmp+4, tlv->value.ptr_, tlv->length);
+			break;
+		default:
+			err = -1;
+			break;
+		}
+	}
+
+	if (err) {
+		free(*buf);
+		*buf = 0;
+		*length = 0;
+	}
+
+	return err;
+}
+
+int wps_get_value(const struct wps_data *data, u16 type, void *value, u16 *length)
+{
+	int ret = 0;
+	struct wps_tlv *tlv = 0;
+	int i;
+
+	for (i = 0; i < data->count; i++) {
+		if ((data->tlvs[i])->type == type) {
+			tlv = data->tlvs[i];
+			break;
+		}
+	}
+
+	if (!tlv)
+		return -1;
+
+	switch (tlv->value_type) {
+	case WPS_VALTYPE_BOOL:
+		if (value)
+			*(Boolean*)value = tlv->value.bool_;
+		break;
+	case WPS_VALTYPE_U8:
+		if (value)
+			*(u8 *)value = tlv->value.u8_;
+		break;
+	case WPS_VALTYPE_U16:
+		if (value)
+			*(u16 *)value = tlv->value.u16_;
+		break;
+	case WPS_VALTYPE_U32:
+		if (value)
+			*(u32 *)value = tlv->value.u32_;
+		break;
+	case WPS_VALTYPE_PTR:
+		if (!length || (*length < tlv->length))
+			ret = -1;
+		else if (value && tlv->value.ptr_)
+			os_memcpy(value, tlv->value.ptr_, tlv->length);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	if (length)
+		*length = tlv->length;
+
+	if (!value)
+		ret = -1;
+
+	return ret;
+}
+
+int wps_set_value(const struct wps_data *data, u16 type, void *value, u16 length)
+{
+	const struct wps_tlv_set *set = 0;
+	struct wps_tlv tlv;
+
+	if (!value && length)
+		return -1;
+
+	set = wps_get_tlv_set(type);
+	if (!set)
+		return -1;
+
+	tlv.value_type = set->value_type;
+	switch (tlv.value_type) {
+	case WPS_VALTYPE_BOOL:
+		tlv.type = type;
+		tlv.length = 1;
+		tlv.value.bool_ = *(Boolean*)value;
+		break;
+	case WPS_VALTYPE_U8:
+		tlv.type = type;
+		tlv.length = 1;
+		tlv.value.u8_ = *(u8*)value;
+		break;
+	case WPS_VALTYPE_U16:
+		tlv.type = type;
+		tlv.length = 2;
+		tlv.value.u16_ = *(u16*)value;
+		break;
+	case WPS_VALTYPE_U32:
+		tlv.type = type;
+		tlv.length = 4;
+		tlv.value.u32_ = *(u16*)value;
+		break;
+	case WPS_VALTYPE_PTR:
+		tlv.type = type;
+		tlv.length = length;
+		tlv.value.ptr_ = (u8*)value;
+		break;
+	default:
+		return -1;
+	}
+
+	return wps_add_tlv((struct wps_data *)data, &tlv, 1);
+}
+
+int wps_remove_value(struct wps_data *data, u16 type)
+{
+	return wps_del_tlv(data, type);
+}
+
+
+u8 wps_get_message_type(u8 *buf, size_t length)
+{
+	u8 msg_type = -1;
+	struct wps_data *wps = 0;
+
+	do {
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(buf, length, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg_type;
+}
+
+
Index: intel_ie_wps.h
===================================================================
--- intel_ie_wps.h	(revision 0)
+++ intel_ie_wps.h	(revision 2)
@@ -0,0 +1,53 @@
+#ifndef INTEL_IE_WPS_H
+#define INTEL_IE_WPS_H
+
+#pragma pack(push, 1)
+
+typedef struct wps_ie_data {
+	struct wpa_supplicant *wpa_s;
+	int udpFdCom;
+	int sendCounter;
+	int sendUp;
+} WPS_IE_DATA;
+
+#if !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_WLAN_UDP_PORT       38000
+#else   // !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_WLAN_UDP_PORT       38002
+#endif  // !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_WLAN_UDP_ADDR       "127.0.0.1"
+
+#define WPS_WLAN_DATA_MAX_LENGTH         1024
+
+#define WPS_IE_TYPE_SET_BEACON_IE     			1
+#define WPS_IE_TYPE_SET_PROBE_REQUEST_IE     	2
+#define WPS_IE_TYPE_SET_PROBE_RESPONSE_IE     	3
+#define WPS_IE_TYPE_BEACON_IE_DATA     			4
+#define WPS_IE_TYPE_PROBE_REQUEST_IE_DATA     	5
+#define WPS_IE_TYPE_PROBE_RESPONSE_IE_DATA     	6
+#define WPS_IE_TYPE_SEND_BEACONS_UP				7
+#define WPS_IE_TYPE_SEND_PR_RESPS_UP			8
+#define WPS_IE_TYPE_SEND_PROBE_REQUEST			9
+#define WPS_IE_TYPE_MAX                         10
+
+typedef struct wps_ie_command_data {
+	u8 type;
+	u32 length;
+	u8 data[];
+} WPS_IE_COMMAND_DATA;
+
+typedef struct wps_ie_beacon_data
+{
+	char        ssid[32];
+	u8          macAddr[6];
+	u8          data[];
+} WPS_IE_BEACON_DATA;
+
+
+int wps_ie_init(struct wpa_supplicant *wpa_s);
+int wps_ie_deinit(struct wpa_supplicant *wpa_s);
+ 
+#pragma pack(pop)
+
+#endif /* INTEL_IE_WPS_H */
+
Index: wps_opt_nfc.h
===================================================================
--- wps_opt_nfc.h	(revision 0)
+++ wps_opt_nfc.h	(revision 2)
@@ -0,0 +1,67 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_nfc.h
+//  Description: EAP-WPS NFC option source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_OPT_NFC_H
+#define WPS_OPT_NFC_H
+
+struct wpa_config;
+struct wps_opt_nfc_sm;
+#ifdef WPS_OPT_UPNP
+struct wps_opt_upnp_sm;
+#endif /* WPS_OPT_UPNP */
+
+struct wps_opt_nfc_sm_ctx {
+	void *ctx;		/* pointer to arbitrary upper level context */
+	void *msg_ctx;
+
+	int (*get_own_addr)(void *ctx, u8* mac);
+	struct wpa_config *(*get_conf)(void *ctx);
+#ifdef WPS_OPT_UPNP
+	struct wps_opt_upnp_sm *(*get_upnp_sm)(void *ctx);
+#endif /* WPS_OPT_UPNP */
+};
+
+struct wps_opt_nfc_sm *wps_opt_nfc_sm_init(struct wps_opt_nfc_sm_ctx *ctx);
+void wps_opt_nfc_sm_deinit(struct wps_opt_nfc_sm *sm);
+void wps_opt_nfc_sm_set_ifname(struct wps_opt_nfc_sm *sm, const char *nfcname);
+void wps_opt_nfc_sm_step(struct wps_opt_nfc_sm *sm);
+
+int wps_opt_nfc_cancel_nfc_comand(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_write_password_token(struct wps_opt_nfc_sm *sm, int nwIdx);
+u16 wps_opt_nfc_read_password_token(struct wps_opt_nfc_sm *sm, int nwIdx);
+int wps_opt_nfc_read_config_token(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_write_config_token(struct wps_opt_nfc_sm *sm, int nwIdx);
+
+
+#endif /* WPS_OPT_NFC_H */
Index: intel_eap_wps.c
===================================================================
--- intel_eap_wps.c	(revision 0)
+++ intel_eap_wps.c	(revision 2)
@@ -0,0 +1,274 @@
+/*
+ * WPA Supplicant / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2004-2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WPS and COPYING for more details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+/*#include <netinet/in.h> */
+#ifdef __linux__
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/dh.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+
+#include "common.h"
+#include "eloop.h"
+#include "eap_i.h"
+#include "wpa_supplicant.h"
+#include "intel_eap_wps.h"
+#include "intel_udplib.h"
+
+#if !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_EAP_UDP_PORT            37000
+#else   // !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_EAP_UDP_PORT            37002
+#endif  // !defined(DIFF_PORT_FROM_HOSTAPD)
+#define WPS_EAP_UDP_ADDR            "127.0.0.1"
+// #define WPS_COMMANDS_UDP_PORT       38000
+
+/*
+static void wps_read_callback(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	struct eap_wps_data *data = eloop_ctx;
+	struct wps_command_data comData;
+	int recvBytes;
+	struct sockaddr_in from;
+
+	wpa_printf(MSG_DEBUG, "EAP-WPS: Entered wps_read_callback. "
+			"sock = %d\n", sock);
+
+	recvBytes = udp_read(data->udpFdCom, (u8 *) &comData, 
+			sizeof(struct wps_command_data), &from);
+
+	if (recvBytes == -1 || recvBytes < sizeof(struct wps_command_data))
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Reading Command message "
+				"from upper layer failed\n");
+		return;
+	}
+
+	if (comData.type == WPS_CTYPE_NEW_SETTINGS)
+	{
+		// write file; send command to reload
+	}
+	else
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Wrong command type from upper layer\n");
+		return;
+	}
+   
+	return;
+}
+*/
+
+static void * eap_wps_init(struct eap_sm *sm)
+{
+	struct eap_wps_data *data;
+
+	wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WPS: Entered eap_wps_init *#@*#@*#@");
+
+	data = os_malloc(sizeof(*data));
+	if (data == NULL)
+		return data;
+	os_memset(data, 0, sizeof(*data));
+
+	data->udpFdEap = udp_open();
+
+	/*
+	data->udpFdCom = udp_open();
+	if (udp_bind(data->udpFdCom, WPS_COMMANDS_UDP_PORT) == -1)
+	{
+		wpa_printf(MSG_DEBUG, "EAP-WPS: udp_bind failed!");
+		os_free(data);
+		return NULL;
+	}
+
+	eloop_register_read_sock(data->udpFdCom, wps_read_callback,
+				 data, NULL);
+	*/
+
+	sm->eap_method_priv = data;
+
+	return data;
+}
+
+
+static void eap_wps_deinit(struct eap_sm *sm, void *priv)
+{
+	wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WPS: Entered eap_wps_reset *#@*#@*#@");
+
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+	if (data == NULL)
+		return;
+
+	if (data->udpFdEap != -1)
+	{
+		udp_close(data->udpFdEap);
+		data->udpFdEap = -1;
+	}
+
+	/*
+	if (data->udpFdCom != -1)
+	{
+		eloop_unregister_read_sock(data->udpFdCom);
+		udp_close(data->udpFdCom);
+		data->udpFdCom = -1;
+	}
+	*/
+
+	os_free(data);
+}
+
+static u8 * eap_wps_process(struct eap_sm *sm, void *priv,
+							struct eap_method_ret *ret,
+							const u8 *reqData, size_t reqDataLen,
+							size_t *respDataLen)
+{
+	struct eap_wps_data *data = priv;
+	struct eap_hdr *req;
+	int recvBytes;
+	u8 * resp;
+	u8 * sendBuf;
+	u32 sendBufLen;
+	struct sockaddr_in from;
+	struct sockaddr_in to;
+	WPS_NOTIFY_DATA notifyData;
+	WPS_NOTIFY_DATA * recvNotify;
+
+	wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WPS: Entered eap_wps_process *#@*#@*#@");
+
+	req = (struct eap_hdr *) reqData;
+	wpa_printf(MSG_DEBUG, "EAP-WPS : Received packet(len=%lu) ",
+			   (unsigned long) reqDataLen);
+	if(ntohs(req->length) != reqDataLen)
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Pkt length in pkt(%d) differs from" 
+			" supplied (%d)\n", ntohs(req->length), reqDataLen);
+		ret->ignore = TRUE;
+		return NULL;
+	}
+
+	notifyData.type = WPS_NOTIFY_TYPE_PROCESS_REQ;
+	notifyData.length = reqDataLen;
+	notifyData.u.process.state = data->state;
+   
+	sendBuf = (u8 *) os_malloc(sizeof(WPS_NOTIFY_DATA) + reqDataLen);
+	if ( ! sendBuf)
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Memory allocation "
+				"for the sendBuf failed\n");
+		ret->ignore = TRUE;
+		return NULL;
+	}
+
+	os_memcpy(sendBuf, &notifyData, sizeof(WPS_NOTIFY_DATA));
+	os_memcpy(sendBuf + sizeof(WPS_NOTIFY_DATA), reqData, reqDataLen);
+	sendBufLen = sizeof(WPS_NOTIFY_DATA) + reqDataLen;
+
+	to.sin_addr.s_addr = inet_addr(WPS_EAP_UDP_ADDR);
+	to.sin_family = AF_INET;
+	to.sin_port = host_to_be16(WPS_EAP_UDP_PORT);
+
+	if (udp_write(data->udpFdEap, (char *) sendBuf, sendBufLen, &to) < 
+			sendBufLen)
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Sending Eap message to "
+				"upper Layer failed\n");
+		ret->ignore = TRUE;
+		os_free(sendBuf);
+		return NULL;
+	}
+
+	os_free(sendBuf);
+
+	recvBytes = udp_read_timed(data->udpFdEap, (char *) data->recvBuf, 
+			WPS_RECVBUF_SIZE, &from, 5);
+
+	if (recvBytes == -1)
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Reading EAP message "
+				"from upper layer failed\n");
+		ret->ignore = TRUE;
+		return NULL;
+	}
+
+	recvNotify = (WPS_NOTIFY_DATA *) data->recvBuf;
+	if ( (recvNotify->type != WPS_NOTIFY_TYPE_PROCESS_RESULT) ||
+	//     (recvNotify->length == 0) ||
+		 (recvNotify->u.processResult.result != WPS_NOTIFY_RESULT_SUCCESS) )
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Process Message failed "
+				"somewhere\n");
+		ret->ignore = TRUE;
+		return NULL;
+	}
+	
+	resp = (u8 *) os_malloc(recvNotify->length);
+	if ( ! resp)
+	{
+		wpa_printf(MSG_INFO, "EAP-WPS: Memory allocation "
+				"for the resp failed\n");
+		ret->ignore = TRUE;
+		return NULL;
+	}
+
+	os_memcpy(resp, recvNotify + 1, recvNotify->length);
+	*respDataLen = recvNotify->length;
+	ret->ignore = FALSE;
+	ret->decision = DECISION_COND_SUCC;
+	ret->allowNotifications = FALSE;
+
+	/*check if we're done*/
+	if (recvNotify->u.processResult.done)
+	{
+		ret->methodState = METHOD_DONE;
+	}
+	else
+	{
+		wpa_printf(MSG_INFO, "Always setting it to METHOD_CONT\n");
+		ret->methodState = METHOD_CONT;
+	}
+
+	return resp;
+}
+
+int eap_peer_wps_register(void)
+{
+#define EAP_VENDOR_ID_WPS	0x0000372a
+#define EAP_VENDOR_TYPE_WPS	1
+
+	struct eap_method *eap;
+	int ret;
+
+	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
+					EAP_VENDOR_ID_WPS, EAP_VENDOR_TYPE_WPS, "WPS");
+	if (eap == NULL)
+		return -1;
+
+	eap->init = eap_wps_init;
+	eap->deinit = eap_wps_deinit;
+	eap->process = eap_wps_process;
+
+	ret = eap_peer_method_register(eap);
+	if (ret)
+		eap_peer_method_free(eap);
+	return ret;
+}
+
Index: wps_parser.h
===================================================================
--- wps_parser.h	(revision 0)
+++ wps_parser.h	(revision 2)
@@ -0,0 +1,65 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_parser.h
+//  Description: EAP-WPS parser source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_PARSER_H
+#define WPS_PARSER_H
+
+#define WPS_VALTYPE_BOOL	0
+#define WPS_VALTYPE_U8		1
+#define WPS_VALTYPE_U16		2
+#define WPS_VALTYPE_U32		3
+#define	WPS_VALTYPE_PTR		4
+
+struct wps_tlv;
+
+struct wps_data {
+	u8 count;
+	struct wps_tlv **tlvs;
+};
+
+int wps_create_wps_data(struct wps_data **data);
+int wps_destroy_wps_data(struct wps_data **data);
+
+int wps_parse_wps_ie(const u8 *wps_ie, size_t wps_ie_len, struct wps_data *data);
+int wps_parse_wps_data(const u8 *buf, size_t len, struct wps_data *data);
+
+int wps_write_wps_ie(struct wps_data * data, u8 **ie, u16 *length);
+int wps_write_wps_data(struct wps_data * data, u8 **buf, u16 *length);
+
+int wps_get_value(const struct wps_data *data, u16 type, void *value, u16 *length);
+int wps_set_value(const struct wps_data *data, u16 type, void *value, u16 length);
+int wps_remove_value(struct wps_data *data, u16 type);
+
+u8 wps_get_message_type(u8 *buf, size_t length);
+#endif /* WPS_PARSER_H */
Index: intel_eap_wps.h
===================================================================
--- intel_eap_wps.h	(revision 0)
+++ intel_eap_wps.h	(revision 2)
@@ -0,0 +1,78 @@
+
+#ifndef EAP_WPS_H
+#define EAP_WPS_H
+
+#pragma pack(push, 1)
+
+#define WPS_RECVBUF_SIZE    2048
+
+struct eap_wps_data {
+    enum { START, CONTINUE, SUCCESS, FAILURE } state;
+    int udpFdEap;
+    int udpFdCom;
+    u8 recvBuf[WPS_RECVBUF_SIZE];
+};
+
+#define WPS_NOTIFY_TYPE_BUILDREQ              1
+#define WPS_NOTIFY_TYPE_BUILDREQ_RESULT       2
+#define WPS_NOTIFY_TYPE_PROCESS_REQ           3
+#define WPS_NOTIFY_TYPE_PROCESS_RESP          4
+#define WPS_NOTIFY_TYPE_PROCESS_RESULT        5
+
+#define WPS_NOTIFY_RESULT_SUCCESS			  0x00
+#define WPS_NOTIFY_RESULT_FAILURE			  0xFF
+
+typedef struct wps_notify_buildreq_tag {
+    u32    id;
+    u32 state;
+} WPS_NOTIFY_BUILDREQ;
+
+typedef struct wps_notify_process_buildreq_result_tag {
+	u8 result;
+} WPS_NOTIFY_BUILDREQ_RESULT;
+
+typedef struct wps_notify_process_tag {
+	u32 state;
+} WPS_NOTIFY_PROCESS;
+
+typedef struct wps_notify_process_result_tag {
+	u8 result;
+	u8 done;
+} WPS_NOTIFY_PROCESS_RESULT;
+
+typedef struct wps_notify_data_tag {
+    u8 type;
+    union {
+        WPS_NOTIFY_BUILDREQ bldReq;
+        WPS_NOTIFY_BUILDREQ_RESULT bldReqResult;
+        WPS_NOTIFY_PROCESS process;
+        WPS_NOTIFY_PROCESS_RESULT processResult;
+    } u;
+	u32 length; // length of the data that follows
+} WPS_NOTIFY_DATA;
+
+
+/*
+#define WPS_CTYPE_NEW_SETTINGS      1
+#define WPS_CTYPE_MAX               2
+
+#define WPS_MAX_SSID_LEN            32
+#define WPS_MAX_PSK_LEN             32
+
+struct wps_command_data {
+    u8 type;
+    union {
+        struct wps_new_settings
+        {
+            u16 ssidLen;
+            char ssid[WPS_MAX_SSID_LEN];
+            u16 pskLen;
+            u8 psk[WPS_MAX_PSK_LEN];
+        } new_set;
+    } u;
+};
+*/
+
+#pragma pack(pop)
+
+#endif /*EAP_WPS_H*/
Index: config_file.c
===================================================================
--- config_file.c	(revision 1)
+++ config_file.c	(revision 2)
@@ -23,7 +23,13 @@
 #include "base64.h"
 #include "eap_methods.h"
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 /**
  * wpa_config_get_line - Read the next configuration file line
  * @s: Buffer for the line
@@ -240,6 +246,65 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static struct wps_config * wpa_config_read_wps_property(FILE *f, int *line)
+{
+	struct wps_config *wps;
+	int errors = 0, end = 0;
+	char buf[256], *pos, *pos2;
+
+	wpa_printf(MSG_MSGDUMP, "Line: %d - start of a wps_property block",
+		   *line);
+	wps = wpa_zalloc(sizeof(*wps));
+	if (wps == NULL)
+		return NULL;
+
+	while (wpa_config_get_line(buf, sizeof(buf), f, line, &pos)) {
+		if (strcmp(pos, "}") == 0) {
+			end = 1;
+			break;
+		}
+
+		pos2 = os_strchr(pos, '=');
+		if (pos2 == NULL) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid property line "
+				   "'%s'.", *line, pos);
+			errors++;
+			continue;
+		}
+
+		*pos2++ = '\0';
+		if (*pos2 == '"') {
+			if (os_strchr(pos2 + 1, '"') == NULL) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid "
+					   "quotation '%s'.", *line, pos2);
+				errors++;
+				continue;
+			}
+		}
+
+		if (wps_config_set(wps, pos, pos2, *line) < 0)
+			errors++;
+	}
+
+	if (!end) {
+		wpa_printf(MSG_ERROR, "Line %d: wps_property block was not "
+			   "terminated properly.", *line);
+		errors++;
+	}
+
+	if (errors) {
+		wpa_config_free_wps_config(wps);
+		wps = NULL;
+	}
+
+	return wps;
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
 struct wpa_config * wpa_config_read(const char *name)
 {
 	FILE *f;
@@ -249,6 +314,12 @@
 	struct wpa_config *config;
 	int id = 0;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config *wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	config = wpa_config_alloc_empty(NULL, NULL);
 	if (config == NULL)
 		return NULL;
@@ -390,6 +461,26 @@
 					   line, so);
 				errors++;
 			}
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+		} else if (os_strcmp(pos, "wps_property={") == 0) {
+			wps = wpa_config_read_wps_property(f, &line);
+			if (config->wps) {
+				if (wps)
+					os_free(wps);
+				wpa_printf(MSG_ERROR, "Line %d: Failed to "
+					   "set multiple WPS properties.", line);
+				errors++;
+				continue;
+			} else if (!wps) {
+				wpa_printf(MSG_ERROR, "Line %d: failed to "
+					   "parse wps_property block.", line);
+				errors++;
+				continue;
+			}
+			config->wps = wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 		} else {
 			wpa_printf(MSG_ERROR, "Line %d: Invalid configuration "
 				   "line '%s'.", line, pos);
@@ -647,6 +738,44 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static void wps_write(FILE *f, const char *field, struct wps_config *wps)
+{
+	char *value = wps_config_get(wps, field);
+	fprintf(f, "\t%s=%s\n", field, value?value:"");
+	os_free(value);
+}
+
+
+static void wpa_config_write_wps(FILE *f, struct wps_config *wps)
+{
+#define WRITE(t) wps_write(f, #t, wps)
+	fprintf(f, "\nwps_property={\n");
+	WRITE(version);
+	WRITE(uuid);
+	WRITE(auth_type_flags);
+	WRITE(encr_type_flags);
+	WRITE(conn_type_flags);
+	WRITE(config_methods);
+	WRITE(wps_state);
+	WRITE(rf_state);
+	WRITE(manufacturer);
+	WRITE(model_name);
+	WRITE(model_number);
+	WRITE(serial_number);
+	WRITE(dev_category);
+	WRITE(dev_sub_category);
+	WRITE(dev_oui);
+	WRITE(dev_name);
+	WRITE(os_version);
+	WRITE(upnp_iface);
+	fprintf(f, "}\n");
+#undef WRITE
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 static void wpa_config_write_global(FILE *f, struct wpa_config *config)
 {
 #ifdef CONFIG_CTRL_IFACE
@@ -716,6 +845,12 @@
 			break;
 	}
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	wpa_config_write_wps(f, config->wps);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	fclose(f);
 
 	wpa_printf(MSG_DEBUG, "Configuration file '%s' written %ssuccessfully",
Index: config.c
===================================================================
--- config.c	(revision 1)
+++ config.c	(revision 2)
@@ -22,7 +22,13 @@
 #include "l2_packet.h"
 #include "config.h"
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 /*
  * Structure for network configuration parsing. This data is used to implement
  * a generic parser for each network block variable. The table of configuration
@@ -132,7 +138,11 @@
 }
 
 
+#if !defined(EAP_WPS) || defined(USE_INTEL_SDK)
 static int is_hex(const u8 *data, size_t len)
+#else // !defined(EAP_WPS) || defined(USE_INTEL_SDK)
+int is_hex(const u8 *data, size_t len)
+#endif // !defined(EAP_WPS) || defined(USE_INTEL_SDK)
 {
 	size_t i;
 
@@ -1338,6 +1348,12 @@
 		wpa_config_free_blob(prevblob);
 	}
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	wpa_config_free_wps_config(config->wps);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	os_free(config->ctrl_interface);
 	os_free(config->ctrl_interface_group);
 	os_free(config->opensc_engine_path);
@@ -1587,6 +1603,7 @@
 		const struct parse_data *field = &ssid_fields[i];
 		if (os_strcmp(var, field->name) == 0) {
 			char *res = field->writer(field, ssid);
+#ifndef EAP_WPS
 			if (field->key_data) {
 				if (res && res[0]) {
 					wpa_printf(MSG_DEBUG, "Do not allow "
@@ -1599,6 +1616,7 @@
 				os_free(res);
 				return NULL;
 			}
+#endif /* EAP_WPS */
 			return res;
 		}
 	}
@@ -1703,7 +1721,571 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static int wpa_config_parse_hex8(const struct parse_data *data,
+				struct wpa_ssid *ssid,
+				int line, const char *value)
+{
+	u8 *dst;
+
+	dst = (u8 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u8)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%02x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%02x "
+			   "min_value=0x%02x)", line, data->name, *dst,
+			   (u8) ((u32) data->param3));
+		*dst = (u8) ((u32) data->param3);
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%02x "
+			   "max_value=0x%02x)", line, data->name, *dst,
+			   (u8) ((u32)data->param4));
+		*dst = (u8) ((u32)data->param4);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * wpa_config_write_hex8(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	u8 *src;
+	char *value;
+
+	src = (u8 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = os_malloc(20);
+	if (value == NULL)
+		return NULL;
+	os_snprintf(value, 20, "0x%02x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wpa_config_parse_hex16(const struct parse_data *data,
+				struct wpa_ssid *ssid,
+				int line, const char *value)
+{
+	u16 *dst;
+
+	dst = (u16 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u16)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%04x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%04x "
+			   "min_value=0x%04x)", line, data->name, *dst,
+			   (u16) ((u32) data->param3));
+		*dst = (u16) ((u32) data->param3);
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%04x "
+			   "max_value=0x%04x)", line, data->name, *dst,
+			   (u16) ((u32)data->param4));
+		*dst = (u16) ((u32)data->param4);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * wpa_config_write_hex16(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	u16 *src;
+	char *value;
+
+	src = (u16 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = os_malloc(20);
+	if (value == NULL)
+		return NULL;
+	os_snprintf(value, 20, "0x%04x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wpa_config_parse_hex32(const struct parse_data *data,
+				struct wpa_ssid *ssid,
+				int line, const char *value)
+{
+	u32 *dst;
+
+	dst = (u32 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u32)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%08x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%08x "
+			   "min_value=0x%08x)", line, data->name, *dst,
+			   (u32) data->param3);
+		*dst = (u32) data->param3;
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%08x "
+			   "max_value=0x%08x)", line, data->name, *dst,
+			   (u32)data->param4);
+		*dst = (u32)data->param4;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * wpa_config_write_hex32(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	u32 *src;
+	char *value;
+
+	src = (u32 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = os_malloc(20);
+	if (value == NULL)
+		return NULL;
+	os_snprintf(value, 20, "0x%08x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wps_config_parse_uuid(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (hexstr2bin(value, wps->uuid, SIZE_16_BYTES) ||
+	    value[SIZE_16_BYTES * 2] != '\0') {
+		wpa_printf(MSG_ERROR, "Line %d: Invalid UUID '%s'.",
+			   line, value);
+		return -1;
+	}
+
+	wps->uuid_set = 1;
+	wpa_hexdump_key(MSG_MSGDUMP, "UUID", wps->uuid, SIZE_16_BYTES);
+	return 0;
+}
+
+
+static char * wps_config_write_uuid(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (wps->uuid_set)
+		return wpa_config_write_string_hex(wps->uuid, SIZE_16_BYTES);
+
+	return NULL;
+}
+
+
+static int _wps_config_parse_dev_category(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value, int sub)
+{
+	u16 *dst;
+	struct wps_config *wps = (struct wps_config *)ssid;
+	u16 min, max;
+	int save_offset;
+
+	if (!sub) {
+		dst = &wps->dev_category;
+		min = 1;
+		max = 10;
+		save_offset = 0;
+	} else {
+		dst = &wps->dev_sub_category;
+		min = 1;
+		max = 3;
+		save_offset = 6;
+	}
+
+	*dst = (u16) atoi(value);
+	wpa_printf(MSG_MSGDUMP, "%s=%d (0x%04x)", data->name, *dst, *dst);
+
+	if (min && *dst < min) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=%d "
+			   "min_value=%d)", line, data->name, *dst, min);
+		*dst = min;
+		return -1;
+	}
+
+	if (max && *dst > max) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=%d "
+			   "max_value=%d)", line, data->name, *dst, max);
+		*dst = max;
+		return -1;
+	}
+
+	WPA_PUT_BE16(&wps->prim_dev_type[save_offset], *dst);
+	return 0;
+}
+
+
+static char * _wps_config_write_dev_category(const u16 src)
+{
+	char *value;
+
+	value = os_malloc(20);
+	if (value == NULL)
+		return NULL;
+	os_snprintf(value, 20, "%d", src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wps_config_parse_dev_category(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value)
+{
+	return _wps_config_parse_dev_category(data, ssid, line, value, 0);
+}
+
+
+static char * wps_config_write_dev_category(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+	return _wps_config_write_dev_category(wps->dev_category);
+}
+
+
+static int wps_config_parse_dev_sub_category(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value)
+{
+	return _wps_config_parse_dev_category(data, ssid, line, value, 1);
+}
+
+
+static char * wps_config_write_dev_sub_category(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+	return _wps_config_write_dev_category(wps->dev_category);
+}
+
+
+static int wps_config_parse_dev_oui(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (hexstr2bin(value, wps->dev_oui, SIZE_4_BYTES) ||
+	    value[SIZE_4_BYTES * 2] != '\0') {
+		wpa_printf(MSG_ERROR, "Line %d: Invalid Device OUI '%s'.",
+			   line, value);
+		return -1;
+	}
+
+	wpa_hexdump_key(MSG_MSGDUMP, "Device OUI", wps->dev_oui, SIZE_4_BYTES);
+	memcpy(&wps->prim_dev_type[2], wps->dev_oui, SIZE_4_BYTES);
+	return 0;
+}
+
+
+static char * wps_config_write_dev_oui(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	return wpa_config_write_string_hex(wps->dev_oui, SIZE_4_BYTES);
+}
+
+
+#ifdef WPS_OPT_UPNP
+static int wps_config_parse_upnp_iface(const struct parse_data *data,
+				struct wpa_ssid *ssid, int line,
+				const char *value)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (!value[0]) {
+		wpa_printf(MSG_ERROR, "Line %d: Invalid UPnP IFace '%s'.",
+			   line, value);
+		return -1;
+	}
+
+	wps->upnp_iface = os_strdup(value);
+	wpa_hexdump_ascii(MSG_MSGDUMP, "UPnP Iface", (u8 *)wps->upnp_iface, os_strlen(wps->upnp_iface));
+	return 0;
+}
+
+
+static char * wps_config_write_upnp_iface(const struct parse_data *data,
+				   struct wpa_ssid *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (wps->upnp_iface)
+		return wpa_config_write_string_ascii((u8 *)wps->upnp_iface, os_strlen(wps->upnp_iface));
+
+	return NULL;
+}
+#endif /* WPS_OPT_UPNP */
+
+
+/* Helper macros for network block parser */
+
+#ifdef OFFSET
+#undef OFFSET
+#endif /* OFFSET */
+/* OFFSET: Get offset of a variable within the wpa_ssid structure */
+#define OFFSET(v) ((void *) &((struct wps_config *) 0)->v)
+
+/* STR: Define a string variable for an ASCII string; f = field name */
+#define _STR(f) #f, wpa_config_parse_str, wpa_config_write_str, OFFSET(f)
+#define STR(f) _STR(f), NULL, NULL, NULL, 0
+#define STR_KEY(f) _STR(f), NULL, NULL, NULL, 1
+
+/* STR_LEN: Define a string variable with a separate variable for storing the
+ * data length. Unlike STR(), this can be used to store arbitrary binary data
+ * (i.e., even nul termination character). */
+#define _STR_LEN(f) _STR(f), OFFSET(f ## _len)
+#define STR_LEN(f) _STR_LEN(f), NULL, NULL, 0
+#define STR_LEN_KEY(f) _STR_LEN(f), NULL, NULL, 1
+
+/* STR_RANGE: Like STR_LEN(), but with minimum and maximum allowed length
+ * explicitly specified. */
+#define _STR_RANGE(f, min, max) _STR_LEN(f), (void *) (min), (void *) (max)
+#define STR_RANGE(f, min, max) _STR_RANGE(f, min, max), 0
+#define STR_RANGE_KEY(f, min, max) _STR_RANGE(f, min, max), 1
+
+#define _HEX(h,f) #f, wpa_config_parse_hex##h, wpa_config_write_hex##h, \
+	OFFSET(f), (void *) 0
+
+/* HEX: Define an hex variable */
+#define HEX8(f) _HEX(8, f), NULL, NULL, 0
+#define HEX16(f) _HEX(16, f), NULL, NULL, 0
+#define HEX32(f) _HEX(32, f), NULL, NULL, 0
+
+/* HEX_RANGE: Define an hex variable with allowed value range */
+#define HEX8_RANGE(f, min, max) _HEX(8, f), (void *) (min), (void *) (max), 0
+#define HEX16_RANGE(f, min, max) _HEX(16, f), (void *) (min), (void *) (max), 0
+#define HEX32_RANGE(f, min, max) _HEX(32, f), (void *) (min), (void *) (max), 0
+
+#define _INT(f) #f, wpa_config_parse_int, wpa_config_write_int, \
+	OFFSET(f), (void *) 0
+
+/* INT: Define an integer variable */
+#define INT(f) _INT(f), NULL, NULL, 0
+
+/* INT_RANGE: Define an integer variable with allowed value range */
+#define INT_RANGE(f, min, max) _INT(f), (void *) (min), (void *) (max), 0
+
+/* FUNC: Define a configuration variable that uses a custom function for
+ * parsing and writing the value. */
+#define _FUNC(f) #f, wps_config_parse_ ## f, wps_config_write_ ## f, \
+	NULL, NULL, NULL, NULL
+#define FUNC(f) _FUNC(f), 0
+#define FUNC_KEY(f) _FUNC(f), 1
+
+/*
+ * Table of network configuration variables. This table is used to parse each
+ * network configuration variable, e.g., each line in wpa_supplicant.conf file
+ * that is inside a network block.
+ *
+ * This table is generated using the helper macros defined above and with
+ * generous help from the C pre-processor. The field name is stored as a string
+ * into .name and for STR and INT types, the offset of the target buffer within
+ * struct wpa_ssid is stored in .param1. .param2 (if not NULL) is similar
+ * offset to the field containing the length of the configuration variable.
+ * .param3 and .param4 can be used to mark the allowed range (length for STR
+ * and value for INT).
+ *
+ * For each configuration line in wpa_supplicant.conf, the parser goes through
+ * this table and select the entry that matches with the field name. The parser
+ * function (.parser) is then called to parse the actual value of the field.
+ *
+ * This kind of mechanism makes it easy to add new configuration parameters,
+ * since only one line needs to be added into this table and into the
+ * struct wpa_ssid definition if the new variable is either a string or
+ * integer. More complex types will need to use their own parser and writer
+ * functions.
+ */
+static const struct parse_data wps_fields[] = {
+	{ HEX8(version) },
+	{ FUNC(uuid) },
+	{ HEX16(auth_type_flags) },
+	{ HEX16(encr_type_flags) },
+	{ HEX8(conn_type_flags) },
+	{ HEX16(config_methods) },
+	{ HEX8(wps_state) },
+	{ HEX8(rf_bands) },
+	{ STR_RANGE(manufacturer, 0, SIZE_64_BYTES) },
+	{ STR_RANGE(model_name, 0, SIZE_32_BYTES) },
+	{ STR_RANGE(model_number, 0, SIZE_32_BYTES) },
+	{ STR_RANGE(serial_number, 0, SIZE_32_BYTES) },
+	{ FUNC_KEY(dev_category) },
+	{ FUNC_KEY(dev_sub_category) },
+	{ FUNC_KEY(dev_oui) },
+	{ STR_RANGE(dev_name, 0, SIZE_32_BYTES) },
+	{ HEX32(os_version) }
+#ifdef WPS_OPT_UPNP
+	,
+	{ FUNC(upnp_iface) }
+#endif /* WPS_OPT_UPNP */
+};
+
+#undef OFFSET
+#undef _STR
+#undef STR
+#undef STR_KEY
+#undef _STR_LEN
+#undef STR_LEN
+#undef STR_LEN_KEY
+#undef _STR_RANGE
+#undef STR_RANGE
+#undef STR_RANGE_KEY
+#undef _INT
+#undef INT
+#undef INT_RANGE
+#undef _FUNC
+#undef FUNC
+#undef FUNC_KEY
+#define NUM_WPS_FIELDS (sizeof(ssid_fields) / sizeof(ssid_fields[0]))
+
+
 /**
+ * wps_config_set - Set a variable in wps configuration
+ * @wps: Pointer to wps configuration data
+ * @var: Variable name, e.g., "version"
+ * @value: Variable value
+ * @line: Line number in configuration file or 0 if not used
+ * Returns: 0 on success, -1 on failure
+ *
+ * This function can be used to set wps configuration variables based on
+ * both the configuration file and management interface input. The value
+ * parameter must be in the same format as the text-based configuration file is
+ * using. For example, strings are using double quotation marks.
+ */
+int wps_config_set(struct wps_config *wps, const char *var, const char *value,
+		   int line)
+{
+	size_t i;
+	int ret = 0;
+
+	if (wps == NULL || var == NULL || value == NULL)
+		return -1;
+
+	for (i = 0; i < NUM_WPS_FIELDS; i++) {
+		const struct parse_data *field = &wps_fields[i];
+		if (os_strcmp(var, field->name) != 0)
+			continue;
+
+		if (field->parser(field, (struct wpa_ssid *)wps, line, value)) {
+			if (line) {
+				wpa_printf(MSG_ERROR, "Line %d: failed to "
+					   "parse %s '%s'.", line, var, value);
+			}
+			ret = -1;
+		}
+		break;
+	}
+	if (i == NUM_WPS_FIELDS) {
+		if (line) {
+			wpa_printf(MSG_ERROR, "Line %d: unknown wps_property field "
+				   "'%s'.", line, var);
+		}
+		ret = -1;
+	}
+
+	return ret;
+}
+
+
+/**
+ * wps_config_get - Get a variable in wps configuration
+ * @wps: Pointer to wps configuration data
+ * @var: Variable name, e.g., "ssid"
+ * Returns: Value of the variable or %NULL on failure
+ *
+ * This function can be used to get wps configuration variables. The
+ * returned value is a copy of the configuration variable in text format, i.e,.
+ * the same format that the text-based configuration file and wps_config_set()
+ * are using for the value. The caller is responsible for freeing the returned
+ * value.
+ */
+char * wps_config_get(struct wps_config *wps, const char *var)
+{
+	size_t i;
+
+	if (wps == NULL || var == NULL)
+		return NULL;
+
+	for (i = 0; i < NUM_WPS_FIELDS; i++) {
+		const struct parse_data *field = &wps_fields[i];
+		if (os_strcmp(var, field->name) == 0)
+			return field->writer(field, (struct wpa_ssid *)wps);
+	}
+
+	return NULL;
+}
+
+
+/**
+ * wpa_config_get_wps_config - Get a wps configuration
+ * @config: Configuration data from wpa_config_read()
+ * Returns: Pointer to wps configuration data or %NULL if not found
+ */
+const struct wps_config * wpa_config_get_wps_config(struct wpa_config * config)
+{
+	return config?config->wps:0;
+}
+
+/**
+ * wpa_config_free_wps_config - Free wps configuration
+ * @wps: Pointer to wps configuration to be freed
+ */
+void wpa_config_free_wps_config(struct wps_config *wps)
+{
+	if (wps) {
+		if (wps->manufacturer)
+			os_free(wps->manufacturer);
+		if (wps->model_name)
+			os_free(wps->model_name);
+		if (wps->model_number)
+			os_free(wps->model_number);
+		if (wps->serial_number)
+			os_free(wps->serial_number);
+		if (wps->dev_name)
+			os_free(wps->dev_name);
+		if (wps->dh_secret)
+			wps_config_free_dh(&wps->dh_secret);
+		if (wps->config)
+			os_free(wps->config);
+#ifdef WPS_OPT_UPNP
+		if (wps->upnp_iface)
+			os_free(wps->upnp_iface);
+		if (wps->cur_upnp_device)
+			os_free(wps->cur_upnp_device);
+#endif /* WPS_OPT_UPNP */
+		os_free(wps);
+	}
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
+/**
  * wpa_config_alloc_empty - Allocate an empty configuration
  * @ctrl_interface: Control interface parameters, e.g., path to UNIX domain
  * socket
Index: driver_ndis.c
===================================================================
--- driver_ndis.c	(revision 1)
+++ driver_ndis.c	(revision 2)
@@ -744,6 +744,7 @@
 	/* wpa_hexdump(MSG_MSGDUMP, "IEs", pos, end - pos); */
 	while (pos + 1 < end && pos + 2 + pos[1] <= end) {
 		u8 ielen = 2 + pos[1];
+#ifndef EAP_WPS
 		if (ielen > SSID_MAX_WPA_IE_LEN) {
 			pos += ielen;
 			continue;
@@ -756,6 +757,26 @@
 			os_memcpy(res->rsn_ie, pos, ielen);
 			res->rsn_ie_len = ielen;
 		}
+#else /* EAP_WPS */
+		if (pos[0] == GENERIC_INFO_ELEM && pos[1] >= 4 &&
+			os_memcmp(pos + 2, "\x00\x50\xf2\x01", 4) == 0) {
+			if (ielen <= SSID_MAX_WPA_IE_LEN) {
+				os_memcpy(res->wpa_ie, pos, ielen);
+				res->wpa_ie_len = ielen;
+			}
+		} else if (pos[0] == RSN_INFO_ELEM) {
+			if (ielen <= SSID_MAX_WPA_IE_LEN) {
+				os_memcpy(res->rsn_ie, pos, ielen);
+				res->rsn_ie_len = ielen;
+			}
+		} else if (pos[0] == GENERIC_INFO_ELEM && pos[1] >= 4 &&
+			os_memcmp(pos + 2, "\x00\x50\xf2\x04", 4) == 0) {
+			if (ielen <= SSID_MAX_WPS_IE_LEN) {
+				os_memcpy(res->wps_ie, pos, ielen);
+				res->wps_ie_len = ielen;
+			}
+		}
+#endif /* EAP_WPS */
 		pos += ielen;
 	}
 }
@@ -2253,8 +2274,8 @@
 	}
 
 	len++;
-	memcpy(multi, drv->adapter_name, len * sizeof(TCHAR));
-	memcpy(&multi[len], TEXT("NDISUIO\0"), 9 * sizeof(TCHAR));
+	os_memcpy(multi, drv->adapter_name, len * sizeof(TCHAR));
+	os_memcpy(&multi[len], TEXT("NDISUIO\0"), 9 * sizeof(TCHAR));
 	len += 9;
 
 	if (!DeviceIoControl(ndis, IOCTL_NDIS_REBIND_ADAPTER,
Index: config.h
===================================================================
--- config.h	(revision 1)
+++ config.h	(revision 2)
@@ -21,6 +21,12 @@
 
 #include "config_ssid.h"
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+struct wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 /**
  * struct wpa_config_blob - Named configuration blob
  *
@@ -270,6 +276,15 @@
 	 * blobs - Configuration blobs
 	 */
 	struct wpa_config_blob *blobs;
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	/**
+	 * wps - WPS configuration
+	 */
+	struct wps_config *wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
 
 
@@ -295,6 +310,16 @@
 			 struct wpa_config_blob *blob);
 void wpa_config_free_blob(struct wpa_config_blob *blob);
 int wpa_config_remove_blob(struct wpa_config *config, const char *name);
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+int wps_config_set(struct wps_config *wps, const char *var, const char *value,
+		   int line);
+char * wps_config_get(struct wps_config *wps, const char *var);
+
+const struct wps_config * wpa_config_get_wps_config(struct wpa_config * config);
+void wpa_config_free_wps_config(struct wps_config *wps);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 struct wpa_config * wpa_config_alloc_empty(const char *ctrl_interface,
 					   const char *driver_param);
 #ifndef CONFIG_NO_STDOUT_DEBUG
Index: eap_i.h
===================================================================
--- eap_i.h	(revision 1)
+++ eap_i.h	(revision 2)
@@ -353,4 +353,10 @@
 			       u8 **payload);
 void eap_notify_pending(struct eap_sm *sm);
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+const struct wps_config *eap_get_wps_config(struct eap_sm *sm);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 #endif /* EAP_I_H */
Index: Makefile
===================================================================
--- Makefile	(revision 1)
+++ Makefile	(revision 2)
@@ -417,6 +417,39 @@
 CONFIG_IEEE8021X_EAPOL=y
 endif
 
+ifdef CONFIG_EAP_WPS
+CFLAGS += -DEAP_WPS
+OBJS += wps_parser.o
+ifdef CONFIG_DRIVER_MADWIFI
+CFLAGS += -DATH_WPS_IE
+endif #CONFIG_DRIVER_MADWIFI
+ifdef CONFIG_USE_INTEL_SDK
+CFLAGS += -DUSE_INTEL_SDK
+OBJS += intel_eap_wps.o \
+		intel_udplib.o \
+		intel_ie_wps.o
+ifdef DIFF_PORT_FROM_HOSTAPD
+CFLAGS += -DDIFF_PORT_FROM_HOSTAPD
+endif #DIFF_PORT_FROM_HOSTAPD
+else #CONFIG_USE_INTEL_SDK
+OBJS += eap_wps.o wps_config.o
+ifdef CONFIG_WPS_OPT_UPNP
+CFLAGS += -DWPS_OPT_UPNP
+OBJS += upnp_wps_common.o \
+		upnp_wps_ctrlpt.o \
+		wps_opt_upnp.o
+endif #CONFIG_WPS_OPT_UPNP
+ifdef CONFIG_WPS_OPT_NFC
+CFLAGS += -DWPS_OPT_NFC
+OBJS += wps_opt_nfc.o
+endif #CONFIG_WPS_OPT_NFC
+endif #CONFIG_USE_INTEL_SDK
+endif #CONFIG_EAP_WPS
+
+ifdef MODIFIED_BY_SONY
+CFLAGS += -DMODIFIED_BY_SONY
+endif
+
 ifdef CONFIG_IEEE8021X_EAPOL
 # IEEE 802.1X/EAPOL state machines (e.g., for RADIUS authentication)
 CFLAGS += -DIEEE8021X_EAPOL
Index: driver_wext.c
===================================================================
--- driver_wext.c	(revision 1)
+++ driver_wext.c	(revision 2)
@@ -1211,6 +1211,10 @@
 			break;
 		case SIOCGIWFREQ:
 			if (ap_num < max_size) {
+#ifdef MODIFIED_BY_SONY
+				if (iwe->u.freq.m > 1000) {
+					/* freq structure means frequency */
+#endif	/* MODIFIED_BY_SONY */
 				int divi = 1000000, i;
 				if (iwe->u.freq.e == 0) {
 					/*
@@ -1242,13 +1246,31 @@
 				for (i = 0; i < iwe->u.freq.e; i++)
 					divi /= 10;
 				results[ap_num].freq = iwe->u.freq.m / divi;
+#ifdef MODIFIED_BY_SONY
+				} else {
+					/* freq structure means channel */
+					u32 freq = 0, channel = iwe->u.freq.m;
+					if (channel < 34) {
+						freq = 2412 + 5 * (channel - 1);
+					} else if (channel > 0) {
+						freq = 5170 + 5 * (channel - 34);
+					}
+					results[ap_num].freq = freq;
+				}
+#endif	/* MODIFIED_BY_SONY */
 			}
 			break;
 		case IWEVQUAL:
 			if (ap_num < max_size) {
+#ifndef MODIFIED_BY_SONY
 				results[ap_num].qual = iwe->u.qual.qual;
 				results[ap_num].noise = iwe->u.qual.noise;
 				results[ap_num].level = iwe->u.qual.level;
+#else	/* MODIFIED_BY_SONY */
+				results[ap_num].qual = (s8)iwe->u.qual.qual;
+				results[ap_num].noise = (s8)iwe->u.qual.noise;
+				results[ap_num].level = (s8)iwe->u.qual.level;
+#endif	/* MODIFIED_BY_SONY */
 			}
 			break;
 		case SIOCGIWENCODE:
@@ -1287,25 +1309,50 @@
 			while (gpos + 1 < gend &&
 			       gpos + 2 + (u8) gpos[1] <= gend) {
 				u8 ie = gpos[0], ielen = gpos[1] + 2;
+#ifndef EAP_WPS
 				if (ielen > SSID_MAX_WPA_IE_LEN) {
 					gpos += ielen;
 					continue;
 				}
+#endif /* EAP_WPS */
 				switch (ie) {
 				case GENERIC_INFO_ELEM:
+#ifndef EAP_WPS
 					if (ielen < 2 + 4 ||
 					    os_memcmp(&gpos[2],
 						      "\x00\x50\xf2\x01", 4) !=
 					    0)
 						break;
+#else /* EAP_WPS */
+					if (ielen >= 2 + 4 &&
+					    os_memcmp(&gpos[2],
+						   "\x00\x50\xf2\x01", 4) == 0 &&
+						   ielen <= SSID_MAX_WPA_IE_LEN) {
+#endif /* EAP_WPS */
 					os_memcpy(results[ap_num].wpa_ie, gpos,
 						  ielen);
 					results[ap_num].wpa_ie_len = ielen;
+#ifdef EAP_WPS
+					} else if (ielen >= 2 + 4 &&
+					    os_memcmp(&gpos[2],
+						   "\x00\x50\xf2\x04", 4) == 0 /* &&
+						   ielen <= SSID_MAX_WPS_IE_LEN */) {
+						os_memcpy(results[ap_num].wps_ie, gpos,
+						       ielen);
+						results[ap_num].wps_ie_len = ielen;
+					}
+#endif /* EAP_WPS */
 					break;
 				case RSN_INFO_ELEM:
+#ifdef EAP_WPS
+					if (ielen <= SSID_MAX_WPA_IE_LEN) {
+#endif /* EAP_WPS */
 					os_memcpy(results[ap_num].rsn_ie, gpos,
 						  ielen);
 					results[ap_num].rsn_ie_len = ielen;
+#ifdef EAP_WPS
+					}
+#endif /* EAP_WPS */
 					break;
 				}
 				gpos += ielen;
@@ -1352,6 +1399,27 @@
 					   bytes);
 				results[ap_num].rsn_ie_len = bytes;
 			}
+#ifdef EAP_WPS
+			else if (clen > 7 &&
+				   os_strncmp(custom, "wps_ie=", 7) == 0 &&
+				   ap_num < max_size) {
+				char *spos;
+				int bytes;
+				spos = custom + 7;
+				bytes = custom + clen - spos;
+				if (bytes & 1)
+					break;
+				bytes /= 2;
+				if (bytes > SSID_MAX_WPS_IE_LEN) {
+					wpa_printf(MSG_INFO, "Too long WPS IE "
+						   "(%d)", bytes);
+					break;
+				}
+				hexstr2bin(spos, results[ap_num].wpa_ie,
+					   bytes);
+				results[ap_num].wpa_ie_len = bytes;
+			}
+#endif /* EAP_WPS */
 			break;
 		}
 
@@ -1452,6 +1520,7 @@
 }
 
 
+#ifndef MODIFIED_BY_SONY
 static int wpa_driver_wext_set_key_ext(void *priv, wpa_alg alg,
 				       const u8 *addr, int key_idx,
 				       int set_tx, const u8 *seq,
@@ -1535,6 +1604,7 @@
 	os_free(ext);
 	return ret;
 }
+#endif /* MODIFIED_BY_SONY */
 
 
 /**
@@ -1577,6 +1647,7 @@
 		   __FUNCTION__, alg, key_idx, set_tx,
 		   (unsigned long) seq_len, (unsigned long) key_len);
 
+#ifndef MODIFIED_BY_SONY
 	ret = wpa_driver_wext_set_key_ext(drv, alg, addr, key_idx, set_tx,
 					  seq, seq_len, key, key_len);
 	if (ret == 0)
@@ -1592,6 +1663,7 @@
 			   "SIOCSIWENCODEEXT");
 		return ret;
 	}
+#endif /* MODIFIED_BY_SONY */
 
 	os_memset(&iwr, 0, sizeof(iwr));
 	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
@@ -1742,7 +1814,11 @@
 }
 
 
+#ifndef MODIFIED_BY_SONY
 static int
+#else /* MODIFIED_BY_SONY */
+int
+#endif /* MODIFIED_BY_SONY */
 wpa_driver_wext_auth_alg_fallback(struct wpa_driver_wext_data *drv,
 				  struct wpa_driver_associate_params *params)
 {
@@ -1759,6 +1835,10 @@
 	iwr.u.encoding.pointer = (caddr_t) NULL;
 	iwr.u.encoding.length = 0;
 
+#ifdef MODIFIED_BY_SONY
+	iwr.u.data.flags |= IW_ENCODE_NOKEY;
+#endif /* MODIFIED_BY_SONY */
+
 	/*
 	 * Note: IW_ENCODE_{OPEN,RESTRICTED} can be interpreted to mean two
 	 * different things. Here they are used to indicate Open System vs.
@@ -1769,12 +1849,24 @@
 	 */
 
 	if (!drv->use_crypt) {
+#ifndef MODIFIED_BY_SONY
 		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
+#else /* MODIFIED_BY_SONY */
+		iwr.u.data.flags |= IW_ENCODE_DISABLED;
+#endif /* MODIFIED_BY_SONY */
 	} else {
 		if (params->auth_alg & AUTH_ALG_OPEN_SYSTEM)
+#ifndef MODIFIED_BY_SONY
 			iwr.u.encoding.flags |= IW_ENCODE_OPEN;
+#else /* MODIFIED_BY_SONY */
+			iwr.u.data.flags |= IW_ENCODE_OPEN;
+#endif /* MODIFIED_BY_SONY */
 		if (params->auth_alg & AUTH_ALG_SHARED_KEY)
+#ifndef MODIFIED_BY_SONY
 			iwr.u.encoding.flags |= IW_ENCODE_RESTRICTED;
+#else /* MODIFIED_BY_SONY */
+			iwr.u.data.flags |= IW_ENCODE_RESTRICTED;
+#endif /* MODIFIED_BY_SONY */
 	}
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
Index: upnp_wps_ctrlpt.c
===================================================================
--- upnp_wps_ctrlpt.c	(revision 0)
+++ upnp_wps_ctrlpt.c	(revision 2)
@@ -0,0 +1,1755 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_ctrlpt.c
+//  Description: EAP-WPS UPnP control-point source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include <upnp/ithread.h>
+#include <upnp/upnp.h>
+#include <upnp/upnptools.h>
+#include <upnp/ixml.h>
+
+#include "common.h"
+#include "upnp_wps_common.h"
+#include "upnp_wps_ctrlpt.h"
+#include "base64.h"
+#include <stdlib.h>
+
+#include <sys/ioctl.h>
+#include <linux/if.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <linux/route.h>
+#include <errno.h>
+
+#define WPS_MAXVARS		4
+#define WPS_MAX_VAL_LEN	255
+#define DEFAULT_TIMEOUT	1801
+
+#define TIMER_LOOP_INC	30
+
+struct wps_service {
+	char *service_id;
+	char *service_type;
+	char *scpd_url;
+	char *control_url;
+	char *event_url;
+	char *var[WPS_MAXVARS];
+	char sid[sizeof(Upnp_SID) + 1];
+};
+
+struct wps_device{
+	char *friendly_name;
+	char *manufacturer;
+	char *manufacturer_url;
+	char *model_desc;
+	char *model_name;
+	char *model_number;
+	char *model_url;
+	char *serial_number;
+	char *udn;
+	char *upc;
+	char *pres_url;
+	int advr_timeout;
+	struct wps_service service;
+};
+
+struct wps_device_node {
+	struct wps_device device;
+	struct wps_device_node *next;
+};
+
+struct upnp_wps_ctrlpt_sm {
+	struct upnp_wps_ctrlpt_ctx *ctx;
+	void *priv;
+	int initialized;
+	struct wps_device_node *device_list;
+	ithread_mutex_t mutex_devlist;
+	int mutex_initialized;
+	UpnpClient_Handle ctrlpt_handle;
+	ithread_t timer_thread;
+	int quit_timer_thread;
+};
+
+
+static const char *wps_device_type = "urn:schemas-wifialliance-org:device:WFADevice:1";
+static const char *wps_service_type = "urn:schemas-wifialliance-org:service:WFAWLANConfig:1";
+enum WPS_EVENT {
+	WPS_EVENT_WLANEVENT = 0,
+	WPS_EVENT_APSTATUS,
+	WPS_EVENT_STASTATUS
+};
+static const char *wps_event_name[] = {
+	"WLANEvent", "APStatus", "STAStatus", 0
+};
+
+struct upnp_wps_action_callback_cookie {
+	struct upnp_wps_ctrlpt_sm *sm;
+	int (*callback)(struct upnp_wps_ctrlpt_sm *sm,
+					char *control_url,
+					IXML_Document *doc);
+};
+
+struct upnp_wps_get_var_callback_cookie {
+	struct upnp_wps_ctrlpt_sm *sm;
+	int device_no;
+	int (*callback)(struct upnp_wps_ctrlpt_sm *sm,
+					char *control_url,
+					char *var, DOMString val);
+};
+
+
+struct upnp_wps_ctrlpt_sm *
+upnp_wps_ctrlpt_init(struct upnp_wps_ctrlpt_ctx *ctx, void *priv)
+{
+	struct upnp_wps_ctrlpt_sm *sm = 0;
+	do {
+		sm = wpa_zalloc(sizeof(*sm));
+		if (!sm)
+			break;
+		sm->ctx = ctx;
+		sm->priv = priv;
+		sm->ctrlpt_handle = -1;
+		sm->timer_thread = -1;
+	} while (0);
+
+	return sm;
+}
+
+
+void
+upnp_wps_ctrlpt_deinit(struct upnp_wps_ctrlpt_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+		upnp_wps_ctrlpt_stop(sm);
+
+		free(sm->ctx);
+		free(sm);
+	} while (0);
+}
+
+static int
+upnp_wps_ctrlpt_delete_node(struct upnp_wps_ctrlpt_sm *sm,
+							struct wps_device_node *node)
+{
+	int ret = -1;
+	int res;
+	int vars;
+
+	do {
+		if (!sm || !node)
+			break;
+
+		res = UpnpUnSubscribe(sm->ctrlpt_handle, node->device.service.sid);
+
+		if (node->device.friendly_name)
+			free(node->device.friendly_name);
+		if (node->device.manufacturer)
+			free(node->device.manufacturer);
+		if (node->device.manufacturer_url)
+			free(node->device.manufacturer_url);
+		if (node->device.model_desc)
+			free(node->device.model_desc);
+		if (node->device.model_name)
+			free(node->device.model_name);
+		if (node->device.model_number)
+			free(node->device.model_number);
+		if (node->device.model_url)
+			free(node->device.model_url);
+		if (node->device.serial_number)
+			free(node->device.serial_number);
+		if (node->device.udn)
+			free(node->device.udn);
+		if (node->device.upc)
+			free(node->device.upc);
+		if (node->device.pres_url)
+			free(node->device.pres_url);
+
+		if (node->device.service.service_id)
+			free(node->device.service.service_id);
+		if (node->device.service.service_type)
+			free(node->device.service.service_type);
+		if (node->device.service.scpd_url)
+			free(node->device.service.scpd_url);
+		if (node->device.service.control_url)
+			free(node->device.service.control_url);
+		if (node->device.service.event_url)
+			free(node->device.service.event_url);
+
+		for (vars = 0; vars < WPS_MAXVARS; vars++) {
+			if (node->device.service.var[vars])
+				free(node->device.service.var[vars]);
+		}
+
+		free(node);
+		node = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_remove_device(struct upnp_wps_ctrlpt_sm *sm,
+							  char *udn)
+{
+	int ret = -1;
+	struct wps_device_node *cur, *prev = 0;
+
+	do {
+		if (!udn)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		cur = sm->device_list;
+		while (cur) {
+			if (!os_strcmp(cur->device.udn, udn)) {
+				if (cur == sm->device_list)
+					sm->device_list = cur->next;
+				else if (prev)
+					prev->next = cur->next;
+				else
+					break;
+				upnp_wps_ctrlpt_delete_node(sm, cur);
+				break;
+			}
+			prev = cur;
+			cur = cur->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_remove_all_device(struct upnp_wps_ctrlpt_sm *sm)
+{
+	struct wps_device_node *cur, *next;
+
+	ithread_mutex_lock(&sm->mutex_devlist);
+
+	cur = sm->device_list;
+	while (cur) {
+		next = cur->next;
+		upnp_wps_ctrlpt_delete_node(sm, cur);
+		cur = next;
+	}
+	sm->device_list = 0;
+
+	ithread_mutex_unlock(&sm->mutex_devlist);
+	return 0;
+}
+
+
+int add_ssdp_network(char *net_if)
+{
+#define SSDP_TARGET		"239.0.0.0"
+#define SSDP_NETMASK	"255.0.0.0"
+	int ret = -1;
+	SOCKET sock = -1;
+	struct rtentry rt;
+	struct sockaddr_in *sin;
+
+	do {
+		if (!net_if)
+			break;
+
+		memset(&rt, 0, sizeof(rt));
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+		if (-1 == sock)
+			break;
+
+		rt.rt_dev = net_if;
+		sin = (struct sockaddr_in *)&rt.rt_dst;
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0;
+		sin->sin_addr.s_addr = inet_addr(SSDP_TARGET);
+		sin = (struct sockaddr_in *)&rt.rt_genmask;
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0;
+		sin->sin_addr.s_addr = inet_addr(SSDP_NETMASK);
+		rt.rt_flags = RTF_UP;
+		if (ioctl(sock, SIOCADDRT, &rt) < 0) {
+			if (errno != EEXIST)
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (-1 != sock)
+		close(sock);
+
+	return ret;
+#undef SSDP_TARGET
+#undef SSDP_NETMASK
+}
+
+
+int get_ip_address(char *net_if, char **ipaddr)
+{
+#define MAX_INTERFACES 256
+	int ret = -1;
+	char buf[MAX_INTERFACES * sizeof(struct ifreq)];
+	struct ifconf conf;
+	struct ifreq *req;
+	struct sockaddr_in sock_addr;
+	int sock = -1;
+	int i;
+
+	do {
+		if (!ipaddr)
+			break;
+		*ipaddr = 0;
+
+		if (!net_if)
+			break;
+
+		if(0 > (sock = socket(AF_INET, SOCK_DGRAM, 0)))
+			break;
+
+		conf.ifc_len = sizeof(buf);
+		conf.ifc_ifcu.ifcu_buf = (caddr_t)buf;
+		if (0 > ioctl(sock, SIOCGIFCONF, &conf))
+			break;
+
+		for( i = 0; i < conf.ifc_len; ) {
+			req = (struct ifreq *)((caddr_t)conf.ifc_req + i);
+			i += sizeof(*req);
+
+			if (AF_INET == req->ifr_addr.sa_family) {
+				if (!os_strcmp(net_if, req->ifr_name)) {
+					size_t len;
+					os_memcpy(&sock_addr, &req->ifr_addr, sizeof(req->ifr_addr));
+					len = os_strlen(inet_ntoa(sock_addr.sin_addr)) + 1;
+					*ipaddr = wpa_zalloc(len);
+					if (!*ipaddr)
+						break;
+					os_snprintf(*ipaddr, len, "%s", inet_ntoa(sock_addr.sin_addr));
+					ret = 0;
+					break;
+				}
+			}
+		}
+	} while (0);
+
+	if (0 <= sock)
+		close(sock);
+
+	return ret;
+#undef MAX_INTERFACES
+}
+
+
+int get_mac_from_ip(char *ipaddr, char mac[18])
+{
+#define MAX_INTERFACES 256
+	int ret = -1;
+	char buf[MAX_INTERFACES * sizeof(struct ifreq)];
+	struct ifconf conf;
+	struct ifreq *req;
+	struct sockaddr_in sock_addr;
+	int sock = -1;
+	int i;
+
+	do {
+		if(0 > (sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)))
+			break;
+
+		conf.ifc_len = sizeof(buf);
+		conf.ifc_ifcu.ifcu_buf = (caddr_t)buf;
+		if (0 > ioctl(sock, SIOCGIFCONF, &conf))
+			break;
+
+		for( i = 0; i < conf.ifc_len; ) {
+			req = (struct ifreq *)((caddr_t)conf.ifc_req + i);
+			i += sizeof(*req);
+
+			if (AF_INET == req->ifr_addr.sa_family) {
+				os_memcpy(&sock_addr, &req->ifr_addr, sizeof(req->ifr_addr));
+				if (!os_strcmp(ipaddr, inet_ntoa(sock_addr.sin_addr))) {
+					os_snprintf(mac, 18, "%02X:%02X:%02X:%02X:%02X:%02X",
+					(u8)(req->ifr_hwaddr.sa_data[0]),
+					(u8)(req->ifr_hwaddr.sa_data[1]),
+					(u8)(req->ifr_hwaddr.sa_data[2]),
+					(u8)(req->ifr_hwaddr.sa_data[3]),
+					(u8)(req->ifr_hwaddr.sa_data[4]),
+					(u8)(req->ifr_hwaddr.sa_data[5]));
+					ret = 0;
+					break;
+				}
+			}
+		}
+	} while (0);
+
+	if (0 <= sock)
+		close(sock);
+
+	return ret;
+}
+
+int
+upnp_wps_ctrlpt_get_scan_results(struct upnp_wps_ctrlpt_sm *sm,
+								 struct upnp_wps_ctrlpt_device_list **list)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	struct upnp_wps_ctrlpt_device_list *cur = 0;
+
+	do {
+		if (!sm || !list)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		*list = 0;
+		node = sm->device_list;
+		while (node) {
+			if (!*list) {
+				*list = (struct upnp_wps_ctrlpt_device_list *)
+						wpa_zalloc(sizeof(**list));
+				if (!*list)
+					break;
+				cur = *list;
+			} else if (cur) {
+				cur->next = (struct upnp_wps_ctrlpt_device_list *)
+						wpa_zalloc(sizeof(*cur));
+				if (!cur->next)
+					break;
+				cur = cur->next;
+			} else
+				break;
+
+			os_snprintf(cur->device.manufacturer,
+						sizeof(cur->device.manufacturer),
+						"%s", node->device.manufacturer);
+			os_snprintf(cur->device.model_name,
+						sizeof(cur->device.model_name),
+						"%s", node->device.model_name);
+			os_snprintf(cur->device.model_number,
+						sizeof(cur->device.model_number),
+						"%s", node->device.model_number);
+			os_snprintf(cur->device.serial_number,
+						sizeof(cur->device.serial_number),
+						"%s", node->device.serial_number);
+			os_snprintf(cur->device.udn,
+						sizeof(cur->device.udn),
+						"%s", node->device.udn);
+			os_snprintf(cur->device.control_url,
+						sizeof(cur->device.control_url),
+						"%s", node->device.service.control_url);
+			node = node->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+
+		if (node)
+			break;
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (list && *list) {
+			upnp_wps_ctrlpt_destroy_device_list(*list);
+			*list = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+void
+upnp_wps_ctrlpt_destroy_device_list(struct upnp_wps_ctrlpt_device_list *list)
+{
+	struct upnp_wps_ctrlpt_device_list *device, *next;
+	do {
+		if (!list)
+			break;
+
+		device = list;
+		while (device) {
+			next = device->next;
+			free(device);
+			device = next;
+		}
+	} while (0);
+}
+
+
+int
+upnp_wps_ctrlpt_refresh_device(struct upnp_wps_ctrlpt_sm *sm, int timeout)
+{
+	int ret = -1;
+
+	upnp_wps_ctrlpt_remove_all_device(sm);
+
+	do {
+		if (!timeout)
+			timeout = TIMER_LOOP_INC; 
+
+		if (UPNP_E_SUCCESS != UpnpSearchAsync(sm->ctrlpt_handle,
+											  timeout,
+											  wps_device_type, sm))
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_encode_base64(u8 *data, size_t data_len,
+							  char **encoded, size_t *encoded_len)
+{
+	int ret = -1;
+
+	do {
+		if (!data || !encoded || !encoded_len)
+			break;
+		*encoded = 0;
+		*encoded_len = 0;
+
+		*encoded = (char *)base64_encode(
+								(const unsigned char *)data,
+								data_len, encoded_len);
+		if (!*encoded)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (encoded && *encoded) {
+			free(*encoded);
+			*encoded = 0;
+		}
+		if (encoded_len)
+			*encoded_len = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_decode_base64(char *data, size_t data_len,
+								  u8 **decoded, size_t *decoded_len)
+{
+	int ret = -1;
+
+	do {
+		if (!data || !decoded || !decoded_len)
+			break;
+		*decoded = 0;
+		*decoded_len = 0;
+
+		*decoded = base64_decode((const unsigned char *)data,
+								 data_len, decoded_len);
+		if (!*decoded)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (decoded && *decoded) {
+			free(*decoded);
+			*decoded = 0;
+		}
+		if (decoded_len)
+			*decoded_len = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_get_device(struct upnp_wps_ctrlpt_sm *sm,
+						   char *control_url,
+						   struct wps_device_node **node)
+{
+	int ret = -1;
+	struct wps_device_node *next;
+
+	do {
+		if (!sm || !control_url || !node)
+			break;
+
+		*node = 0;
+		next = sm->device_list;
+		while (next) {
+			if (!os_strcmp(next->device.service.control_url, control_url)) {
+				*node = next;
+				break;
+			}
+			next = next->next;
+		}
+
+		if (!*node)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (node && *node)
+			*node = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_add_device(struct upnp_wps_ctrlpt_sm *sm,
+						   IXML_Document *desc_doc,
+						   char *location, int expires )
+{
+	int ret = -1;
+	struct wps_device_node *node = 0, *next;
+	char pres_url[250] = {0};
+	char *url_base = 0, *device_type = 0, *friendly_name = 0,
+		 *manufacturer = 0, *manufacturer_url = 0,
+		 *model_desc = 0, *model_name = 0, *model_number = 0,
+		 *model_url = 0, *serial_number = 0, *udn = 0, *upc = 0,
+		 *rel_url = 0;
+	char *service_id = 0,
+		 *scpd_url = 0, *control_url = 0, *event_url = 0;
+	int timeout = DEFAULT_TIMEOUT;
+	Upnp_SID event_sid;
+	int vars;
+
+	if (!sm)
+		return ret;
+
+	ithread_mutex_lock(&sm->mutex_devlist);
+
+	do {
+		upnp_get_first_document_item(desc_doc, "URLBase", &url_base);
+		upnp_get_first_document_item(desc_doc, "deviceType", &device_type);
+		upnp_get_first_document_item(desc_doc, "friendlyName", &friendly_name);
+		upnp_get_first_document_item(desc_doc, "manufacturer", &manufacturer);
+		upnp_get_first_document_item(desc_doc, "manufacturerURL", &manufacturer_url);
+		upnp_get_first_document_item(desc_doc, "modelDescription", &model_desc);
+		upnp_get_first_document_item(desc_doc, "modelName", &model_name);
+		upnp_get_first_document_item(desc_doc, "modelNumber", &model_number);
+		upnp_get_first_document_item(desc_doc, "modelURL", &model_url);
+		upnp_get_first_document_item(desc_doc, "serialNumber", &serial_number);
+		upnp_get_first_document_item(desc_doc, "UDN", &udn);
+		upnp_get_first_document_item(desc_doc, "UPC", &upc);
+		upnp_get_first_document_item(desc_doc, "presentationURL", &rel_url);
+
+		if (rel_url) {
+			if (UPNP_E_SUCCESS != UpnpResolveURL((url_base?url_base:location), rel_url, pres_url))
+				break;
+		}
+
+		if (os_strcmp(device_type, wps_device_type))
+			break;
+
+		node = sm->device_list;
+		while (node) {
+			if (!os_strcmp(node->device.udn, udn))
+				break;
+			node = node->next;
+		}
+
+		if (node) {
+			node->device.advr_timeout = expires;
+		} else {
+			if (!upnp_find_service(desc_doc, location, (char *)wps_service_type,
+				&service_id, &scpd_url, &control_url, &event_url))
+				break;
+
+			if (UPNP_E_SUCCESS != UpnpSubscribe(sm->ctrlpt_handle, event_url,
+												&timeout, event_sid))
+				break;
+
+			node = (struct wps_device_node *)wpa_zalloc(sizeof(*node));
+			if (friendly_name) {
+				node->device.friendly_name =
+						(char *)wpa_zalloc(os_strlen(friendly_name) + 1);
+				if (!node->device.friendly_name)
+					break;
+				strcpy(node->device.friendly_name, friendly_name);
+			}
+			if (manufacturer) {
+				node->device.manufacturer =
+						(char *)wpa_zalloc(os_strlen(manufacturer) + 1);
+				if (!node->device.manufacturer)
+					break;
+				strcpy(node->device.manufacturer, manufacturer);
+			}
+			if (manufacturer_url) {
+				node->device.manufacturer_url =
+					(char *)wpa_zalloc(os_strlen(manufacturer_url) + 1);
+				if (!node->device.manufacturer_url)
+					break;
+				strcpy(node->device.manufacturer_url, manufacturer_url);
+			}
+			if (model_desc) {
+				node->device.model_desc =
+						(char *)wpa_zalloc(os_strlen(model_desc) + 1);
+				if (!node->device.model_desc)
+					break;
+				strcpy(node->device.model_desc, model_desc);
+			}
+			if (model_name) {
+				node->device.model_name =
+						(char *)wpa_zalloc(os_strlen(model_name) + 1);
+				if (!node->device.model_name)
+					break;
+				strcpy(node->device.model_name, model_name);
+			}
+			if (model_number) {
+				node->device.model_number =
+						(char *)wpa_zalloc(os_strlen(model_number) + 1);
+				if (!node->device.model_number)
+					break;
+				strcpy(node->device.model_number, model_number);
+			}
+			if (model_url) {
+				node->device.model_url =
+						(char *)wpa_zalloc(os_strlen(model_url) + 1);
+				if (!node->device.model_url)
+					break;
+				strcpy(node->device.model_url, model_url);
+			}
+			if (serial_number) {
+				node->device.serial_number =
+						(char *)wpa_zalloc(os_strlen(serial_number) + 1);
+				if (!node->device.serial_number)
+					break;
+				strcpy(node->device.serial_number, serial_number);
+			}
+			if (udn) {
+				node->device.udn =
+						(char *)wpa_zalloc(os_strlen(udn) + 1);
+				if (!node->device.udn)
+					break;
+				strcpy(node->device.udn, udn);
+			}
+			if (upc) {
+				node->device.upc =
+						(char *)wpa_zalloc(os_strlen(upc) + 1);
+				if (!node->device.upc)
+					break;
+				strcpy(node->device.upc, upc);
+			}
+			if (rel_url) {
+				node->device.pres_url =
+						(char *)wpa_zalloc(os_strlen(pres_url) + 1);
+				if (!node->device.pres_url)
+					break;
+				strcpy(node->device.pres_url, pres_url);
+			}
+			node->device.advr_timeout = expires;
+
+			node->device.service.service_id =
+					(char *)wpa_zalloc(os_strlen(service_id) + 1);
+			if (!node->device.service.service_id)
+				break;
+			strcpy(node->device.service.service_id, service_id);
+			node->device.service.service_type =
+					(char *)wpa_zalloc(os_strlen(wps_service_type) + 1);
+			if (!node->device.service.service_type)
+				break;
+			strcpy(node->device.service.service_type, wps_service_type);
+			if (scpd_url) {
+				node->device.service.scpd_url =
+						(char *)wpa_zalloc(os_strlen(scpd_url) + 1);
+				if (!node->device.service.scpd_url)
+					break;
+				strcpy(node->device.service.scpd_url, scpd_url);
+			}
+			if (control_url) {
+				node->device.service.control_url =
+						(char *)wpa_zalloc(os_strlen(control_url) + 1);
+				if (!node->device.service.control_url)
+					break;
+				strcpy(node->device.service.control_url, control_url);
+			}
+			if (event_url) {
+				node->device.service.event_url =
+						(char *)wpa_zalloc(os_strlen(event_url) + 1);
+				if (!node->device.service.event_url)
+					break;
+				strcpy(node->device.service.event_url, event_url);
+			}
+			os_memcpy(node->device.service.sid, event_sid, sizeof(Upnp_SID));
+
+			for (vars = 0; vars < WPS_MAXVARS; vars++)
+				node->device.service.var[vars] = (char *)wpa_zalloc(WPS_MAX_VAL_LEN);
+
+			if (sm->device_list) {
+				next = sm->device_list;
+				while(next->next)
+					next = next->next;
+				next->next = node;
+			} else
+				sm->device_list = node;
+		}
+		ret = 0;
+    } while (0);
+
+	if (url_base) free(url_base);
+	if (device_type) free(device_type);
+	if (friendly_name) free(friendly_name);
+	if (manufacturer) free(manufacturer);
+	if (manufacturer_url) free(manufacturer_url);
+	if (model_desc) free(model_desc);
+	if (model_name) free(model_name);
+	if (model_number) free(model_number);
+	if (model_url) free(model_url);
+	if (serial_number) free(serial_number);
+	if (udn) free(udn);
+	if (upc) free(upc);
+	if (rel_url) free(rel_url);
+	if (service_id) free(service_id);
+	if (scpd_url) free(scpd_url);
+	if (control_url) free(control_url);
+	if (event_url) free(event_url);
+	if (ret) {
+		if (node)
+			upnp_wps_ctrlpt_delete_node(sm, node);
+	}
+	ithread_mutex_unlock(&sm->mutex_devlist);
+
+	return ret;
+}
+
+
+static void
+upnp_wps_ctrlpt_handle_action_complete(char *control_url,
+									   IXML_Document *doc,
+									   struct upnp_wps_action_callback_cookie *cb_cookie)
+{
+	struct upnp_wps_ctrlpt_sm *sm;
+	struct wps_device_node *node;
+	do {
+		if (!control_url || !doc || !cb_cookie)
+			break;
+		sm = cb_cookie->sm;
+		if (!sm)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		node = sm->device_list;
+		while (node) {
+			if (!os_strcmp(node->device.service.control_url, control_url)) {
+				if (cb_cookie->callback)
+					cb_cookie->callback(sm, control_url, doc);
+				break;
+			}
+			node = node->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+	} while (0);
+
+	if (cb_cookie)
+		free(cb_cookie);
+}
+
+
+static void
+upnp_wps_ctrlpt_handle_get_var_complete(char *control_url,
+										char *var,
+										DOMString val,
+										struct upnp_wps_get_var_callback_cookie *cb_cookie)
+{
+	struct upnp_wps_ctrlpt_sm *sm;
+	struct wps_device_node *node;
+	do {
+		if (!control_url || !var || !cb_cookie)
+			break;
+		sm = cb_cookie->sm;
+		if (!sm)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		node = sm->device_list;
+		while (node) {
+			if (!os_strcmp(node->device.service.control_url, control_url)) {
+				cb_cookie->callback(sm, control_url, var, val);
+				break;
+			}
+			node = node->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+	} while (0);
+
+	if (cb_cookie)
+		free(cb_cookie);
+}
+
+
+static void
+upnp_wps_ctrlpt_handle_event_received(struct upnp_wps_ctrlpt_sm *sm,
+									  Upnp_SID sid,
+									  int event_key,
+									  IXML_Document *doc)
+{
+	struct wps_device_node *node;
+	IXML_NodeList *props, *vars;
+	IXML_Element *prop, *var;
+	int i, j, props_len, vars_len;
+	char *val;
+
+	do {
+		if (!sm || !sm->ctx || !doc)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		node = sm->device_list;
+		while (node) {
+			if (!os_strcmp(node->device.service.sid, sid)) {
+				props = ixmlDocument_getElementsByTagName(doc, "e:property");
+				if (!props)
+					break;
+				props_len = ixmlNodeList_length(props);
+				for (i = 0; i < props_len; i++) {
+					prop = (IXML_Element *)ixmlNodeList_item(props, i);
+					for (j = 0; wps_event_name[j]; j++) {
+						vars = ixmlElement_getElementsByTagName(prop,
+												(char *)wps_event_name[j]);
+						if (!vars)
+							continue;
+
+						vars_len = ixmlNodeList_length(vars);
+						if (!vars_len) {
+							ixmlNodeList_free(vars);
+							continue;
+						}
+
+						var = (IXML_Element *)ixmlNodeList_item(vars, 0);
+						do {
+							val = 0;
+							if (upnp_get_element_value(var, &val))
+								break;
+							switch (j) {
+							case WPS_EVENT_WLANEVENT:
+							{
+								int event_type;
+								char event_mac[18];
+								u8 *decoded = 0;
+								size_t decoded_len;
+								do {
+									if (!sm->ctx->received_wlan_event)
+										break;
+
+									if (upnp_wps_ctrlpt_decode_base64(val,
+																	  os_strlen(val),
+																	  &decoded,
+																	  &decoded_len))
+										break;
+
+									event_type = (int)(u8)*decoded;
+									strncpy(event_mac, (char *)(decoded + 1), sizeof(event_mac) - 1);
+									event_mac[sizeof(event_mac) - 1] = 0;
+
+									sm->ctx->received_wlan_event(sm->priv,
+																 node->device.service.control_url,
+																 event_type,
+																 event_mac,
+																 decoded + 18,
+																 decoded_len - 18);
+								} while (0);
+
+								if (decoded)
+									free(decoded);
+								break;
+							}
+							case WPS_EVENT_APSTATUS:
+								if (sm->ctx->received_ap_status)
+									sm->ctx->received_ap_status(sm->priv,
+																node->device.service.control_url,
+																atoi(val));
+								break;
+							case WPS_EVENT_STASTATUS:
+								if (sm->ctx->received_sta_status)
+									sm->ctx->received_sta_status(sm->priv,
+																 node->device.service.control_url,
+																 atoi(val));
+								break;
+							}
+						} while (0);
+
+						if (val) {
+							free(val);
+							val = 0;
+						}
+						ixmlNodeList_free(vars);
+					}
+				}
+				ixmlNodeList_free(props);
+				break;
+			}
+			node = node->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+	} while (0);
+}
+
+
+static void
+upnp_wps_ctrlpt_subscribe_update(struct upnp_wps_ctrlpt_sm *sm,
+								 char *event_url,
+								 Upnp_SID sid,
+								 int timeout)
+{
+	struct wps_device_node *node;
+
+	do {
+		if (!sm || !event_url)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+
+		node = sm->device_list;
+		while (node) {
+			if (!os_strcmp(node->device.service.event_url, event_url)) {
+				os_memset(node->device.service.sid, 0,
+						  sizeof(node->device.service.sid));
+				os_memcpy(node->device.service.sid, sid, sizeof(sid));
+				break;
+			}
+			node = node->next;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_devlist);
+	} while (0);
+}
+
+
+static int
+upnp_wps_ctrlpt_callback_event_handler(Upnp_EventType event_type,
+									   void *event, void *cookie)
+{
+	switch (event_type) {
+	/* SSDP */
+	case UPNP_DISCOVERY_ADVERTISEMENT_ALIVE:
+	case UPNP_DISCOVERY_SEARCH_RESULT:
+	{
+		struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)cookie;
+		struct Upnp_Discovery *discovery_event =
+				(struct Upnp_Discovery*)event;
+		IXML_Document *desc_doc = 0;
+
+		do {
+			if (UPNP_E_SUCCESS != discovery_event->ErrCode)
+				break;
+
+			if (UPNP_E_SUCCESS !=
+				UpnpDownloadXmlDoc(discovery_event->Location,
+								   &desc_doc))
+				break;
+
+			if(upnp_wps_ctrlpt_add_device(sm, desc_doc,
+										  discovery_event->Location,
+										  discovery_event->Expires))
+				break;
+		} while (0);
+
+		if (desc_doc)
+			ixmlDocument_free(desc_doc);
+		break;
+	}
+	case UPNP_DISCOVERY_SEARCH_TIMEOUT:
+		/* nothing to do */
+		break;
+	case UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE:
+	{
+		struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)cookie;
+		struct Upnp_Discovery *discovery_event =
+				(struct Upnp_Discovery*)event;
+
+		if (UPNP_E_SUCCESS != discovery_event->ErrCode)
+			;
+		upnp_wps_ctrlpt_remove_device(sm, discovery_event->DeviceId);
+		break;
+	}
+	/* SOAP */
+	case UPNP_CONTROL_ACTION_COMPLETE:
+	{
+		struct upnp_wps_action_callback_cookie *cb_cookie
+				= (struct upnp_wps_action_callback_cookie *)cookie;
+		struct Upnp_Action_Complete *action_event =
+			(struct Upnp_Action_Complete *)event;
+
+		do {
+			if (UPNP_E_SUCCESS != action_event->ErrCode)
+				break;
+
+			upnp_wps_ctrlpt_handle_action_complete(action_event->CtrlUrl,
+												   action_event->ActionResult,
+												   cb_cookie);
+		} while (0);
+
+		break;
+	}
+	case UPNP_CONTROL_GET_VAR_COMPLETE:
+	{
+		struct upnp_wps_get_var_callback_cookie *cb_cookie
+				= (struct upnp_wps_get_var_callback_cookie *)cookie;
+		struct Upnp_State_Var_Complete *var_event =
+			( struct Upnp_State_Var_Complete * )event;
+		do {
+			if (UPNP_E_SUCCESS != var_event->ErrCode)
+				break;
+
+			upnp_wps_ctrlpt_handle_get_var_complete(var_event->CtrlUrl,
+													var_event->StateVarName,
+													var_event->CurrentVal,
+													cb_cookie);
+		} while (0);
+		break;
+	}
+	/* GENA */
+	case UPNP_EVENT_RECEIVED:
+	{
+		struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)cookie;
+		struct Upnp_Event *e_event = (struct Upnp_Event *)event;
+		upnp_wps_ctrlpt_handle_event_received(sm,
+											  e_event->Sid, e_event->EventKey,
+											  e_event->ChangedVariables);
+		break;
+	}
+	case UPNP_EVENT_SUBSCRIBE_COMPLETE:
+	case UPNP_EVENT_UNSUBSCRIBE_COMPLETE:
+	case UPNP_EVENT_RENEWAL_COMPLETE:
+	{
+		struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)cookie;
+		struct Upnp_Event_Subscribe *es_event =
+			(struct Upnp_Event_Subscribe *)event;
+
+		do {
+			if (UPNP_E_SUCCESS != es_event->ErrCode)
+				break;
+
+			upnp_wps_ctrlpt_subscribe_update(sm,
+											 es_event->PublisherUrl,
+											 es_event->Sid,
+											 es_event->TimeOut);
+		} while (0);
+		
+		break;
+	}
+	case UPNP_EVENT_AUTORENEWAL_FAILED:
+	case UPNP_EVENT_SUBSCRIPTION_EXPIRED:
+	{
+		struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)cookie;
+		struct Upnp_Event_Subscribe *es_event =
+			(struct Upnp_Event_Subscribe *)event;
+		int timeout = DEFAULT_TIMEOUT;
+		Upnp_SID sid;
+
+		do 	{
+			if (!sm)
+				break;
+
+			if (UPNP_E_SUCCESS !=
+				UpnpSubscribe(sm->ctrlpt_handle, es_event->PublisherUrl,
+							  &timeout, sid))
+				break;
+
+			upnp_wps_ctrlpt_subscribe_update(sm,
+											 es_event->PublisherUrl,
+											 sid, timeout);
+		} while (0);
+
+		break;
+	}
+	default:
+		/* ignore */
+		break;
+	}
+
+	return 0;
+}
+
+
+#if 0
+static int
+upnp_wps_ctrlpt_get_var(struct upnp_wps_ctrlpt_sm *sm,
+						char *control_url,
+						char *var,
+						void *cookie)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+
+	if (!sm)
+		return ret;
+
+	ithread_mutex_lock(&sm->mutex_devlist);
+
+	do {
+		if (!var)
+			break;
+
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpGetServiceVarStatusAsync(sm->ctrlpt_handle,
+										 node->device.service.control_url,
+										 var,
+										 upnp_wps_ctrlpt_callback_event_handler,
+										 cookie))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	ithread_mutex_unlock(&sm->mutex_devlist);
+
+	return ret;
+}
+#endif
+
+
+static int
+upnp_wps_ctrlpt_send_action(struct upnp_wps_ctrlpt_sm *sm,
+							char *control_url,
+							char *action,
+							char **param_name,
+							char **param_val,
+							int param_cnt,
+							void *cookie)
+{
+	int ret = -1;
+	struct wps_device_node *node;
+	IXML_Document *action_node = 0;
+	int cnt;
+
+	if (!sm)
+		return ret;
+
+	ithread_mutex_lock(&sm->mutex_devlist);
+
+	do {
+		if (upnp_wps_ctrlpt_get_device(sm, control_url, &node))
+			break;
+
+		if (!param_cnt)
+			action_node = UpnpMakeAction(action, wps_service_type, 0, 0);
+		else {
+			for (cnt = 0; cnt < param_cnt; cnt++) {
+				if (UPNP_E_SUCCESS !=
+					UpnpAddToAction(&action_node, action, wps_service_type,
+					param_name[cnt], param_val[cnt]))
+					break;
+			}
+
+			if (cnt < param_cnt)
+				break;
+		}
+
+		if (!action_node) break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpSendActionAsync(sm->ctrlpt_handle,
+								node->device.service.control_url,
+								wps_service_type,
+								0, action_node,
+								upnp_wps_ctrlpt_callback_event_handler, cookie))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	ithread_mutex_unlock(&sm->mutex_devlist);
+
+	if (action_node)
+		ixmlDocument_free(action_node);
+
+	return ret;
+}
+
+static int
+upnp_wps_ctrlpt_resp_get_device_info(struct upnp_wps_ctrlpt_sm *sm,
+									 char *control_url,
+									 IXML_Document *doc)
+{
+	int ret = -1;
+	IXML_NodeList *resps, *vars;
+	IXML_Element *resp, *var;
+	int i, resps_len, vars_len;
+	char *val;
+	u8 *decoded;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !doc)
+			break;
+		if (!sm->ctx->received_resp_get_device_info)
+			break;
+
+		resps = ixmlDocument_getElementsByTagName(doc, "u:GetDeviceInfoResponse");
+		if (!resps)
+			break;
+		resps_len = ixmlNodeList_length(resps);
+		for (i = 0; i < resps_len; i++) {
+			resp = (IXML_Element *)ixmlNodeList_item(resps, i);
+			vars = ixmlElement_getElementsByTagName(resp, "NewDeviceInfo");
+			if (!vars)
+				continue;
+
+			vars_len = ixmlNodeList_length(vars);
+			if (!vars_len)
+				continue;
+
+			var = (IXML_Element *)ixmlNodeList_item(vars, 0);
+			do {
+				decoded = 0;
+				val = 0;
+				if (upnp_get_element_value(var, &val))
+					break;
+
+				if (upnp_wps_ctrlpt_decode_base64(val,
+												  os_strlen(val),
+												  &decoded,
+												  &decoded_len))
+					break;
+
+				if(sm->ctx->received_resp_get_device_info(sm->priv,
+											 control_url,
+											 decoded,
+											 decoded_len))
+					break;
+			} while (0);
+
+			if (decoded)
+				free(decoded);
+			if (val)
+				free(val);
+			ixmlNodeList_free(vars);
+		}
+		ixmlNodeList_free(resps);
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_send_get_device_info(struct upnp_wps_ctrlpt_sm *sm,
+									 char *control_url)
+{
+	int ret = -1;
+	struct upnp_wps_action_callback_cookie *a_cb;
+
+	do {
+		if (!sm || !control_url)
+			break;
+
+		a_cb = (struct upnp_wps_action_callback_cookie *)wpa_zalloc(sizeof(*a_cb));
+		if (!a_cb)
+			break;
+		a_cb->sm = sm;
+		a_cb->callback = upnp_wps_ctrlpt_resp_get_device_info;
+
+		if (upnp_wps_ctrlpt_send_action(sm,
+										control_url,
+										"GetDeviceInfo",
+										0, 0, 0, (void *)a_cb))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_ctrlpt_resp_put_message(struct upnp_wps_ctrlpt_sm *sm,
+								 char *control_url,
+								 IXML_Document *doc)
+{
+	int ret = -1;
+	IXML_NodeList *resps, *vars;
+	IXML_Element *resp, *var;
+	int i, resps_len, vars_len;
+	char *val;
+	u8 *decoded;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !doc)
+			break;
+		if (!sm->ctx->received_resp_put_message)
+			break;
+
+		resps = ixmlDocument_getElementsByTagName(doc, "u:PutMessageResponse");
+		if (!resps)
+			break;
+		resps_len = ixmlNodeList_length(resps);
+		for (i = 0; i < resps_len; i++) {
+			resp = (IXML_Element *)ixmlNodeList_item(resps, i);
+			vars = ixmlElement_getElementsByTagName(resp, "NewOutMessage");
+			if (!vars)
+				continue;
+
+			vars_len = ixmlNodeList_length(vars);
+			if (!vars_len)
+				continue;
+
+			var = (IXML_Element *)ixmlNodeList_item(vars, 0);
+			do {
+				decoded = 0;
+				val = 0;
+				if (upnp_get_element_value(var, &val))
+					break;
+
+				if (upnp_wps_ctrlpt_decode_base64(val,
+												  os_strlen(val),
+												  &decoded,
+												  &decoded_len))
+					break;
+
+				if(sm->ctx->received_resp_put_message(sm->priv,
+											 control_url,
+											 decoded,
+											 decoded_len))
+					break;
+			} while (0);
+
+			if (decoded)
+				free(decoded);
+			if (val)
+				free(val);
+			ixmlNodeList_free(vars);
+		}
+		ixmlNodeList_free(resps);
+
+		ret = 0;
+	} while (0);
+
+	return 0;
+}
+
+
+int
+upnp_wps_ctrlpt_send_put_message(struct upnp_wps_ctrlpt_sm *sm,
+								 char *control_url,
+								 u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	char *param_name = "NewInMessage";
+	char *encoded = 0;
+	size_t encoded_len;
+	struct upnp_wps_action_callback_cookie *a_cb;
+
+	do {
+		if (!sm || !control_url || !msg)
+			break;
+
+		a_cb = (struct upnp_wps_action_callback_cookie *)wpa_zalloc(sizeof(*a_cb));
+		if (!a_cb)
+			break;
+		a_cb->sm = sm;
+		a_cb->callback = upnp_wps_ctrlpt_resp_put_message;
+
+		if (upnp_wps_ctrlpt_encode_base64(msg, msg_len, &encoded, &encoded_len))
+			break;
+
+		if (upnp_wps_ctrlpt_send_action(sm,
+										control_url,
+										"PutMessage",
+										&param_name,
+										&encoded, 1,
+										(void *)a_cb))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (encoded)
+		free(encoded);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_send_put_wlan_response(struct upnp_wps_ctrlpt_sm *sm,
+									   char *control_url, int ev_type,
+									   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	char *param_name[3] = {"NewMessage", "NewWLANEventType", "NewWLANEventMAC"};
+	char *param_val[3];
+	char *encoded = 0;
+	size_t encoded_len;
+	char type[2];
+	char mac[32];
+	struct upnp_wps_action_callback_cookie *a_cb;
+
+	do {
+		if (!sm || !control_url || !msg)
+			break;
+
+		a_cb = (struct upnp_wps_action_callback_cookie *)wpa_zalloc(sizeof(*a_cb));
+		if (!a_cb)
+			break;
+		a_cb->sm = sm;
+		a_cb->callback = 0;
+
+		if (upnp_wps_ctrlpt_encode_base64(msg, msg_len, &encoded, &encoded_len))
+			break;
+		os_snprintf(type, sizeof(type), "%d",
+				 ev_type & (UPNP_WPS_WLANEVENT_TYPE_PROBE|
+				 			UPNP_WPS_WLANEVENT_TYPE_EAP));
+		if (get_mac_from_ip(UpnpGetServerIpAddress(), mac))
+			break;
+
+		param_val[0] = encoded;
+		param_val[1] = type;
+		param_val[2] = mac;
+
+		if (upnp_wps_ctrlpt_send_action(sm,
+										control_url,
+										"PutWLANResponse",
+										param_name,
+										param_val, 3, (void *)a_cb))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (encoded)
+		free(encoded);
+
+	return ret;
+}
+
+int
+upnp_wps_ctrlpt_send_set_selected_registrar(struct upnp_wps_ctrlpt_sm *sm,
+											char *control_url,
+											u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	char *param_name = "NewMessage";
+	char *encoded = 0;
+	size_t encoded_len;
+	struct upnp_wps_action_callback_cookie *a_cb;
+
+	do {
+		if (!sm || !control_url || !msg)
+			break;
+
+		a_cb = (struct upnp_wps_action_callback_cookie *)wpa_zalloc(sizeof(*a_cb));
+		if (!a_cb)
+			break;
+		a_cb->sm = sm;
+		a_cb->callback = 0;
+
+		if (upnp_wps_ctrlpt_encode_base64(msg, msg_len, &encoded, &encoded_len))
+			break;
+
+		if (upnp_wps_ctrlpt_send_action(sm,
+										control_url,
+										"SetSelectedRegistrar",
+										&param_name,
+										&encoded, 1, (void *)a_cb))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (encoded)
+		free(encoded);
+
+	return ret;
+}
+
+static void *
+upnp_wps_ctrlpt_timer(void *args)
+{
+	struct upnp_wps_ctrlpt_sm *sm = (struct upnp_wps_ctrlpt_sm *)args;
+	struct wps_device_node *prev, *cur;
+
+	if (!sm)
+		return 0;
+
+	sm->quit_timer_thread = 0;
+	while (!sm->quit_timer_thread) {
+		isleep(TIMER_LOOP_INC);
+
+		ithread_mutex_lock(&sm->mutex_devlist);
+		prev = 0;
+		cur = sm->device_list;
+		while (cur) {
+			cur->device.advr_timeout -= TIMER_LOOP_INC;
+			if (0 >= cur->device.advr_timeout) {
+				if (cur == sm->device_list)
+					sm->device_list = cur->next;
+				else
+					prev->next = cur->next;
+				upnp_wps_ctrlpt_delete_node(sm, cur);
+				if (prev)
+					cur = prev->next;
+				else
+					cur = sm->device_list;
+			} else {
+				if (cur->device.advr_timeout < (2 * TIMER_LOOP_INC)) {
+					(void)UpnpSearchAsync(sm->ctrlpt_handle,
+										  TIMER_LOOP_INC,
+										  cur->device.udn, sm);
+				}
+				prev = cur;
+				cur = cur->next;
+			}
+		}
+		ithread_mutex_unlock(&sm->mutex_devlist);
+	}
+
+	return 0;
+}
+
+
+int
+upnp_wps_ctrlpt_start(struct upnp_wps_ctrlpt_sm *sm, char *net_if)
+{
+	int ret = -1;
+	char *ip_address = 0;
+
+	do {
+		if (!sm)
+			break;
+
+		if (sm->initialized)
+			upnp_wps_ctrlpt_stop(sm);
+
+		ithread_mutex_init(&sm->mutex_devlist, 0);
+		sm->mutex_initialized = 1;
+
+		if (add_ssdp_network(net_if))
+			break;
+
+		if (get_ip_address(net_if, &ip_address))
+			break;
+
+		if (UPNP_E_SUCCESS != UpnpInit(ip_address, 0))
+			break;
+		sm->initialized++;
+
+		if (os_strcmp(UpnpGetServerIpAddress(), ip_address))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpRegisterClient(upnp_wps_ctrlpt_callback_event_handler,
+							   (void *)sm, &sm->ctrlpt_handle))
+			break;
+		sm->initialized++;
+
+		if (ithread_create(&sm->timer_thread, 0, upnp_wps_ctrlpt_timer, (void *)sm)) {
+			sm->timer_thread = -1;
+			break;
+		}
+		sm->initialized++;
+
+		(void)upnp_wps_ctrlpt_refresh_device(sm, 5);
+
+		ret = 0;
+	} while (0);
+
+	if (ip_address)
+		free(ip_address);
+
+	return ret;
+}
+
+
+int
+upnp_wps_ctrlpt_stop(struct upnp_wps_ctrlpt_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+
+		if (!sm->initialized)
+			break;
+
+		if (0 <= (int)sm->timer_thread) {
+			sm->quit_timer_thread = 1;
+			ithread_join(sm->timer_thread, 0);
+			sm->timer_thread = -1;
+			sm->initialized--;
+		}
+
+		if (sm->mutex_initialized)
+			ithread_mutex_lock(&sm->mutex_devlist);
+		if (0 <= (int)sm->ctrlpt_handle) {
+			UpnpUnRegisterClient(sm->ctrlpt_handle);
+			sm->ctrlpt_handle = -1;
+			sm->initialized--;
+		}
+
+		if (sm->initialized) {
+			UpnpFinish();
+			sm->initialized--;
+		}
+		if (sm->mutex_initialized) {
+			ithread_mutex_unlock(&sm->mutex_devlist);
+			ithread_mutex_destroy(&sm->mutex_devlist);
+			sm->mutex_initialized = 0;
+		}
+	} while (0);
+
+	if (sm)
+		sm->initialized = 0;
+	return 0;
+}
+
+
Index: driver_wext.h
===================================================================
--- driver_wext.h	(revision 1)
+++ driver_wext.h	(revision 2)
@@ -45,4 +45,8 @@
 int wpa_driver_wext_set_operstate(void *priv, int state);
 int wpa_driver_wext_get_version(struct wpa_driver_wext_data *drv);
 
+#ifdef MODIFIED_BY_SONY
+int wpa_driver_wext_auth_alg_fallback(struct wpa_driver_wext_data *drv,
+					struct wpa_driver_associate_params *params);
+#endif /* MODIFIED_BY_SONY */
 #endif /* DRIVER_WEXT_H */
Index: upnp_wps_ctrlpt.h
===================================================================
--- upnp_wps_ctrlpt.h	(revision 0)
+++ upnp_wps_ctrlpt.h	(revision 2)
@@ -0,0 +1,107 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_ctrlpt.h
+//  Description: EAP-WPS UPnP control-point source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef UPNP_WPS_CTRLPT_H
+#define UPNP_WPS_CTRLPT_H
+
+struct upnp_wps_ctrlpt_sm;
+
+struct upnp_wps_ctrlpt_ctx {
+	int (*received_resp_get_device_info)(void *priv,
+										 char *control_url,
+										 u8 *msg, size_t msg_len);
+	int (*received_resp_put_message)(void *priv,
+									 char *control_url,
+									 u8 *msg, size_t msg_len);
+
+	int (*received_wlan_event)(void *priv,
+							   char *control_url,
+							   int ev_type, char *ev_mac,
+							   u8 *msg, size_t msg_len);
+
+#define UPNP_WPS_STATUS_CHANGE_CONFIGURATION		0x01
+#define UPNP_WPS_STATUS_FAIL_AUTH_THRESOLD_REACHED	0x10
+	int (*received_ap_status)(void *priv,
+							  char *control_url, u8 status);
+	int (*received_sta_status)(void *priv,
+							   char *control_url, u8 status);
+};
+
+struct upnp_wps_ctrlpt_sm *
+upnp_wps_ctrlpt_init(struct upnp_wps_ctrlpt_ctx *ctx, void *priv);
+void upnp_wps_ctrlpt_deinit(struct upnp_wps_ctrlpt_sm *sm);
+
+int upnp_wps_ctrlpt_start(struct upnp_wps_ctrlpt_sm *sm, char *net_if);
+int upnp_wps_ctrlpt_stop(struct upnp_wps_ctrlpt_sm *sm);
+
+#ifndef NAME_SIZE
+#define NAME_SIZE 256
+#endif /* NAME_SIZE */
+
+struct upnp_wps_ctrlpt_device {
+	char manufacturer[250];
+	char model_name[250];
+	char model_number[250];
+	char serial_number[250];
+	char udn[250];
+	char control_url[NAME_SIZE];
+};
+
+struct upnp_wps_ctrlpt_device_list {
+	struct upnp_wps_ctrlpt_device device;
+	struct upnp_wps_ctrlpt_device_list *next;
+};
+
+int upnp_wps_ctrlpt_get_scan_results(struct upnp_wps_ctrlpt_sm *sm,
+								struct upnp_wps_ctrlpt_device_list **list);
+void upnp_wps_ctrlpt_destroy_device_list(struct upnp_wps_ctrlpt_device_list *list);
+
+int upnp_wps_ctrlpt_refresh_device(struct upnp_wps_ctrlpt_sm *sm, int timeout);
+int upnp_wps_ctrlpt_send_get_device_info(struct upnp_wps_ctrlpt_sm *sm,
+										 char *control_url);
+int upnp_wps_ctrlpt_send_put_message(struct upnp_wps_ctrlpt_sm *sm,
+									 char *control_url,
+									 u8 *msg, size_t msg_len);
+#define UPNP_WPS_WLANEVENT_TYPE_PROBE	1
+#define UPNP_WPS_WLANEVENT_TYPE_EAP		2
+int upnp_wps_ctrlpt_send_put_wlan_response(struct upnp_wps_ctrlpt_sm *sm,
+										   char *control_url, int ev_type,
+#ifdef CONFIG_NATIVE_WINDOWS
+										   u8 *mac,
+#endif /* CONFIG_NATIVE_WINDOWS */
+										   u8 *msg, size_t msg_len);
+int upnp_wps_ctrlpt_send_set_selected_registrar(struct upnp_wps_ctrlpt_sm *sm,
+												char *control_url,
+												u8 *msg, size_t msg_len);
+#endif /* UPNP_WPS_CTRLPT_H */
Index: vs2005/wpa_supplicant/wpa_supplicant.vcproj
===================================================================
--- vs2005/wpa_supplicant/wpa_supplicant.vcproj	(revision 1)
+++ vs2005/wpa_supplicant/wpa_supplicant.vcproj	(revision 2)
@@ -40,8 +40,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
+				AdditionalIncludeDirectories="\dev\WpdPack\include;\dev\OpenSSL\include;..\..\..\WpsNfcLibrary"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS;EAP_WPS;WPS_OPT_UPNP;WPS_OPT_NFC;MODIFIED_BY_SONY"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="3"
@@ -62,9 +62,9 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
+				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib wpsnfc.lib"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
+				AdditionalLibraryDirectories="\dev\WpdPack\Lib;\dev\OpenSSL\lib\VC;..\..\..\WpsNfcLibrary\win32"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -119,8 +119,8 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
+				AdditionalIncludeDirectories="\dev\WpdPack\include;\dev\OpenSSL\include;..\..\..\WpsNfcLibrary"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS;EAP_WPS;WPS_OPT_UPNP;WPS_OPT_NFC;MODIFIED_BY_SONY"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
@@ -139,9 +139,9 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
+				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib wpsnfc.lib"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
+				AdditionalLibraryDirectories="\dev\WpdPack\Lib;\dev\OpenSSL\lib\VC;..\..\..\WpsNfcLibrary\win32"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -275,6 +275,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\eap_wps.c"
+				>
+			</File>
+			<File
 				RelativePath="..\..\eapol_sm.c"
 				>
 			</File>
@@ -339,6 +343,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\upnp_wps_ctrlpt_win.c"
+				>
+			</File>
+			<File
 				RelativePath="..\..\wpa.c"
 				>
 			</File>
@@ -346,6 +354,22 @@
 				RelativePath="..\..\wpa_supplicant.c"
 				>
 			</File>
+			<File
+				RelativePath="..\..\wps_config.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\wps_opt_nfc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\wps_opt_upnp.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\wps_parser.c"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Header Files"
Index: eap_methods.c
===================================================================
--- eap_methods.c	(revision 1)
+++ eap_methods.c	(revision 2)
@@ -462,6 +462,13 @@
 	}
 #endif /* EAP_VENDOR_TEST */
 
+#ifdef EAP_WPS
+	if (ret == 0) {
+		int eap_peer_wps_register(void);
+		ret = eap_peer_wps_register();
+	}
+#endif /* EAP_WPS */
+
 	return ret;
 }
 
Index: wpa_supplicant.c
===================================================================
--- wpa_supplicant.c	(revision 1)
+++ wpa_supplicant.c	(revision 2)
@@ -36,10 +36,30 @@
 #include "wpa_ctrl.h"
 #include "mlme.h"
 
+#ifdef WPS_OPT_UPNP
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+#include "wps_opt_nfc.h"
+#endif /* WPS_OPT_NFC */
+#ifdef USE_INTEL_SDK
+#include "intel_ie_wps.h"
+#elif defined(EAP_WPS)
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+
 const char *wpa_supplicant_version =
 "wpa_supplicant v" VERSION_STR "\n"
 "Copyright (c) 2003-2007, Jouni Malinen <j@w1.fi> and contributors";
 
+#ifdef MODIFIED_BY_SONY
+const char *modified_by_sony_version =
+		"\nWi-Fi Protected Setup Reference Application,\n"
+		"Version '" MODIFIED_BY_SONY_VERSION_STR "', modified by Sony.\n"
+		"Copyright (c) 2007, Sony Corporation "
+		"and contributers\n";
+#endif /* MODIFIED_BY_SONY */
+
 const char *wpa_supplicant_license =
 "This program is free software. You can distribute it and/or modify it\n"
 "under the terms of the GNU General Public License version 2.\n"
@@ -292,6 +312,18 @@
 	struct wpa_supplicant *wpa_s = ctx;
 	return wpa_config_get_blob(wpa_s->conf, name);
 }
+
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static const struct wps_config *
+wpa_supplicant_get_wps_config(void *ctx)
+{
+	struct wpa_supplicant *wpa_s = ctx;
+	return wpa_config_get_wps_config(wpa_s->conf);
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 #endif /* defined(IEEE8021X_EAPOL) || !defined(CONFIG_NO_WPA) */
 
 
@@ -491,6 +523,48 @@
  */
 void wpa_supplicant_req_scan(struct wpa_supplicant *wpa_s, int sec, int usec)
 {
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wpa_ssid *ssid = 0;
+	u8 *ie = 0;
+	size_t ie_len;
+
+	ssid = wpa_s->conf->ssid;
+	while (ssid) {
+		if (!ssid->disabled)
+			break;
+		ssid = ssid->next;
+	}
+
+	if (wpa_config_get(ssid, "eap") &&
+	    !os_strcmp("WPS", wpa_config_get(ssid, "eap"))) {
+		do {
+			/* Create WPS ProbeReq IE */
+			if (wps_config_create_probe_req_ie(wpa_s, &ie, &ie_len))
+				break;
+			/* Set WPS ProbeReq IE */
+			if (wpa_drv_set_wps_probe_req_ie(wpa_s, ie, (int)ie_len))
+				break;
+			free(ie);
+			ie = 0;
+			ie_len = 0;
+			/* Create WPS AssocReq IE */
+			if (wps_config_create_assoc_req_ie(wpa_s, &ie, &ie_len))
+				break;
+			/* Set WPS AssocReq IE */
+			if (wpa_drv_set_wps_assoc_req_ie(wpa_s, ie, (int)ie_len))
+				break;
+		} while (0);
+		if (ie)
+			free(ie);
+	} else {
+		/* Clear WPS ProbeResp/AssocReq IE */
+		(void)wpa_drv_set_wps_probe_req_ie(wpa_s, 0, 0);
+		(void)wpa_drv_set_wps_assoc_req_ie(wpa_s, 0, 0);
+	}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	wpa_msg(wpa_s, MSG_DEBUG, "Setting scan request: %d sec %d usec",
 		sec, usec);
 	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
@@ -696,6 +770,15 @@
 	eapol_sm_deinit(wpa_s->eapol);
 	wpa_s->eapol = NULL;
 
+#ifdef WPS_OPT_NFC
+	if (wpa_s->nfcname) {
+		free(wpa_s->nfcname);
+		wpa_s->nfcname = 0;
+	}
+	wps_opt_nfc_sm_deinit(wpa_s->wps_opt_nfc);
+	wpa_s->wps_opt_nfc = NULL;
+#endif /* WPS_OPT_NFC */
+
 	rsn_preauth_deinit(wpa_s->wpa);
 
 	pmksa_candidate_free(wpa_s->wpa);
@@ -711,6 +794,11 @@
 	wpa_supplicant_cancel_auth_timeout(wpa_s);
 
 	ieee80211_sta_deinit(wpa_s);
+
+#ifdef WPS_OPT_UPNP
+	wps_opt_upnp_sm_deinit(wpa_s->wps_opt_upnp);
+	wpa_s->wps_opt_upnp = NULL;
+#endif /* WPS_OPT_UPNP */
 }
 
 
@@ -2144,6 +2232,24 @@
 			   sizeof(wpa_s->bridge_ifname));
 	}
 
+#ifdef WPS_OPT_NFC
+	if (iface->nfcname) {
+#ifdef CONFIG_BACKEND_FILE
+		wpa_s->nfcname = os_rel2abs_path(iface->nfcname);
+		if (wpa_s->nfcname == NULL) {
+			wpa_printf(MSG_ERROR, "Failed to get absolute path "
+				   "for nfc interface name '%s'.",
+				   iface->nfcname);
+			return -1;
+		}
+		wpa_printf(MSG_DEBUG, "NFC interface '%s' -> '%s'",
+			   iface->nfcname, wpa_s->nfcname);
+#else /* CONFIG_BACKEND_FILE */
+		wpa_s->nfcname = os_strdup(iface->nfcname);
+#endif /* CONFIG_BACKEND_FILE */
+	}
+#endif /* WPS_OPT_NFC */
+
 	return 0;
 }
 
@@ -2171,7 +2277,15 @@
 	ctx->opensc_engine_path = wpa_s->conf->opensc_engine_path;
 	ctx->pkcs11_engine_path = wpa_s->conf->pkcs11_engine_path;
 	ctx->pkcs11_module_path = wpa_s->conf->pkcs11_module_path;
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	ctx->get_wps_config = wpa_supplicant_get_wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	wpa_s->eapol = eapol_sm_init(ctx);
+	wpa_s->eapol = eapol_sm_init(ctx);
 	if (wpa_s->eapol == NULL) {
 		os_free(ctx);
 		wpa_printf(MSG_ERROR, "Failed to initialize EAPOL state "
@@ -2226,12 +2340,107 @@
 }
 
 
+#if defined(WPS_OPT_UPNP) || defined(WPS_OPT_NFC)
+static struct wpa_config *wpa_supplicant_get_conf(void *ctx)
+{
+	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)ctx;
+	return wpa_s?wpa_s->conf:NULL;
+}
+#endif /* defined(WPS_OPT_UPNP) || defined(WPS_OPT_NFC) */
+
+
+#ifdef WPS_OPT_UPNP
+static int wpa_supplicant_init_wps_opt_upnp(struct wpa_supplicant *wpa_s)
+{
+	struct wps_opt_upnp_sm_ctx *ctx;
+	ctx = wpa_zalloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate UPNP context.");
+		return -1;
+	}
+
+	ctx->ctx = wpa_s;
+	ctx->msg_ctx = wpa_s;
+
+	ctx->get_conf = wpa_supplicant_get_conf;
+
+	wpa_s->wps_opt_upnp = wps_opt_upnp_sm_init(ctx);
+	if (wpa_s->wps_opt_upnp == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to initialize UPNP state "
+			   "machine");
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* WPS_OPT_UPNP */
+
+
+#ifdef WPS_OPT_NFC
+#ifdef WPS_OPT_UPNP
+static struct wps_opt_upnp_sm *
+wpa_supplicant_get_upnp_sm(void *ctx)
+{
+	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)ctx;
+	return wpa_s?wpa_s->wps_opt_upnp:0;
+}
+#endif /* WPS_OPT_UPNP */
+
+
+static int wpa_supplicant_get_own_addr(void *ctx, u8 *mac)
+{
+	int ret = 0;
+	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)ctx;
+	if (wpa_s)
+		memcpy(mac, wpa_s->own_addr, ETH_ALEN);
+	else
+		ret = -1;
+	return ret;
+}
+
+
+static int wpa_supplicant_init_wps_opt_nfc(struct wpa_supplicant *wpa_s)
+{
+	struct wps_opt_nfc_sm_ctx *ctx;
+	ctx = wpa_zalloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate NFC context.");
+		return -1;
+	}
+
+	ctx->ctx = wpa_s;
+	ctx->msg_ctx = wpa_s;
+
+	ctx->get_own_addr = wpa_supplicant_get_own_addr;
+	ctx->get_conf = wpa_supplicant_get_conf;
+#ifdef WPS_OPT_UPNP
+	ctx->get_upnp_sm = wpa_supplicant_get_upnp_sm;
+#endif /* WPS_OPT_UPNP */
+
+	wpa_s->wps_opt_nfc = wps_opt_nfc_sm_init(ctx);
+	if (wpa_s->wps_opt_nfc == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to initialize NFC state "
+			   "machine");
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* WPS_OPT_NFC */
+
+
 static int wpa_supplicant_init_iface2(struct wpa_supplicant *wpa_s,
 				      int wait_for_interface)
 {
 	const char *ifname;
 	struct wpa_driver_capa capa;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config * wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	wpa_printf(MSG_DEBUG, "Initializing interface (2) '%s'",
 		   wpa_s->ifname);
 
@@ -2323,6 +2532,78 @@
 			return -1;
 	}
 
+#ifdef USE_INTEL_SDK
+	if (wps_ie_init(wpa_s) < 0) {
+		return -1;
+	}
+#elif defined(EAP_WPS)
+	wps = wpa_s->conf->wps;
+	if (wps) {
+		struct wpa_hw_modes *modes;
+		u16 num_modes, flags;
+
+		memcpy(wps->mac, wpa_s->own_addr, sizeof(wps->mac));
+		wps->mac_set = 1;
+
+		if (!wpa_drv_get_capa(wpa_s, &capa)) {
+			wps->auth_type_flags = 0;
+			if (capa.auth & WPA_DRIVER_AUTH_OPEN)
+				wps->auth_type_flags |= WPS_AUTHTYPE_OPEN;
+			if (capa.auth & WPA_DRIVER_AUTH_SHARED)
+				wps->auth_type_flags |= WPS_AUTHTYPE_SHARED;
+			if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA)
+				wps->auth_type_flags |= WPS_AUTHTYPE_WPA;
+			if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA2)
+				wps->auth_type_flags |= WPS_AUTHTYPE_WPA2;
+			if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK)
+				wps->auth_type_flags |= WPS_AUTHTYPE_WPAPSK;
+			if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK)
+				wps->auth_type_flags |= WPS_AUTHTYPE_WPA2PSK;
+
+			wps->encr_type_flags = WPS_ENCRTYPE_NONE;
+			if (capa.enc & (WPA_DRIVER_CAPA_ENC_WEP40|
+							WPA_DRIVER_CAPA_ENC_WEP104))
+				wps->encr_type_flags |= WPS_ENCRTYPE_WEP;
+			if (capa.enc & WPA_DRIVER_CAPA_ENC_TKIP)
+				wps->encr_type_flags |= WPS_ENCRTYPE_TKIP;
+			if (capa.enc & WPA_DRIVER_CAPA_ENC_CCMP)
+				wps->encr_type_flags |= WPS_ENCRTYPE_AES;
+		}
+
+		modes = wpa_drv_get_hw_feature_data(wpa_s, &num_modes, &flags);
+		if (modes) {
+			int i;
+
+			wps->rf_bands = 0;
+			for (i = 0; i < num_modes; i++) {
+				if(modes[i].mode & WPA_MODE_IEEE80211A)
+					wps->rf_bands |= WPS_RFBAND_50GHZ;
+				else if (modes[i].mode & (WPA_MODE_IEEE80211B|
+										  WPA_MODE_IEEE80211G))
+					wps->rf_bands |= WPS_RFBAND_24GHZ;
+				if (modes[i].channels)
+					free(modes[i].channels);
+				if (modes[i].rates)
+					free(modes[i].rates);
+			}
+			free(modes);
+		}
+	}
+#endif /* USE_INTEL_SDK */
+
+#ifdef WPS_OPT_NFC
+	if (wpa_supplicant_init_wps_opt_nfc(wpa_s) < 0)
+		return -1;
+	if (wpa_s->nfcname) {
+		wps_opt_nfc_sm_set_ifname(wpa_s->wps_opt_nfc, wpa_s->nfcname);
+	}
+#endif /* WPS_OPT_NFC */
+
+#ifdef WPS_OPT_UPNP
+	if (wpa_supplicant_init_wps_opt_upnp(wpa_s))
+		return -1;
+#endif /* WPS_OPT_UPNP */
+
 	return 0;
 }
 
@@ -2343,6 +2624,10 @@
 		wpa_drv_set_drop_unencrypted(wpa_s, 0);
 		wpa_drv_set_countermeasures(wpa_s, 0);
 		wpa_clear_keys(wpa_s, NULL);
+
+#ifdef USE_INTEL_SDK
+		wps_ie_deinit(wpa_s);
+#endif /* USE_INTEL_SDK */
 	}
 
 	wpas_dbus_unregister_iface(wpa_s);
Index: version.h
===================================================================
--- version.h	(revision 1)
+++ version.h	(revision 2)
@@ -3,4 +3,8 @@
 
 #define VERSION_STR "0.5.8"
 
+#ifdef MODIFIED_BY_SONY
+#define MODIFIED_BY_SONY_VERSION_STR "sony_r5.7"
+#endif /* MODIFIED_BY_SONY */
+
 #endif /* VERSION_H */
Index: wps_opt_upnp.c
===================================================================
--- wps_opt_upnp.c	(revision 0)
+++ wps_opt_upnp.c	(revision 2)
@@ -0,0 +1,1372 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_upnp.c
+//  Description: EAP-WPS UPnP option source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#ifndef CONFIG_NATIVE_WINDOWS
+#include <upnp/ithread.h>
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+#include "defs.h"
+#include "common.h"
+#include "wpa_supplicant.h"
+#include "wpa.h"
+#include "eloop.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wpa_ctrl.h"
+#include "state_machine.h"
+#include "wps_parser.h"
+#include "wps_opt_upnp.h"
+#include "eap_wps.h"
+#include "upnp_wps_ctrlpt.h"
+
+#define STATE_MACHINE_DATA struct wps_opt_upnp_sm
+#define STATE_MACHINE_DEBUG_PREFIX "OPT_UPNP"
+
+#ifdef CONFIG_NATIVE_WINDOWS
+typedef HANDLE mutex_t;
+#else /* CONFIG_NATIVE_WINDOWS */
+typedef ithread_mutex_t mutex_t;
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+
+/**
+ * struct wps_opt_upnp_sm - Internal data for UPNP state machines
+ */
+
+typedef enum {
+	OPT_UPNP_INACTIVE = 0,
+	OPT_UPNP_SCANNING,
+	OPT_UPNP_SCAN_TIMEOUT
+} opt_upnp_states;
+
+struct opt_upnp_device_info {
+	char *control_url;
+	int event_type;
+	char event_mac[18];
+	struct eap_wps_data *data;
+};
+
+struct opt_upnp_device_node {
+	struct opt_upnp_device_info info;
+	struct opt_upnp_device_node *next;
+};
+
+struct wps_opt_upnp_sm {
+	opt_upnp_states OPT_UPNP_state;
+	Boolean changed;
+	struct wps_opt_upnp_sm_ctx *ctx;
+	struct upnp_wps_ctrlpt_sm *upnp_ctrlpt_sm;
+	struct os_time scanTimeout;
+	mutex_t mutex_devlist;
+	struct opt_upnp_device_node *list;
+};
+
+
+static void wps_opt_upnp_request(struct wps_opt_upnp_sm *sm,
+								 int req_type, const char *msg,
+								 size_t msg_len)
+{
+#define CTRL_REQ_TYPE_COMP			0
+#define CTRL_REQ_TYPE_FAIL			1
+#define CTRL_REQ_TYPE_PASSWORD		2
+	char *buf;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (!sm || !sm->ctx)
+		return;
+
+	switch(req_type) {
+	case CTRL_REQ_TYPE_COMP:
+		field = "UPNP_COMP";
+		txt = "Complete EAP-WPS with UPnP authentication";
+		break;
+	case CTRL_REQ_TYPE_FAIL:
+		field = "UPNP_FAIL";
+		txt = "Fail EAP-WPS with UPnP authentication";
+		break;
+	case CTRL_REQ_TYPE_PASSWORD:
+		field = "UPNP_PASSWORD";
+		txt = "Request Password for EAP-WPS with UPnP";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	wpa_msg(sm->ctx->msg_ctx, MSG_INFO, "%s", buf);
+	free(buf);
+}
+
+
+int
+wps_opt_upnp_refresh_device(struct wps_opt_upnp_sm *sm, int timeout)
+{
+	int ret = -1;
+
+	do {
+		if (!sm)
+			break;
+
+		if (upnp_wps_ctrlpt_refresh_device(sm->upnp_ctrlpt_sm, timeout))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+wps_opt_upnp_get_scan_result(struct wps_opt_upnp_sm *sm,
+							 struct upnp_wps_ctrlpt_device_list **list)
+{
+	int ret = -1;
+
+	do {
+		if (!sm || !list)
+			break;
+		*list = 0;
+
+		if (upnp_wps_ctrlpt_get_scan_results(sm->upnp_ctrlpt_sm, list))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (list && *list) {
+			upnp_wps_ctrlpt_destroy_device_list(*list);
+			*list = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static void wps_opt_upnp_deinit_data(struct eap_wps_data *data)
+{
+	do {
+		if (!data)
+			break;
+		eap_wps_config_deinit_data(data);
+	} while (0);
+}
+
+
+static int wps_opt_upnp_init_data(struct wps_opt_upnp_sm *sm,
+								  struct eap_wps_data **data)
+{
+	int ret = -1;
+	struct wps_config *conf;
+
+	do {
+		if (!sm || !sm->ctx || !data)
+			break;
+		*data = 0;
+
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (!conf)
+			break;
+
+		*data = (struct eap_wps_data *)wpa_zalloc(sizeof(**data));
+		if (!*data)
+			break;
+		if (eap_wps_config_init_data(conf, *data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (data && *data) {
+			free(*data);
+			*data = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int wps_opt_upnp_get_device_node(struct wps_opt_upnp_sm *sm,
+										char *control_url,
+										struct opt_upnp_device_node **node)
+{
+	int ret = -1;
+	struct opt_upnp_device_node *cur;
+
+	do {
+		if (!sm || !control_url || !node)
+			break;
+
+		*node = 0;
+		cur = sm->list;
+		while (cur) {
+			if (cur->info.control_url &&
+				!os_strcmp(cur->info.control_url, control_url)) {
+				*node = cur;
+				ret = 0;
+				break;
+			}
+			cur = cur->next;
+		}
+	} while (0);
+	if (ret && node && *node)
+		*node = 0;
+	return ret;
+}
+
+
+static void wps_opt_upnp_del_device_node(struct opt_upnp_device_node *node)
+{
+	do {
+		if (!node)
+			break;
+		if (node->info.control_url)
+			free(node->info.control_url);
+		wps_opt_upnp_deinit_data(node->info.data);
+		free(node);
+		node = 0;
+	} while (0);
+}
+
+
+static int wps_opt_upnp_remove_device_node(struct wps_opt_upnp_sm *sm,
+										   char *control_url)
+{
+	int ret = -1;
+	struct opt_upnp_device_node *prev = 0, *cur;
+
+	do {
+		if (!sm || !control_url)
+			break;
+
+		cur = sm->list;
+		while (cur) {
+			if (cur->info.control_url &&
+				!os_strcmp(cur->info.control_url, control_url)) {
+				if (cur == sm->list)
+					sm->list = cur->next;
+				else if (prev)
+					prev->next = cur->next;
+				else
+					break;
+				wps_opt_upnp_del_device_node(cur);
+				ret = 0;
+				break;
+			}
+			prev = cur;
+			cur = cur->next;
+		}
+	} while (0);
+
+	return ret;
+}
+
+
+static void wps_opt_upnp_remove_all_device_node(struct wps_opt_upnp_sm *sm)
+{
+	struct opt_upnp_device_node *cur, *next;
+
+	do {
+		if (!sm)
+			break;
+
+		cur = sm->list;
+		while (cur) {
+			next = cur->next;
+			wps_opt_upnp_del_device_node(cur);
+			cur = next;
+		}
+		sm->list = 0;
+	} while (0);
+}
+
+
+static struct opt_upnp_device_node *
+wps_opt_upnp_add_device_node(struct wps_opt_upnp_sm *sm,
+							 char *control_url)
+{
+	int ret = -1;
+	struct opt_upnp_device_node *node = 0, *next;
+
+	do {
+		if (!sm || !control_url)
+			break;
+
+		node = sm->list;
+		while (node) {
+			if (node->info.control_url &&
+				!os_strcmp(node->info.control_url, control_url))
+				break;
+			node = node->next;
+		}
+
+		if (node) {
+			wps_opt_upnp_deinit_data(node->info.data);
+			if (wps_opt_upnp_init_data(sm, &node->info.data))
+				break;
+		} else {
+			node = (struct opt_upnp_device_node *)wpa_zalloc(sizeof(*node));
+			if (!node)
+				break;
+			node->info.control_url =
+				(char *)wpa_zalloc(os_strlen(control_url) + 1);
+			if (!node->info.control_url)
+				break;
+			strcpy(node->info.control_url, control_url);
+			node->info.data =
+				(struct eap_wps_data *)wpa_zalloc(sizeof(*node->info.data));
+			if (!node->info.data)
+				break;
+			if (wps_opt_upnp_init_data(sm, &node->info.data))
+				break;
+
+			if (sm->list) {
+				next = sm->list;
+				while (next->next)
+					next = next->next;
+				next->next = node;
+			} else
+				sm->list = node;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (node) {
+			(void)wps_opt_upnp_remove_device_node(sm, control_url);
+			wps_opt_upnp_del_device_node(node);
+			node = 0;
+		}
+	}
+	return node;
+}
+
+
+int
+wps_opt_upnp_select_ssid_configuration(struct wps_opt_upnp_sm *sm,
+									   char *control_url,
+									   struct wps_config *conf,
+									   struct eap_wps_data *data,
+									   u8 *raw_data, size_t raw_data_len,
+									   Boolean wrap_credential)
+{
+	int ret = -1;
+	int index;
+	char msg[BUFSIZ];
+
+	do {
+		if (!sm || !conf || !data || !raw_data || !raw_data_len)
+			break;
+
+		index = eap_wps_config_select_ssid_configuration(conf, data,
+														 raw_data, raw_data_len,
+														 wrap_credential);
+		if (0 > index)
+			break;
+
+		os_snprintf(msg, sizeof(msg), "%d:%s", index, control_url);
+		wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, msg, os_strlen(msg));
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 *
+wps_opt_upnp_build_req_registrar(struct wps_opt_upnp_sm *sm,
+								 char *control_url,
+								 struct wps_config *conf,
+								 struct eap_wps_data *data,
+								 size_t *rsp_len)
+{
+	u8 *rsp = 0;
+	struct eap_wps_target_info *target;
+
+	do {
+		if (!sm || !conf || !data || !data->target || !rsp_len)
+			break;
+		*rsp_len = 0;
+
+		target = data->target;
+
+		switch (data->state) {
+		case M2:
+		{
+			/* Build M2 message */
+			rsp = eap_wps_config_build_message_M2(conf, data, rsp_len);
+			if (!rsp)
+				break;
+			/* Should be received M3 message */
+			data->state = M3;
+			break;
+		}
+		case M2D:
+		{
+			char msg[BUFSIZ];
+
+			/* Build M2D message */
+			rsp = eap_wps_config_build_message_M2D(conf, data, rsp_len);
+			if (!rsp)
+				break;
+
+			switch (data->reg_mode) {
+			case WPS_REGMODE_REGISTER_STA:
+				os_snprintf(msg, sizeof(msg), "REGISTRAR_STA:%s", control_url);
+				break;
+			default:
+				msg[0] = 0;
+				break;
+			}
+			if (msg[0])
+				wps_opt_upnp_request(sm, CTRL_REQ_TYPE_PASSWORD, msg, os_strlen(msg));
+
+			/* wait for receiving DONE message or inputting PIN */
+			data->state = DONE;
+			break;
+		}
+		case M4:
+		{
+			/* Build M4 message */
+			rsp = eap_wps_config_build_message_M4(conf, data, rsp_len);
+			if(!rsp)
+				break;
+			/* Should be received M5 message */
+			data->state = M5;
+			break;
+		}
+		case M6:
+		{
+			/* Build M6 message */
+			rsp = eap_wps_config_build_message_M6(conf, data, rsp_len);
+			if(!rsp)
+				break;
+			/* Should be received M7 message */
+			data->state = M7;
+			break;
+		}
+		case M8:
+		{
+			if (data->reg_mode == WPS_REGMODE_REGISTER_STA) {
+				int res = -1;
+				struct wps_data *wps = 0;
+				u8 *tmp;
+				u16 tmp_len;
+				do {
+					if (wps_create_wps_data(&wps))
+						break;
+
+					if (wps_set_value(wps, WPS_TYPE_CREDENTIAL,
+									  data->config, data->config_len))
+						break;
+
+					if (wps_write_wps_data(wps, &tmp, &tmp_len))
+						break;
+
+					res = 0;
+				} while (0);
+				(void)wps_destroy_wps_data(&wps);
+
+				if (!res) {
+					free(data->config);
+					data->config = tmp;
+					data->config_len = tmp_len;
+				} else {
+					if (data->config) free(data->config);
+					data->config = 0;
+					data->config_len = 0;
+					if (tmp) free(tmp);
+					break;
+				}
+			}
+
+			/* Build M8 message */
+			rsp = eap_wps_config_build_message_M8(conf, data, rsp_len);
+			if(!rsp)
+				break;
+			/* Should be received Done message */
+			data->state = DONE;
+			break;
+		}
+		case NACK:
+		{
+
+			char msg[BUFSIZ];
+
+			rsp = eap_wps_config_build_message_special(conf, data,
+													   WPS_MSGTYPE_NACK,
+													   target->nonce,
+													   data->nonce,
+													   rsp_len);
+			if (conf->reg_mode == WPS_REGMODE_CONFIGURE_AP) {
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				data->state = FAILURE;
+
+				/* Send EAP-WPS fail message */
+				os_snprintf(msg, sizeof(msg), "%d:%s", 0, control_url);
+				wps_opt_upnp_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+			} else {
+				data->state = NACK;
+			}
+		}
+		default:
+		{
+			break;
+		}
+		}
+	} while (0);
+
+	if (!rsp && rsp_len)
+		*rsp_len = 0;
+
+	return rsp;
+}
+
+
+static int
+wps_opt_upnp_process_registrar(struct wps_opt_upnp_sm *sm,
+							   char *control_url,
+							   struct wps_config *conf,
+							   struct eap_wps_data *data,
+							   u8 *req, size_t req_len)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	int prev_state;
+
+	do {
+		if (!sm || !conf || !data || !data->target || !req)
+			break;
+		target = data->target;
+
+		if (data->rcvMsg) {
+			free(data->rcvMsg);
+			data->rcvMsg = 0;
+			data->rcvMsgLen = 0;
+		}
+
+		if (!req || !req_len)
+			break;
+
+		data->rcvMsg = (u8 *)wpa_zalloc(req_len);
+		if (!data->rcvMsg)
+			break;
+		os_memcpy(data->rcvMsg, req, req_len);
+		data->rcvMsgLen = req_len;
+
+		prev_state = data->state;
+		switch (data->state) {
+		case START:
+		{
+			/* Should be received M1 message */
+			if (!eap_wps_config_process_message_M1(conf, data)) {
+				if (data->dev_pwd_len) {
+					/* Build M2 message */
+					data->state = M2;
+				} else {
+					/* Build M2D message */
+					data->state = M2D;
+				}
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M3:
+		{
+			/* Should be received M3 message */
+			if (!eap_wps_config_process_message_M3(conf, data)) {
+				/* Build M4 message */
+				data->state = M4;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M5:
+		{
+			/* Should be received M5 message */
+			if (!eap_wps_config_process_message_M5(conf, data)) {
+				/* Build M6 message */
+				data->state = M6;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M7:
+		{
+			/* Should be received M7 message */
+			if (!eap_wps_config_process_message_M7(conf, data)) {
+				/* Build M8 message */
+				data->state = M8;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case DONE:
+		{
+			/* Should be received Done */
+			if (!eap_wps_config_process_message_special(conf, data, WPS_MSGTYPE_DONE, target->nonce, data->nonce)) {
+				switch (data->reg_mode) {
+				case WPS_REGMODE_CONFIGURE_AP:
+					/* Select Network Configuration (already added) */
+					(void)wps_opt_upnp_select_ssid_configuration(
+										sm, control_url, conf, data,
+										data->config, data->config_len, 0);
+					break;
+				case WPS_REGMODE_REGISTER_STA:
+					/* Select Network Configuration (already added) */
+					(void)wps_opt_upnp_select_ssid_configuration(
+										sm, control_url, conf, data,
+										data->config, data->config_len, 1);
+					break;
+				default:
+					break;
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+				data->state = FAILURE;
+			} else if (WPS_MSGTYPE_DONE == wps_get_message_type(data->rcvMsg, data->rcvMsgLen)) {
+				data->state = FAILURE;
+			} else if (!eap_wps_config_process_message_M1(conf, data)) {
+				if (conf->dev_pwd_len)
+					data->state = M2;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case NACK:
+		{
+			char msg[BUFSIZ];
+
+			/* Should be received NACK */
+			(void)eap_wps_config_process_message_special(conf, data,
+														 WPS_MSGTYPE_NACK,
+														 target->nonce,
+														 data->nonce);
+			if (conf->reg_mode == WPS_REGMODE_CONFIGURE_AP) {
+				data->state = NACK;
+			} else {
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				data->state = FAILURE;
+
+				/* Send EAP-WPS fail message */
+				os_snprintf(msg, sizeof(msg), "%d:%s", 0, control_url);
+				wps_opt_upnp_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+			}
+
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+		if (((data->state != DONE) && (data->state != NACK))
+			 && (prev_state == data->state))
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+wps_opt_upnp_get_device_info(struct wps_opt_upnp_sm *sm,
+							 char *control_url)
+{
+	int ret = -1;
+
+	do {
+		if (!sm || !control_url)
+			break;
+
+		if (upnp_wps_ctrlpt_send_get_device_info(sm->upnp_ctrlpt_sm,
+												 control_url))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+wps_opt_upnp_set_selected_registrar(struct wps_opt_upnp_sm *sm,
+									char *control_url,
+									int selected)
+{
+	int ret = -1;
+	struct wpa_config *conf;
+	struct wps_config *wps;
+	struct wps_data *data = 0;
+	Boolean blval;
+	u8 u8val;
+	u16 u16val;
+	u8 *msg = 0;
+	u16 msg_len;
+
+	do {
+		if (!sm || !sm->ctx)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf || !conf->wps)
+			break;
+		wps = conf->wps;
+
+		if (wps_create_wps_data(&data))
+			break;
+
+		u8val = wps->version;
+		if (!u8val)
+			u8val = WPS_VERSION;
+		if (wps_set_value(data, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Selected Registrar */
+		blval = selected?1:0;
+		if (wps_set_value(data, WPS_TYPE_SEL_REGISTRAR, &blval, 0))
+			break;
+
+		/* Device Password ID */
+		u16val = selected?wps->dev_pwd_id:WPS_DEVICEPWDID_DEFAULT;
+		if (wps_set_value(data, WPS_TYPE_DEVICE_PWD_ID, &u16val, 0))
+			break;
+
+		/* Selected Registrar Config Methods */
+		u16val = selected?wps->config_methods:0;
+		if (wps_set_value(data, WPS_TYPE_SEL_REG_CFG_METHODS, &u16val, 0))
+			break;
+
+		if (wps_write_wps_data(data, &msg, &msg_len))
+			break;
+
+		if (upnp_wps_ctrlpt_send_set_selected_registrar(sm->upnp_ctrlpt_sm,
+														control_url,
+														msg, msg_len))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (msg)
+		free(msg);
+	(void)wps_destroy_wps_data(&data);
+
+	return ret;
+}
+
+
+static void
+wps_opt_upnp_build_req_timer(void *priv, void *control_url)
+{
+	struct wps_opt_upnp_sm *sm;
+	struct opt_upnp_device_node *node;
+	struct wps_config *conf;
+	struct eap_wps_data *data;
+	u8 *rsp = 0;
+	size_t rsp_len;
+
+	do {
+		if (!priv || !control_url)
+			break;
+
+		sm = priv;
+		if (!sm->ctx)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (!conf)
+			break;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_lock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		do {
+			if (wps_opt_upnp_get_device_node(sm, control_url, &node)) {
+				break;
+			}
+
+			data = node->info.data;
+			if (!data)
+				break;
+
+			rsp = wps_opt_upnp_build_req_registrar(sm, control_url,
+												   conf, data,
+												   &rsp_len);
+		} while (0);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		ReleaseMutex(sm->mutex_devlist);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_unlock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		if (rsp) {
+			switch (data->reg_mode) {
+			case WPS_REGMODE_CONFIGURE_AP:
+				if (upnp_wps_ctrlpt_send_put_message(sm->upnp_ctrlpt_sm,
+													 control_url,
+													 rsp, rsp_len))
+					break;
+				break;
+			case WPS_REGMODE_REGISTER_STA:
+				if (upnp_wps_ctrlpt_send_put_wlan_response(sm->upnp_ctrlpt_sm,
+													 control_url,
+													 UPNP_WPS_WLANEVENT_TYPE_EAP,
+#ifdef CONFIG_NATIVE_WINDOWS
+													 conf->mac,
+#endif /* CONFIG_NATIVE_WINDOWS */
+													 rsp, rsp_len))
+					break;
+				break;
+			default:
+				break;
+			}
+		}
+	} while (0);
+
+	if (rsp)
+		free(rsp);
+	if (control_url)
+		free(control_url);
+}
+
+
+static int
+wps_opt_upnp_received_resp_get_device_info(void *priv,
+										   char *control_url,
+										   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm;
+	struct opt_upnp_device_node *node;
+	struct wps_config *conf;
+	struct eap_wps_data *data;
+	char *ctrl_url = 0;
+
+	do {
+		if (!priv || !control_url || !msg)
+			break;
+
+		sm = priv;
+		if (!sm->ctx)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (!conf)
+			break;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_lock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		do {
+			conf->reg_mode = WPS_REGMODE_CONFIGURE_AP;
+			node = wps_opt_upnp_add_device_node(sm, control_url);
+			if (!node)
+				break;
+
+			data = node->info.data;
+			if (!data)
+				break;
+
+			if (wps_opt_upnp_process_registrar(sm, control_url,
+											   conf, data,
+											   msg, msg_len)) {
+				wps_opt_upnp_remove_device_node(sm, control_url);
+				break;
+			}
+
+			if (FAILURE == data->state)
+				wps_opt_upnp_remove_device_node(sm, control_url);
+			else {
+				ctrl_url = os_strdup(control_url);
+				if (!ctrl_url)
+					break;
+				eloop_register_timeout(0, 0, wps_opt_upnp_build_req_timer, sm, ctrl_url);
+			}
+			ret = 0;
+		} while (0);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		ReleaseMutex(sm->mutex_devlist);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_unlock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+	} while (0);
+
+	if (ret && ctrl_url)
+		free(ctrl_url);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_resp_put_message(void *priv,
+									   char *control_url,
+									   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm;
+	struct opt_upnp_device_node *node;
+	struct wps_config *conf;
+	struct eap_wps_data *data;
+	char *ctrl_url = 0;
+
+	do {
+		if (!priv || !control_url || !msg)
+			break;
+
+		sm = priv;
+		if (!sm->ctx)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (!conf)
+			break;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_lock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		do {
+			if (wps_opt_upnp_get_device_node(sm, control_url, &node))
+				break;
+
+			data = node->info.data;
+			if (!data)
+				break;
+
+			if (wps_opt_upnp_process_registrar(sm, control_url,
+											   conf, data,
+											   msg, msg_len)) {
+				wps_opt_upnp_remove_device_node(sm, control_url);
+				break;
+			}
+
+			if (FAILURE == data->state)
+				wps_opt_upnp_remove_device_node(sm, control_url);
+			else {
+				ctrl_url = os_strdup(control_url);
+				if (!ctrl_url)
+					break;
+				eloop_register_timeout(0, 0, wps_opt_upnp_build_req_timer, sm, ctrl_url);
+			}
+			ret = 0;
+		} while (0);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		ReleaseMutex(sm->mutex_devlist);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_unlock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+	} while (0);
+
+	if (ret && ctrl_url)
+		free(ctrl_url);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_wlan_event(void *priv,
+								 char *control_url,
+								 int event_type,
+								 char *event_mac,
+								 u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm;
+	struct opt_upnp_device_node *node;
+	struct wps_config *conf;
+	struct eap_wps_data *data;
+	char *ctrl_url = 0;
+
+	do {
+		if (!priv || !control_url || !msg)
+			break;
+
+		sm = priv;
+		if (!sm->ctx)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (!conf)
+			break;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_lock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		do {
+			if (WPS_MSGTYPE_M1 == wps_get_message_type(msg, msg_len)) {
+				int state = START;
+				conf->reg_mode = WPS_REGMODE_REGISTER_STA;
+				do {
+					if (wps_opt_upnp_get_device_node(sm, control_url, &node))
+						break;
+
+					data = node->info.data;
+					if (!data)
+						break;
+
+					if (DONE != data->state)
+						break;
+
+					state = DONE;
+				} while (0);
+
+				node = wps_opt_upnp_add_device_node(sm, control_url);
+				if (!node)
+					break;
+
+				data = node->info.data;
+				if (!data)
+					break;
+
+				data->state = state;
+			} else if (wps_opt_upnp_get_device_node(sm, control_url, &node))
+				break;
+
+			data = node->info.data;
+			if (!data)
+				break;
+
+			node->info.event_type = event_type;
+			os_snprintf(node->info.event_mac, sizeof(node->info.event_mac), "%s", event_mac);
+
+			if (wps_opt_upnp_process_registrar(sm, control_url,
+											   conf, data,
+											   msg, msg_len)) {
+				wps_opt_upnp_remove_device_node(sm, control_url);
+				break;
+			}
+
+			if (FAILURE == data->state) {
+				if ((conf->cur_upnp_device) &&
+					!os_strcmp(control_url, conf->cur_upnp_device)) {
+					free(conf->cur_upnp_device);
+					conf->cur_upnp_device = 0;
+				}
+				wps_opt_upnp_remove_device_node(sm, control_url);
+			} else {
+				ctrl_url = os_strdup(control_url);
+				if (!ctrl_url)
+					break;
+				eloop_register_timeout(0, 0, wps_opt_upnp_build_req_timer, sm, ctrl_url);
+			}
+			ret = 0;
+		} while (0);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		ReleaseMutex(sm->mutex_devlist);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_unlock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+	} while (0);
+
+	if (ret && ctrl_url)
+		free(ctrl_url);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_ap_status(void *priv,
+								char *control_url, u8 status)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm;
+
+	do {
+		if (!priv || !control_url)
+			break;
+
+		sm = priv;
+
+		ret = 0;
+	} while (0);
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_sta_status(void *priv,
+								 char *control_url, u8 status)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm;
+
+	do {
+		if (!priv || !control_url)
+			break;
+
+		sm = priv;
+
+		ret = 0;
+	} while (0);
+	return ret;
+}
+
+
+struct wps_opt_upnp_sm *
+wps_opt_upnp_sm_init(struct wps_opt_upnp_sm_ctx *ctx)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = 0;
+	struct upnp_wps_ctrlpt_ctx *cp_ctx = 0;
+	struct upnp_wps_ctrlpt_sm *cp = 0;
+	struct wps_config *conf;
+
+	do {
+		cp_ctx = wpa_zalloc(sizeof(*cp_ctx));
+		if (!cp_ctx)
+			break;
+		cp_ctx->received_resp_get_device_info = 
+			wps_opt_upnp_received_resp_get_device_info;
+		cp_ctx->received_resp_put_message = 
+			wps_opt_upnp_received_resp_put_message;
+		cp_ctx->received_wlan_event = 
+			wps_opt_upnp_received_wlan_event;
+		cp_ctx->received_ap_status = 
+			wps_opt_upnp_received_ap_status;
+		cp_ctx->received_sta_status = 
+			wps_opt_upnp_received_sta_status;
+
+		sm = wpa_zalloc(sizeof(*sm));
+		if (!sm)
+			break;
+		sm->ctx = ctx;
+#ifdef CONFIG_NATIVE_WINDOWS
+		sm->mutex_devlist = CreateMutex(0, 0, 0);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_init(&sm->mutex_devlist, 0);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		cp = upnp_wps_ctrlpt_init(cp_ctx, sm);
+		if (!cp)
+			break;
+		sm->upnp_ctrlpt_sm = cp;
+
+		if (!sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+		if (!conf)
+			break;
+
+		if (conf->upnp_iface) {
+			if (upnp_wps_ctrlpt_start(sm->upnp_ctrlpt_sm, conf->upnp_iface))
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (sm) {
+			wps_opt_upnp_sm_deinit(sm);
+			sm = 0;
+		} else if (cp)
+			upnp_wps_ctrlpt_deinit(cp);
+		else if (cp_ctx)
+			free(cp_ctx);
+	}
+
+	return sm;
+}
+
+
+void wps_opt_upnp_sm_deinit(struct wps_opt_upnp_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		WaitForSingleObject(sm->mutex_devlist, INFINITE);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_lock(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		wps_opt_upnp_remove_all_device_node(sm);
+		upnp_wps_ctrlpt_deinit(sm->upnp_ctrlpt_sm);
+
+#ifdef CONFIG_NATIVE_WINDOWS
+		ReleaseMutex(sm->mutex_devlist);
+		CloseHandle(sm->mutex_devlist);
+#else /* CONFIG_NATIVE_WINDOWS */
+		ithread_mutex_unlock(&sm->mutex_devlist);
+		ithread_mutex_destroy(&sm->mutex_devlist);
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+		free(sm->ctx);
+		free(sm);
+	} while (0);
+}
+
+
+int wps_opt_upnp_sm_start(struct wps_opt_upnp_sm *sm, char *net_if)
+{
+	int ret = -1;
+
+	do {
+		if (!sm)
+			break;
+
+		if (upnp_wps_ctrlpt_start(sm->upnp_ctrlpt_sm, net_if))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+
+}
+
+
+int wps_opt_upnp_sm_stop(struct wps_opt_upnp_sm *sm)
+{
+	int ret = -1;
+	struct wps_config *conf;
+
+	do {
+		if (!sm)
+			break;
+
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   (sm->ctx->get_conf(sm->ctx->ctx))->wps:0;
+		if (conf && conf->cur_upnp_device) {
+			(void)wps_opt_upnp_set_selected_registrar(sm,
+									conf->cur_upnp_device,
+									0);
+		}
+
+		if (upnp_wps_ctrlpt_stop(sm->upnp_ctrlpt_sm))
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+
+}
+
+
Index: eap_wps.c
===================================================================
--- eap_wps.c	(revision 0)
+++ eap_wps.c	(revision 2)
@@ -0,0 +1,4791 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: eap_wps.c
+//  Description: EAP-WPS main source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "eloop.h"
+#include "wps_config.h"
+#include "wpa_supplicant_i.h"
+#include "wpa_supplicant.h"
+#include "eap_i.h"
+#include "eap_wps.h"
+#include "wps_parser.h"
+#include "wpa_ctrl.h"
+
+#include <openssl/rand.h>
+#include <openssl/bn.h>
+#include <openssl/dh.h>
+#include <openssl/sha.h>
+#include <openssl/hmac.h>
+#include <openssl/aes.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+
+#define EAP_OPCODE_WPS_START	0x01
+#define EAP_OPCODE_WPS_ACK		0x02
+#define EAP_OPCODE_WPS_NACK		0x03
+#define EAP_OPCODE_WPS_MSG		0x04
+#define EAP_OPCODE_WPS_DONE		0x05
+#define EAP_OPCODE_WPS_FLAG_ACK	0x06
+
+#define EAP_FLAG_MF	0x01
+#define EAP_FLAG_LF	0x02
+
+#define EAP_VENDOR_ID_WPS	"\x00\x37\x2a"
+#define EAP_VENDOR_TYPE_WPS	"\x00\x00\x00\x01"
+
+#define EAP_WPS_PBC_PERIOD_SEC		1
+#define EAP_WPS_PBC_PERIOD_USEC		0
+#define EAP_WPS_PBC_TIMEOUT_SEC		120
+#define EAP_WPS_PBC_TIMEOUT_USEC	120
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+static u8 DH_P_VALUE[SIZE_1536_BITS] = 
+{
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
+    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
+    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
+    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
+    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
+    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
+    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
+    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
+    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
+    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
+    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
+    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
+    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
+    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
+    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
+    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,
+    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
+    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,
+    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
+    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
+    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
+    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x23, 0x73, 0x27,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+static u32 DH_G_VALUE = 2;
+
+struct eap_format {
+	u8 type;
+	u8 vendor_id[3];
+	u8 vendor_type[4];
+	u8 op_code;
+	u8 flags;
+};
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+static int eap_wps_clear_target_info(struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+
+	do {
+		if (!data || !data->target)
+			break;
+
+		target = data->target;
+
+		if (target->manufacturer)
+			os_free(target->manufacturer);
+		if (target->model_name)
+			os_free(target->model_name);
+		if (target->model_number)
+			os_free(target->model_number);
+		if (target->serial_number)
+			os_free(target->serial_number);
+		if (target->dev_name)
+			os_free(target->dev_name);
+		if (target->config) {
+			os_free(target->config);
+			target->config = 0;
+			target->config_len = 0;
+		}
+
+		os_memset(target, 0, sizeof(*target));
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_config_init_data(struct wps_config *conf, struct eap_wps_data *data)
+{
+	int ret = -1;
+
+	do {
+		if (!conf || !data)
+			break;
+
+		data->target = wpa_zalloc(sizeof(*data->target));
+		if (!data->target)
+			break;
+
+		if (conf->dev_pwd_len) {
+			data->dev_pwd_id = conf->dev_pwd_id;
+			os_memcpy(data->dev_pwd, conf->dev_pwd, conf->dev_pwd_len);
+			data->dev_pwd_len = conf->dev_pwd_len;
+		}
+
+		if (conf->set_pub_key) {
+			os_memcpy(data->pubKey, conf->pub_key, sizeof(data->pubKey));
+			if (conf->dh_secret)
+				data->dh_secret = (DH *)conf->dh_secret;
+			data->preset_pubKey = 1;
+		}
+
+		if (conf->config) {
+			data->config = (u8 *)os_malloc(conf->config_len);
+			if (!data->config)
+				break;
+			os_memcpy(data->config, conf->config, conf->config_len);
+			data->config_len = conf->config_len;
+		}
+
+		data->reg_mode = conf->reg_mode;
+
+		data->state = START;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_init_data(struct eap_sm *sm, struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+	const u8 *pwd;
+	size_t pwd_len;
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_init_data(conf, data))
+			break;
+
+		pwd = eap_get_config_password(sm, &pwd_len);
+		if (pwd && pwd_len) {
+			if (pwd_len > sizeof(data->dev_pwd))
+				pwd_len = sizeof(data->dev_pwd);
+
+			if (8 == pwd_len) {
+				if (eap_wps_device_password_validation(pwd, (int)pwd_len))
+					data->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+				else
+					data->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			} else
+				data->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+			os_memcpy(data->dev_pwd, pwd, pwd_len);
+			data->dev_pwd_len = pwd_len;
+
+			if (data->preset_pubKey) {
+				os_memset(data->pubKey, 0, sizeof(data->pubKey));
+				data->dh_secret = 0;
+				data->preset_pubKey = 0;
+			}
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static void *eap_wps_init(struct eap_sm *sm)
+{
+	int result = -1;
+	struct eap_wps_data *data;
+
+	do {
+		data = wpa_zalloc(sizeof(*data));
+		if (data == NULL)
+			break;
+
+		if (eap_wps_init_data(sm, data))
+			break;
+
+		sm->eap_method_priv = data;
+		result = 0;
+	} while (0);
+
+	if (result) {
+		os_free(data);
+		data = 0;
+	}
+
+	return data;
+}
+
+
+void eap_wps_config_deinit_data(struct eap_wps_data *data)
+{
+	do {
+		if (!data)
+			break;
+
+		if (data->rcvMsg) {
+			os_free(data->rcvMsg);
+			data->rcvMsg = 0;
+			data->rcvMsgLen = 0;
+			data->fragment = 0;
+		}
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+
+		if (!data->preset_pubKey && data->dh_secret) {
+			DH_free(data->dh_secret);
+			data->dh_secret = 0;
+		}
+
+		if (data->config) {
+			os_free(data->config);
+			data->config = 0;
+			data->config_len = 0;
+		}
+
+		if (data->target) {
+			eap_wps_clear_target_info(data);
+			os_free(data->target);
+			data->target = 0;
+		}
+
+		os_free(data);
+	} while (0);
+}
+
+static void eap_wps_deinit(struct eap_sm *sm, void *priv)
+{
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+
+	eap_wps_config_deinit_data(data);
+}
+
+
+static void eap_wps_request(struct eap_sm *sm,
+							int req_type, const char *msg, size_t msg_len)
+{
+#define CTRL_REQ_TYPE_COMP			0
+#define CTRL_REQ_TYPE_FAIL			1
+#define CTRL_REQ_TYPE_PASSWORD		2
+	char *buf;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (sm == NULL)
+		return;
+
+	switch(req_type) {
+	case CTRL_REQ_TYPE_COMP:
+		field = "EAP_WPS_COMP";
+		txt = "Complete EAP-WPS authentication";
+		break;
+	case CTRL_REQ_TYPE_FAIL:
+		field = "EAP_WPS_FAIL";
+		txt = "Fail EAP-WPS authentication";
+		break;
+	case CTRL_REQ_TYPE_PASSWORD:
+		field = "EAP_WPS_PASSWORD";
+		txt = "Request Password for EAP-WPS";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		os_free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	wpa_msg(sm->msg_ctx, MSG_INFO, "%s", buf);
+	os_free(buf);
+}
+
+
+int eap_wps_generate_sha256hash(u8 *inbuf, int inbuf_len, u8 *outbuf)
+{
+	int ret = -1;
+
+	do {
+		if (!inbuf || !inbuf_len || !outbuf)
+			break;
+
+		if (!SHA256(inbuf, inbuf_len, outbuf))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_free_dh(void **dh)
+{
+	int ret = -1;
+	do {
+		if (!dh || !*dh)
+			break;
+
+		DH_free(*dh);
+		*dh = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_generate_public_key(void **dh_secret, u8 *public_key)
+{
+	int ret = -1;
+	u8 tmp[SIZE_PUB_KEY];
+	DH *dh = 0;
+	u32 g;
+	int length;
+
+	do {
+		if (!dh_secret || !public_key)
+			break;
+
+		*dh_secret = 0;
+
+		dh = DH_new();
+		if(!dh)
+			break;
+
+		dh->p = BN_new();
+		if (!dh->p)
+			break;
+
+		dh->g = BN_new();
+		if (!dh->g)
+			break;
+	   
+		if(!BN_bin2bn(DH_P_VALUE, SIZE_1536_BITS, dh->p))
+			break;
+
+		g = host_to_be32(DH_G_VALUE);
+		if(!BN_bin2bn((u8 *)&g, 4, dh->g))
+			break;
+
+		if(!DH_generate_key(dh))
+			break;
+
+		length = BN_bn2bin(dh->pub_key, tmp);
+		if (!length)
+			break;
+
+		length = BN_bn2bin(dh->pub_key, public_key);
+		if (!length)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && dh) {
+		DH_free(dh);
+	} else if (dh) {
+		*dh_secret = dh;
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_generate_kdk(struct eap_wps_data *data, u8 *e_nonce, u8 *mac,
+								u8 *r_nonce, u8 *kdk)
+{
+	int ret = -1;
+	DH *dh_secret = (DH *)data->dh_secret;
+	BIGNUM *bn_peer = 0;
+	u8 sec_key[SIZE_PUB_KEY];
+	int sec_key_len;
+	u8 sec_key_sha[SIZE_256_BITS];
+	u8 kdk_src[SIZE_NONCE + SIZE_MAC_ADDR + SIZE_NONCE];
+	int kdk_src_len;
+
+	do {
+		if (!dh_secret || !e_nonce || !mac || !r_nonce || !kdk)
+			break;
+
+		bn_peer = BN_new();
+		if (!bn_peer)
+			break;
+
+		if (!BN_bin2bn(data->target->pubKey, SIZE_PUB_KEY, bn_peer))
+			break;
+
+		sec_key_len = DH_compute_key(sec_key, bn_peer, dh_secret);
+		if (-1 == sec_key_len)
+			break;
+
+		if (!SHA256(sec_key, sec_key_len, sec_key_sha))
+			break;
+
+		kdk_src_len = 0;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, e_nonce, SIZE_NONCE);
+		kdk_src_len += SIZE_NONCE;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, mac, SIZE_MAC_ADDR);
+		kdk_src_len += SIZE_MAC_ADDR;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, r_nonce, SIZE_NONCE);
+		kdk_src_len += SIZE_NONCE;
+		if (!HMAC(EVP_sha256(), sec_key_sha, SIZE_256_BITS,
+				  kdk_src, kdk_src_len, kdk, NULL))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (bn_peer)
+		BN_free(bn_peer);
+
+	return ret;
+}
+
+
+static int eap_wps_key_derive_func(struct eap_wps_data *data, 
+						   u8 *kdk, char *personalization, u32 total_key_bits,
+						   u8 *keys, u32 *keys_len_bytes)
+{
+	int ret = -1;
+	u8 *prf;
+	u32 prf_len, iterations;
+	u8 *hmac = 0, *pos;
+	u32 hmac_len = 0, length = 0;
+	u32 i;
+
+	do {
+		prf_len = sizeof(u32) + os_strlen(personalization) + sizeof(u32);
+		prf = (u8 *)os_malloc(prf_len);
+		if (!prf)
+			break;
+
+		iterations = ((total_key_bits/8) + PRF_DIGEST_SIZE - 1) / PRF_DIGEST_SIZE;
+
+		pos = prf + sizeof(u32);
+		os_memcpy(pos, personalization, os_strlen(personalization));
+		pos += os_strlen(personalization);
+		WPA_PUT_BE32(pos, total_key_bits);
+
+		for (i = 1; i <= iterations; i++) {
+			WPA_PUT_BE32(prf, i);
+			length = 0;
+			(void)HMAC(EVP_sha256(), kdk, SIZE_256_BITS, prf, prf_len, 0, &length);
+			hmac = (u8 *)os_realloc(hmac, hmac_len + length);
+			pos = hmac + hmac_len;
+			if (!HMAC(EVP_sha256(), kdk, SIZE_256_BITS, prf, prf_len, pos, &length))
+				break;
+			hmac_len += length;
+		}
+		if (i <= iterations)
+			break; 
+		if ((total_key_bits / 8) > hmac_len)
+			break;
+
+		if (keys_len_bytes) {
+			*keys_len_bytes = total_key_bits / 8;
+		}
+
+		if (!keys)
+			break;
+		os_memcpy(keys, hmac, total_key_bits / 8);
+
+		ret = 0;
+	} while (0);
+
+	if (prf)
+		os_free(prf);
+	if (hmac)
+		os_free(hmac);
+	return ret;
+}
+
+
+static int eap_wps_hmac_validation(struct eap_wps_data *data, u8 *authenticator, u8 *auth_key)
+{
+	int ret = -1;
+	u8 *hmac_src = 0;
+	u32 hmac_src_len;
+	struct wps_data *wps = 0;
+	u8 *buf = 0;
+	u16 buf_len;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!data || !authenticator || !auth_key)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		if (wps_remove_value(wps, WPS_TYPE_AUTHENTICATOR))
+			break;
+
+		if (wps_write_wps_data(wps, &buf, &buf_len))
+			break;
+
+		hmac_src_len = data->sndMsgLen + buf_len;
+		hmac_src = (u8 *)os_malloc(hmac_src_len);
+		if (!hmac_src)
+			break;
+
+		os_memcpy(hmac_src, data->sndMsg, data->sndMsgLen);
+		os_memcpy(hmac_src + data->sndMsgLen, buf, buf_len);
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, hmac_src, hmac_src_len, hmac, NULL))
+			break;
+
+		if (os_memcmp(hmac, authenticator, SIZE_64_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (hmac_src)
+		os_free(hmac_src);
+	if (buf)
+		os_free(buf);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_encrypt_data(struct eap_wps_data *data,
+								u8 *inbuf, int inbuf_len,
+								u8 *encrKey,
+								u8 *iv, u8 **cipher, int *cipher_len)
+{
+	int ret = -1;
+	EVP_CIPHER_CTX ctx;
+	u8 buf[1024];
+	int buf_len;
+	int length, curr_len; int block_size;
+
+	do {
+		RAND_bytes(iv, SIZE_128_BITS);
+
+		if (!cipher || !cipher_len)
+			break;
+
+		if (!EVP_EncryptInit(&ctx, EVP_aes_128_cbc(), encrKey, iv))
+			break;
+
+		length = inbuf_len;
+		block_size = sizeof(buf) - SIZE_128_BITS;
+
+		*cipher = 0;
+		*cipher_len  = 0;
+		while (length) {
+			if (length > block_size)
+				curr_len = block_size;
+			else
+				curr_len = length;
+
+			if (!EVP_EncryptUpdate(&ctx, buf, &buf_len, inbuf, curr_len))
+				break;
+			*cipher = (u8 *)os_realloc(*cipher, *cipher_len + buf_len);
+			os_memcpy(*cipher + *cipher_len, buf, buf_len);
+			*cipher_len += buf_len;
+			length -= curr_len;
+		}
+
+		if (length)
+			break;
+
+		if (!EVP_EncryptFinal(&ctx, buf, &buf_len))
+			break;
+
+		*cipher = (u8 *)os_realloc(*cipher, *cipher_len + buf_len);
+		os_memcpy(*cipher + *cipher_len, buf, buf_len);
+		*cipher_len += buf_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (cipher_len)
+			*cipher_len = 0;
+		if (cipher && *cipher) {
+			os_free(*cipher);
+			*cipher = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_decrypt_data(struct eap_wps_data *data, u8 *iv,
+								u8 *cipher, int cipher_len,
+								u8 *encrKey, u8 **plain, int *plain_len)
+{
+	int ret = -1;
+	EVP_CIPHER_CTX ctx;
+	u8 buf[1024];
+	int buf_len = sizeof(buf);
+	int length, curr_len;
+	int block_size;
+
+	do {
+		if (!iv || !cipher || !encrKey || !plain || !plain_len)
+			break;
+
+		*plain = 0;
+		*plain_len = 0;
+
+		if (!EVP_DecryptInit(&ctx, EVP_aes_128_cbc(), encrKey, iv))
+			break;
+
+		length = cipher_len;
+		block_size = sizeof(buf) - SIZE_128_BITS;
+
+		while (length) {
+			if (length > block_size)
+				curr_len = block_size;
+			else
+				curr_len = length;
+
+			if (!EVP_DecryptUpdate(&ctx, buf, &buf_len, cipher, curr_len))
+				break;
+			*plain = (u8 *)os_realloc(*plain, *plain_len + buf_len);
+			os_memcpy(*plain + *plain_len, buf, buf_len);
+			*plain_len += buf_len;
+			length -= curr_len;
+		}
+
+		if (length)
+			break;
+
+		if (!EVP_DecryptFinal(&ctx, buf, &buf_len))
+			break;
+
+		*plain = (u8 *)os_realloc(*plain, *plain_len + buf_len);
+		os_memcpy(*plain + *plain_len, buf, buf_len);
+		*plain_len += buf_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (plain_len)
+			*plain_len = 0;
+		if (plain || *plain) {
+			os_free(*plain);
+			*plain = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_encrsettings_creation(struct eap_wps_data *data,
+										 u16 nonce_type, u8 *nonce,
+										 u8 *buf, size_t buf_len,
+										 u8 *auth_key, u8 *key_wrap_auth,
+										 u8 **encrs, int *encrs_len)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 hmac[SIZE_256_BITS];
+	u16 length = 0;
+	u8 *tmp = 0;
+	u8 *cipher = 0, iv[SIZE_128_BITS];
+	int cipher_len;
+
+	do {
+		if (!auth_key || !key_wrap_auth || !encrs || !encrs_len)
+			break;
+
+		*encrs = 0;
+		*encrs_len = 0;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (nonce) {
+			length = SIZE_NONCE;
+			if (wps_set_value(wps, nonce_type, nonce, length))
+				break;
+
+			length = 0;
+			if (wps_write_wps_data(wps, &tmp, &length))
+				break;
+		}
+
+		if (buf && buf_len) {
+			(void)wps_destroy_wps_data(&wps);
+
+			tmp = os_realloc(tmp, length + buf_len);
+			if (!tmp)
+				break;
+			os_memcpy(tmp + length, buf, buf_len);
+			length += buf_len;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(tmp, length, wps))
+				break;
+		}
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, tmp, length, hmac, NULL))
+			break;
+
+		if (wps_set_value(wps, WPS_TYPE_KEY_WRAP_AUTH, hmac, SIZE_64_BITS))
+			break;
+
+		os_free(tmp);
+		tmp = 0;
+
+		length = 0;
+		if (wps_write_wps_data(wps, &tmp, &length))
+			break;
+
+		if (eap_wps_encrypt_data(data, tmp, length, key_wrap_auth, iv, &cipher, &cipher_len))
+			break;
+
+		*encrs = os_malloc(SIZE_128_BITS + cipher_len);
+		if (!*encrs)
+			break;
+		os_memcpy(*encrs, iv, SIZE_128_BITS);
+		os_memcpy(*encrs + SIZE_128_BITS, cipher, cipher_len);
+		*encrs_len = SIZE_128_BITS + cipher_len;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (cipher)
+		os_free(cipher);
+
+	if (ret) {
+		if (encrs_len)
+			*encrs_len = 0;
+		if (encrs && *encrs) {
+			os_free(*encrs);
+			*encrs = 0;
+		}
+	}
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_encrsettings_validation(struct eap_wps_data *data,
+										   u8 *plain, int plain_len,
+										   u8 *auth_key, u16 nonce_type,
+										   u8 *nonce, u8 *key_wrap_auth)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u16 length;
+	u8 *buf = 0;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!plain || !plain_len || !key_wrap_auth)
+			break;
+		
+		if (wps_create_wps_data(&wps))
+			break;
+		if (wps_parse_wps_data(plain, plain_len, wps))
+			break;
+
+		if (nonce) {
+		/* Nonce */
+			length = SIZE_NONCE;
+			if (wps_get_value(wps, nonce_type, nonce, &length))
+				break;
+		}
+
+		/* Key Wrap Authenticator */
+		length = SIZE_8_BYTES;
+		if (wps_get_value(wps, WPS_TYPE_KEY_WRAP_AUTH, key_wrap_auth, &length))
+			break;
+
+		if (wps_remove_value(wps, WPS_TYPE_KEY_WRAP_AUTH))
+			break;
+
+		length = 0;
+		if (wps_write_wps_data(wps, &buf, &length))
+			break;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, buf, length, hmac, NULL))
+			break;
+
+		if (os_memcmp(hmac, key_wrap_auth, SIZE_64_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (nonce)
+			os_memset(nonce, 0, SIZE_NONCE);
+		if (key_wrap_auth)
+			os_memset(key_wrap_auth, 0, SIZE_8_BYTES);
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_generate_hash(struct eap_wps_data *data,
+								  u8 *src, int src_len,
+								  u8 *pub_key1, u8 *pub_key2,
+								  u8 *auth_key,
+								  u8 *psk, u8 *es, u8 *hash)
+{
+	int ret = -1;
+	u8 hash_tmp[SIZE_256_BITS];
+	u8 hash_src[SIZE_128_BITS * 2 + SIZE_PUB_KEY * 2];
+	u8 *tmp;
+
+	do {
+		if (!src || !pub_key1 || !pub_key2 || !psk || !es || !auth_key)
+			break;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, src, src_len,
+			 hash_tmp, NULL))
+			break;
+		os_memcpy(psk, hash_tmp, SIZE_128_BITS);
+
+		RAND_bytes(es, SIZE_128_BITS);
+
+		tmp = hash_src;
+		os_memcpy(tmp, es, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, psk, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, pub_key1, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+		os_memcpy(tmp, pub_key2, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS,
+				  hash_src, tmp - hash_src, hash, NULL))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_generate_device_password_id(u16 *dev_pwd_id)
+{
+	int ret = -1;
+
+	do {
+		if (!dev_pwd_id)
+			break;
+
+		RAND_bytes((u8 *)dev_pwd_id, 2);
+		*dev_pwd_id |= 0x8000;
+		*dev_pwd_id &= 0xfff0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 eap_wps_compute_device_password_checksum(u32 pin)
+{
+	u32 acc = 0;
+	u32 tmp = pin * 10;
+
+	acc += 3 * ((tmp / 10000000) % 10);
+	acc += 1 * ((tmp / 1000000) % 10);
+	acc += 3 * ((tmp / 100000) % 10);
+	acc += 1 * ((tmp / 10000) % 10);
+	acc += 3 * ((tmp / 1000) % 10);
+	acc += 1 * ((tmp / 100) % 10);
+	acc += 3 * ((tmp / 10) % 10);
+
+	return (u8)(10 - (acc % 10)) % 10;
+}
+
+
+int eap_wps_generate_device_password(u8 *dev_pwd, int dev_pwd_len)
+{
+	int ret = -1;
+
+	do {
+		if (!dev_pwd || !dev_pwd_len)
+			break;
+
+		RAND_bytes(dev_pwd, dev_pwd_len);
+		if (8 == dev_pwd_len) {
+			u32 val;
+			u8 check_sum, tmp[9];
+			val = *(u32 *)dev_pwd;
+			check_sum = eap_wps_compute_device_password_checksum(val);
+			val = val * 10 + check_sum;
+			os_snprintf((char *)tmp, 9, "%08u", val);
+			os_memcpy(dev_pwd, tmp, 8);
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_oobdevpwd_public_key_hash_validation(const u8 *hashed, const u8 *raw)
+{
+	int ret = -1;
+	u8 src[SIZE_256_BITS];
+
+	do {
+		if (!hashed || !raw)
+			break;
+
+		if (eap_wps_generate_sha256hash((u8 *)raw, SIZE_PUB_KEY, src))
+			break;
+
+		if (os_memcmp(hashed, src, SIZE_20_BYTES))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_device_password_validation(const u8 *pwd, const int len)
+{
+	int ret = -1;
+	u32 pin;
+	char str_pin[9], *end;
+	u8 check_sum;
+
+	do {
+		if (!pwd || 8 != len)
+			break;
+
+		os_memcpy(str_pin, pwd, 8);
+		str_pin[8] = 0;
+		pin = strtoul(str_pin, &end, 10);
+		if (end != (str_pin + 8))
+			break;
+
+		check_sum = eap_wps_compute_device_password_checksum(pin / 10);
+		if (check_sum != (u8)(pin % 10))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_calcurate_authenticator(struct eap_wps_data *data,
+										   u8 *sndmsg, size_t sndmsg_len,
+										   u8 *auth_key, u8 *authenticator)
+{
+	int ret = -1;
+	u8 *hmac_src = 0;
+	int hmac_src_len;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!data || !sndmsg || !authenticator)
+			break;
+
+		hmac_src_len = data->rcvMsgLen + sndmsg_len;
+		hmac_src = (u8 *)os_malloc(hmac_src_len);
+		os_memcpy(hmac_src, data->rcvMsg, data->rcvMsgLen);
+		os_memcpy(hmac_src + data->rcvMsgLen, sndmsg, sndmsg_len);
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS,
+				  hmac_src, hmac_src_len, hmac, NULL))
+			break;
+
+		os_memcpy(authenticator, hmac, SIZE_64_BITS);
+
+		ret = 0;
+	} while (0);
+
+	if (hmac_src)
+		os_free(hmac_src);
+
+	return ret;
+}
+
+
+static int eap_wps_hash_validation(struct eap_wps_data *data,
+								   u8 *compared,
+								   u8 *rsnonce, u8 *psk,
+								   u8 *pub_key1, u8 *pub_key2,
+								   u8 *auth_key)
+{
+	int ret = -1;
+	u8 hash_src[SIZE_128_BITS * 2 + SIZE_PUB_KEY * 2];
+	u8 *tmp;
+	u8 target[SIZE_256_BITS];
+
+	do {
+		if (!compared || !rsnonce || !psk || !pub_key1 || !pub_key2 || !auth_key)
+			break;
+
+		tmp = hash_src;
+		os_memcpy(tmp, rsnonce, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, psk, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, pub_key1, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+		os_memcpy(tmp, pub_key2, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, hash_src, tmp - hash_src, target, NULL))
+			 	break;
+
+		if (os_memcmp(compared, target, SIZE_256_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_config_select_ssid_configuration(struct wps_config *conf,
+											 struct eap_wps_data *data,
+											 u8 *raw_data, size_t raw_data_len,
+											 Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 *val = 0;
+	u16 val_len;
+	u8 id;
+	int index = -1;
+
+
+	do {
+		if (!conf || !data || !raw_data || !raw_data_len)
+			break;
+
+		/* Creadential */
+		val_len = 0;
+		if (wrap_credential) {
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(raw_data, raw_data_len, wps))
+				break;
+
+			(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, 0, &val_len);
+			if (!val_len)
+				break;
+			val = (u8 *)os_malloc(val_len);
+			if (!val)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_CREDENTIAL, val, &val_len))
+				break;
+
+			(void)wps_destroy_wps_data(&wps);
+		} else {
+			val = (u8 *)os_malloc(raw_data_len);
+			if (!val)
+				break;
+			os_memcpy(val, raw_data, raw_data_len);
+			val_len = raw_data_len;
+		}
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(val, val_len, wps))
+			break;
+
+		if (wps_get_value(wps, WPS_TYPE_NW_INDEX, &id, 0))
+			break;
+
+		index = (int)id;
+		ret = 0;
+	} while (0);
+
+	if (val)
+		os_free(val);
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret && (0 <= index))
+		index = -1;
+
+	return index;
+}
+
+
+static int eap_wps_select_ssid_configuration(struct eap_sm *sm,
+											 struct eap_wps_data *data,
+											 u8 *raw_data, size_t raw_data_len,
+											 Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+	int index;
+	char msg[10];
+
+	do {
+		if (!data || !raw_data || !raw_data_len || !conf)
+			break;
+
+		index = eap_wps_config_select_ssid_configuration(conf, data,
+														 raw_data, raw_data_len,
+														 wrap_credential);
+		if (0 > index)
+			break;
+
+		os_snprintf(msg, sizeof(msg), "%d", index);
+		eap_wps_request(sm, CTRL_REQ_TYPE_COMP, msg, os_strlen(msg));
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_config_set_ssid_configuration(struct wps_config *conf,
+										  void *wpa_s,
+										  u8 *raw_data, size_t raw_data_len,
+										  Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 *val = 0;
+	u16 val_len;
+	int index = -1;
+
+
+	do {
+		if (!conf || !wpa_s || !raw_data || !raw_data_len)
+			break;
+
+		/* Creadential */
+		val_len = 0;
+		if (wrap_credential) {
+			u8 nwIdx;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(raw_data, raw_data_len, wps))
+				break;
+
+			(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, 0, &val_len);
+			if (!val_len)
+				break;
+			val = (u8 *)os_malloc(val_len);
+			if (!val)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_CREDENTIAL, val, &val_len))
+				break;
+
+			(void)wps_destroy_wps_data(&wps);
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(val, val_len, wps))
+				break;
+
+			/* Network Index */
+			if (!wps_get_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, NULL))
+			/** Ignore Network Index **/
+				(void)wps_remove_value(wps, WPS_TYPE_NW_INDEX);
+
+			os_free(val);
+			val = 0;
+			val_len = 0;
+
+			if (wps_write_wps_data(wps, &val, &val_len))
+				break;
+		} else {
+			val = (u8 *)os_malloc(raw_data_len);
+			if (!val)
+				break;
+			os_memcpy(val, raw_data, raw_data_len);
+			val_len = raw_data_len;
+		}
+
+		index = wps_set_ssid_configuration(wpa_s, val, val_len);
+		if (0 > index)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (val)
+		os_free(val);
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret && (0 <= index))
+		index = -1;
+
+	return index;
+}
+
+
+static int eap_wps_set_ssid_configuration(struct eap_sm *sm,
+										  struct eap_wps_data *data,
+										  u8 *raw_data, size_t raw_data_len,
+										  Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+	int index;
+	char msg[10];
+
+
+	do {
+		if (!sm || !data || !raw_data || !raw_data_len || !conf)
+			break;
+
+		index = eap_wps_config_set_ssid_configuration(conf,
+													  sm->msg_ctx,
+													  raw_data, raw_data_len,
+													  wrap_credential);
+		if (0 > index)
+			break;
+
+		os_snprintf(msg, 10, "%d", index);
+		eap_wps_request(sm, CTRL_REQ_TYPE_COMP, msg, os_strlen(msg));
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M1(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !msg_len)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M1;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* UUID-E */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_E, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* MAC Address */
+		if (!conf->mac_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, conf->mac, sizeof(conf->mac)))
+			break;
+
+		/* Enrollee Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* Public Key */
+		if (!data->preset_pubKey) {
+			if (data->dh_secret)
+				eap_wps_free_dh((void **)&data->dh_secret);
+			if (eap_wps_generate_public_key(&data->dh_secret, data->pubKey))
+				break;
+		}
+		if (wps_set_value(wps, WPS_TYPE_PUBLIC_KEY, data->pubKey, sizeof(data->pubKey)))
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &conf->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &conf->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &conf->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_METHODS, &conf->config_methods, 0))
+			break;
+
+		/* Wi-Fi Protected Setup State */
+		if (wps_set_value(wps, WPS_TYPE_WPSSTATE, &conf->wps_state, 0))
+			break;
+
+		/* Manufacturer */
+		if (wps_set_value(wps, WPS_TYPE_MANUFACTURER, conf->manufacturer, conf->manufacturer_len))
+			break;
+
+		/* Model Name */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NAME, conf->model_name, conf->model_name_len))
+			break;
+
+		/* Model Number */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NUMBER, conf->model_number, conf->model_number_len))
+			break;
+
+		/* Serial Number */
+		if (wps_set_value(wps, WPS_TYPE_SERIAL_NUM, conf->serial_number, conf->serial_number_len))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps, WPS_TYPE_PRIM_DEV_TYPE, conf->prim_dev_type, sizeof(conf->prim_dev_type)))
+			break;
+
+		/* Device Name */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_NAME, conf->dev_name, conf->dev_name_len))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps, WPS_TYPE_RF_BANDS, &conf->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_set_value(wps, WPS_TYPE_ASSOC_STATE, &data->assoc_state, 0))
+			break;
+
+		/* Device Passwork ID */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_PWD_ID, &data->dev_pwd_id, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &data->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M1(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M1(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M1(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target = data->target;
+	u16 length;
+
+	do {
+		if (!conf || !data)
+			break;
+
+		target = data->target;
+		if (!target)
+			break;
+
+		eap_wps_clear_target_info(data);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &target->version, 0))
+			break;
+		if ((target->version != WPS_VERSION) && (target->version != WPS_VERSION_EX))
+			break;
+
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M1)
+			break;
+
+		/* UUID-E */
+		length = sizeof(target->uuid);
+		if (wps_get_value(wps, WPS_TYPE_UUID_E, target->uuid, &length))
+			break;
+
+		/* MAC Address */
+		length = sizeof(target->mac);
+		if (wps_get_value(wps, WPS_TYPE_MAC_ADDR, target->mac, &length))
+			break;
+		target->mac_set = 1;
+
+		/* Enrollee Nonce */
+		length = sizeof(target->nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, &length))
+			break;
+
+		/* Public Key */
+		length = sizeof(target->pubKey);
+		if (wps_get_value(wps, WPS_TYPE_PUBLIC_KEY, target->pubKey, &length))
+			break;
+		if (data->preset_pubKey) {
+			if (eap_wps_oobdevpwd_public_key_hash_validation(data->pubKey, target->pubKey))
+				break;
+
+			os_memset(data->pubKey, 0, sizeof(data->pubKey));
+			data->preset_pubKey = 0;
+		}
+
+		/* Authentication Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &target->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &target->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &target->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_METHODS, &target->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		(void)wps_get_value(wps, WPS_TYPE_MANUFACTURER, 0, &length);
+		if (!length)
+			break;
+		target->manufacturer = (u8 *)os_malloc(length);
+		target->manufacturer_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MANUFACTURER, target->manufacturer, &length))
+			break;
+
+		/* Model Name */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NAME, 0, &length);
+		if (!length)
+			break;
+		target->model_name = (u8 *)os_malloc(length);
+		target->model_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NAME, target->model_name, &length))
+			break;
+
+		/* Model Number */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, 0, &length);
+		if (!length)
+			break;
+		target->model_number = (u8 *)os_malloc(length);
+		target->model_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, target->model_number, &length))
+			break;
+
+		/* Serial Number */
+		(void)wps_get_value(wps, WPS_TYPE_SERIAL_NUM, 0, &length);
+		if (!length)
+			break;
+		target->serial_number = (u8 *)os_malloc(length);
+		target->serial_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_SERIAL_NUM, target->serial_number, &length))
+			break;
+
+		/* Primary Device Type */
+		length = sizeof(target->prim_dev_type);
+		if (wps_get_value(wps, WPS_TYPE_PRIM_DEV_TYPE, target->prim_dev_type, &length))
+			break;
+
+		/* Device Name */
+		(void)wps_get_value(wps, WPS_TYPE_DEVICE_NAME, 0, &length);
+		if (!length)
+			break;
+		target->dev_name = (u8 *)os_malloc(length);
+		target->dev_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_NAME, target->dev_name, &length))
+			break;
+
+		/* RF Bands */
+		if (wps_get_value(wps, WPS_TYPE_RF_BANDS, &target->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_get_value(wps, WPS_TYPE_ASSOC_STATE, &target->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_get_value(wps, WPS_TYPE_OS_VERSION, &target->os_version, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		eap_wps_clear_target_info(data);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M1(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M1(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_config_build_message_M2_M2D(struct wps_config *conf,
+											   struct eap_wps_data *data,
+											   struct wps_data *wps)
+{
+	int ret = -1;
+
+	do {
+		if (!conf || !data || !wps)
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &conf->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &conf->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &conf->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_METHODS, &conf->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		if (wps_set_value(wps, WPS_TYPE_MANUFACTURER, conf->manufacturer, conf->manufacturer_len))
+			break;
+
+		/* Model Name */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NAME, conf->model_name, conf->model_name_len))
+			break;
+
+		/* Model Number */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NUMBER, conf->model_number, conf->model_number_len))
+			break;
+
+		/* Serial Number */
+		if (wps_set_value(wps, WPS_TYPE_SERIAL_NUM, conf->serial_number, conf->serial_number_len))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps, WPS_TYPE_PRIM_DEV_TYPE, conf->prim_dev_type, sizeof(conf->prim_dev_type)))
+			break;
+
+		/* Device Name */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_NAME, conf->dev_name, conf->dev_name_len))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps, WPS_TYPE_RF_BANDS, &conf->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_set_value(wps, WPS_TYPE_ASSOC_STATE, &data->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &data->config_error, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M2(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target = data->target;
+	u8 kdk[SIZE_256_BITS];
+	u8 keys[KDF_KEY_BITS/8];
+	u32 keys_length_bytes;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !msg_len || !target)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M2;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* UUID-R */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_R, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* Public Key */
+		if (!data->preset_pubKey) {
+			if (data->dh_secret)
+				eap_wps_free_dh((void **)&data->dh_secret);
+			if (eap_wps_generate_public_key(&data->dh_secret, data->pubKey))
+				break;
+		}
+		if (wps_set_value(wps, WPS_TYPE_PUBLIC_KEY, data->pubKey, sizeof(data->pubKey)))
+			break;
+
+		/* M2/M2D common data */
+		if (eap_wps_config_build_message_M2_M2D(conf, data, wps))
+			break;
+
+		/* Device Password ID */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_PWD_ID, &data->dev_pwd_id, 0))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		/* Encrypted Settings */
+#if 0
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, encrs_len))
+			break;
+#endif
+
+		/* Generate KDK */
+		if (!target->mac_set)
+			break;
+		if (eap_wps_generate_kdk(data, target->nonce, target->mac, data->nonce, kdk))
+			break;
+
+		/* Key Derivation Function */
+		if (eap_wps_key_derive_func(data, kdk, WPS_PERSONALIZATION_STRING, KDF_KEY_BITS,
+							keys, &keys_length_bytes))
+			break;
+		os_memcpy(data->authKey, keys, SIZE_256_BITS);
+		os_memcpy(data->keyWrapKey, keys + SIZE_256_BITS, SIZE_128_BITS);
+		os_memcpy(data->emsk, keys + SIZE_256_BITS + SIZE_128_BITS, SIZE_256_BITS);
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M2(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M2(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+u8 *eap_wps_config_build_message_M2D(struct wps_config *conf,
+									 struct eap_wps_data *data,
+									 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target = data->target;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !msg_len || !target)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M2D;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* UUID-R */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_R, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* M2/M2D common data */
+		if (eap_wps_config_build_message_M2_M2D(conf, data, wps))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M2D(struct eap_sm *sm,
+									 struct eap_wps_data *data,
+									 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M2D(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+static int eap_wps_config_process_message_M2_M2D(struct wps_config *conf,
+												 struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target = data->target;
+	u8 tmp[SIZE_64_BYTES];
+	u16 length;
+
+	do {
+		if (!conf || !data || !target)
+			break;
+
+		eap_wps_clear_target_info(data);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &target->version, 0))
+			break;
+		if ((target->version != WPS_VERSION) && (target->version != WPS_VERSION_EX))
+			break;
+
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if ((msg_type != WPS_MSGTYPE_M2) && (msg_type != WPS_MSGTYPE_M2D))
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(tmp);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, tmp, &length))
+			break;
+		if (os_memcmp(data->nonce, tmp, sizeof(data->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(target->nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, &length))
+			break;
+
+		/* UUID-R */
+		length = sizeof(target->uuid);
+		if (wps_get_value(wps, WPS_TYPE_UUID_R, target->uuid, &length))
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &target->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &target->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &target->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_METHODS, &target->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		(void)wps_get_value(wps, WPS_TYPE_MANUFACTURER, 0, &length);
+		if (!length)
+			break;
+		target->manufacturer = (u8 *)os_malloc(length);
+		target->manufacturer_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MANUFACTURER, target->manufacturer, &length))
+			break;
+
+		/* Model Name */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NAME, 0, &length);
+		if (!length)
+			break;
+		target->model_name = (u8 *)os_malloc(length);
+		target->model_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NAME, target->model_name, &length))
+			break;
+
+		/* Model Number */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, 0, &length);
+		if (!length)
+			break;
+		target->model_number = (u8 *)os_malloc(length);
+		target->model_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, target->model_number, &length))
+			break;
+
+		/* Serial Number */
+		(void)wps_get_value(wps, WPS_TYPE_SERIAL_NUM, 0, &length);
+		if (!length)
+			break;
+		target->serial_number = (u8 *)os_malloc(length);
+		target->serial_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_SERIAL_NUM, target->serial_number, &length))
+			break;
+
+		/* Primary Device Type */
+		length = sizeof(target->prim_dev_type);
+		if (wps_get_value(wps, WPS_TYPE_PRIM_DEV_TYPE, target->prim_dev_type, &length))
+			break;
+
+		/* Device Name */
+		(void)wps_get_value(wps, WPS_TYPE_DEVICE_NAME, 0, &length);
+		if (!length)
+			break;
+		target->dev_name = (u8 *)os_malloc(length);
+		target->dev_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_NAME, target->dev_name, &length))
+			break;
+
+		/* RF Bands */
+		if (wps_get_value(wps, WPS_TYPE_RF_BANDS, &target->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_get_value(wps, WPS_TYPE_ASSOC_STATE, &target->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_get_value(wps, WPS_TYPE_OS_VERSION, &target->os_version, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		eap_wps_clear_target_info(data);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+int eap_wps_config_process_message_M2(struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  Boolean *with_config)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	u8 kdk[SIZE_256_BITS];
+	u8 keys[KDF_KEY_BITS/8];
+	u32 keys_length_bytes;
+	struct eap_wps_target_info *target = data->target;
+	u16 length;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !target)
+			break;
+
+		if (with_config)
+			*with_config = 0;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M2)
+			break;
+
+		if (eap_wps_config_process_message_M2_M2D(conf, data))
+			break;
+
+		/* Public Key */
+		length = sizeof(target->pubKey);
+		if (wps_get_value(wps, WPS_TYPE_PUBLIC_KEY, target->pubKey, &length))
+			break;
+
+		/* Device Password ID */
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_PWD_ID, &target->dev_pwd_id, 0))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* Generate KDK */
+		if (eap_wps_generate_kdk(data, data->nonce, conf->mac, target->nonce, kdk))
+			break;
+
+		/* Key Derivation Function */
+		if (eap_wps_key_derive_func(data, kdk, WPS_PERSONALIZATION_STRING, KDF_KEY_BITS,
+							keys, &keys_length_bytes))
+			break;
+		os_memcpy(data->authKey, keys, SIZE_256_BITS);
+		os_memcpy(data->keyWrapKey, keys + SIZE_256_BITS, SIZE_128_BITS);
+		os_memcpy(data->emsk, keys + SIZE_256_BITS + SIZE_128_BITS, SIZE_256_BITS);
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (length) {
+			u8 *encrs = 0;
+			u8 *iv, *cipher;
+			int cipher_len;
+			u8 *config = 0;
+			int config_len;
+			int fail = 1;
+
+			do {
+				encrs = (u8 *)os_malloc(length);
+				if (!encrs)
+					break;
+				if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, &length))
+					break;
+
+				iv = encrs;
+				cipher = encrs + SIZE_128_BITS;
+				cipher_len = length - SIZE_128_BITS;
+				if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &config, &config_len))
+					break;
+
+				target->config = config;
+				target->config_len = config_len;
+
+				fail = 0;
+			} while (0);
+			
+			if (encrs)
+				os_free(encrs);
+			if (fail && config) {
+				os_free(config);
+				target->config = 0;
+				target->config_len = 0;
+			}
+			if (fail)
+				break;
+
+			if (with_config)
+				*with_config = 1;
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M2(struct eap_sm *sm,
+									  struct eap_wps_data *data,
+									  Boolean *with_config)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M2(conf, data, with_config))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_config_process_message_M2D(struct wps_config *conf,
+									   struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target = data->target;
+
+	do {
+		if (!conf || !data || !target)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M2D)
+			break;
+
+		if (eap_wps_config_process_message_M2_M2D(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M2D(struct eap_sm *sm,
+									   struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M2D(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M3(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M3;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Generate Device Password, if it hasn't been set yet */
+		if (!data->dev_pwd_len) {
+			if (eap_wps_generate_device_password(data->dev_pwd, 8))
+				break;
+			data->dev_pwd_len = 8;
+			data->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			printf("eap_wps : generated device password [%s]\n", data->dev_pwd);
+		}
+
+		/* E-Hash1 */
+		if (eap_wps_generate_hash(data, data->dev_pwd,
+								   data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->pubKey, target->pubKey, data->authKey,
+								   data->psk1, data->snonce1, data->hash1))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_E_HASH1, data->hash1, sizeof(data->hash1)))
+			break;
+
+		/* E-Hash2 */
+		if (eap_wps_generate_hash(data, data->dev_pwd + data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->dev_pwd_len/2,
+								   data->pubKey, target->pubKey, data->authKey,
+								   data->psk2, data->snonce2, data->hash2))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_E_HASH2, data->hash2, sizeof(data->hash2)))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M3(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M3(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M3(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 tmp[SIZE_64_BYTES];
+	u16 length;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M3)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(tmp);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, tmp, &length))
+			break;
+		if (os_memcmp(tmp, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* E-Hash1 */
+		length = sizeof(target->hash1);
+		if (wps_get_value(wps, WPS_TYPE_E_HASH1, target->hash1, &length))
+			break;
+
+		/* E-Hash2 */
+		length = sizeof(target->hash2);
+		if (wps_get_value(wps, WPS_TYPE_E_HASH2, target->hash2, &length))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M3(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M3(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M4(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+	u8 *encrs;
+	int encrs_len;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M4;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		if (!data->dev_pwd_len)
+			break;
+
+		/* R-Hash1 */
+		if (eap_wps_generate_hash(data, data->dev_pwd,
+								   data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   target->pubKey, data->pubKey, data->authKey,
+								   data->psk1, data->snonce1, data->hash1))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_R_HASH1, data->hash1, sizeof(data->hash1)))
+			break;
+
+		/* R-Hash2 */
+		if (eap_wps_generate_hash(data, data->dev_pwd + data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->dev_pwd_len/2,
+								   target->pubKey, data->pubKey, data->authKey,
+								   data->psk2, data->snonce2, data->hash2))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_R_HASH2, data->hash2, sizeof(data->hash2)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_R_SNONCE1, data->snonce1, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M4(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M4(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M4(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	u8 version;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M4)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* R-Hash1 */
+		length = sizeof(target->hash1);
+		if (wps_get_value(wps, WPS_TYPE_R_HASH1, target->hash1, &length))
+			break;
+
+		/* R-Hash2 */
+		length = sizeof(target->hash2);
+		if (wps_get_value(wps, WPS_TYPE_R_HASH2, target->hash2, &length))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_R_SNONCE1, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* RHash1 validation */
+		if (eap_wps_hash_validation(data, target->hash1, rsnonce, data->psk1, data->pubKey, target->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M4(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!conf || !data)
+			break;
+
+		if (eap_wps_config_process_message_M4(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M5(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M5;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_E_SNONCE1, data->snonce1, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M5(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M5(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M5(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	u8 version;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M5)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_E_SNONCE1, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* EHash1 validation */
+		if (eap_wps_hash_validation(data, target->hash1, rsnonce, data->psk1, target->pubKey, data->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M5(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M5(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M6(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M6;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_R_SNONCE2, data->snonce2, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M6(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M6(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M6(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	u8 version;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M6)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_R_SNONCE2, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* RHash2 validation */
+		if (eap_wps_hash_validation(data, target->hash2, rsnonce, data->psk2, data->pubKey, target->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M6(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M6(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M7(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M7;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_E_SNONCE2, data->snonce2, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M7(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M7(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M7(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	u8 version;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M7)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_E_SNONCE2, rsnonce, keyWrapAuth))
+			break;
+		if (target->config)
+			os_free(target->config);
+		target->config = decrypted;
+		target->config_len = decrypted_len;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* EHash2 validation */
+		if (eap_wps_hash_validation(data, target->hash2, rsnonce, data->psk2, target->pubKey, data->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (ret && decrypted) {
+		os_free(decrypted);
+		if (data->target) {
+			target = data->target;
+			target->config = 0;
+			target->config_len = 0;
+		}
+	}
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M7(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M7(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_M8(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M8;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, 0, 0,
+					data->config, data->config_len,
+					data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M8(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M8(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_M8(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M8)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len,
+											data->authKey, 0, 0, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		if (target->config)
+			os_free(target->config);
+		target->config = decrypted;
+		target->config_len = decrypted_len;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (ret && decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M8(struct eap_sm *sm,
+									 struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M8(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *eap_wps_config_build_message_special(struct wps_config *conf,
+										 struct eap_wps_data *data,
+										 u8 msg_type,
+										 u8 *e_nonce, u8 *r_nonce,
+										 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !e_nonce || !r_nonce || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, e_nonce, SIZE_UUID))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, r_nonce, SIZE_UUID))
+			break;
+
+		/* Configuration Error */
+		if (WPS_MSGTYPE_NACK == msg_type) {
+			if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+				break;
+		}
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_special(struct eap_sm *sm,
+										 struct eap_wps_data *data,
+										 u8 msg_type,
+										 u8 *e_nonce, u8 *r_nonce,
+										 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !msg_len || !e_nonce || !r_nonce || !msg_len)
+			break;
+
+		msg = eap_wps_config_build_message_special(conf, data, msg_type,
+												   e_nonce, r_nonce, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int eap_wps_config_process_message_special(struct wps_config *conf,
+										   struct eap_wps_data *data,
+										   u8 msg_type,
+										   u8 *e_nonce, u8 *r_nonce)
+{
+	int ret = -1;
+	u8 version;
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+	u8 u8val;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !e_nonce || !r_nonce)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+		if (msg_type != u8val)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(e_nonce, nonce, length))
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(r_nonce, nonce, length))
+			break;
+
+		if (msg_type == WPS_MSGTYPE_NACK) {
+			/* Configuration Error */
+			if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_special(struct eap_sm *sm,
+										   struct eap_wps_data *data,
+										   u8 msg_type,
+										   u8 *e_nonce, u8 *r_nonce)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!data || !e_nonce || !r_nonce || !conf)
+			break;
+
+		if (eap_wps_config_process_message_special(conf, data, msg_type,
+												   e_nonce, r_nonce))
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 *eap_wps_build_packet(u8 code, u8 identifier, u8 op_code, u8 flags,
+								u8 *msg, size_t msg_len, size_t *rsp_len)
+{
+	u8 *rsp = 0;
+	struct eap_hdr *rsp_hdr;
+	struct eap_format *rsp_fmt;
+	u8 *tmp;
+
+	do {
+		if ((!msg && msg_len) || !rsp_len)
+			break;
+
+		if (flags & EAP_FLAG_LF)
+			*rsp_len = sizeof(*rsp_hdr) + sizeof(*rsp_fmt) + msg_len + 2;
+		else
+			*rsp_len = sizeof(*rsp_hdr) + sizeof(*rsp_fmt) + msg_len;
+		rsp = wpa_zalloc(*rsp_len);
+		
+		if (rsp) {
+			rsp_hdr = (struct eap_hdr *)rsp;
+			rsp_hdr->code = code;
+			rsp_hdr->identifier = identifier;
+			rsp_hdr->length = host_to_be16(*rsp_len);
+
+			rsp_fmt = (struct eap_format *)(rsp_hdr + 1);
+			rsp_fmt->type = EAP_TYPE_EXPANDED;
+			os_memcpy(rsp_fmt->vendor_id, EAP_VENDOR_ID_WPS, sizeof(rsp_fmt->vendor_id));
+			os_memcpy(rsp_fmt->vendor_type, EAP_VENDOR_TYPE_WPS, sizeof(rsp_fmt->vendor_type));
+			rsp_fmt->op_code = op_code;
+			rsp_fmt->flags = flags;
+
+			tmp = (u8 *)(rsp_fmt + 1);
+			if (flags & EAP_FLAG_LF) {
+				WPA_PUT_BE16(tmp, msg_len);
+				tmp += 2;
+			}
+
+			if (msg_len)
+				os_memcpy(tmp, msg, msg_len);
+		}
+	} while (0);
+
+	if (!rsp && rsp_len)
+		*rsp_len = 0;
+
+	return rsp;
+}
+
+
+static u8 *eap_wps_process_registrar(struct eap_sm *sm,
+									 struct eap_wps_data *data,
+									 struct eap_method_ret *ret,
+									 u8 req_identifier,
+									 u8 req_op_code, size_t *rsp_len)
+{
+	u8 *rsp = 0;
+	u8 *wps_msg = 0;
+	size_t wps_msg_len;
+	struct eap_wps_target_info *target = data->target;
+
+	do {
+		if (data->mode != REGISTRAR)
+			break;
+
+		switch (req_op_code) {
+		case EAP_OPCODE_WPS_MSG:
+			if (WPS_MSGTYPE_M1 == wps_get_message_type(data->rcvMsg,
+														   data->rcvMsgLen))
+				data->state = START;
+			break;
+		case EAP_OPCODE_WPS_NACK:
+			data->state = NACK;
+			break;
+		default:
+			break;
+		}
+
+		switch (data->state) {
+		case START:
+		{
+			/* Should be received M1 message */
+			if (!eap_wps_process_message_M1(sm, data)) {
+				if (data->dev_pwd_len) {
+					/* Build M2 message */
+					if (!(wps_msg = eap_wps_build_message_M2(sm, data, &wps_msg_len)))
+						break;
+
+					rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+												EAP_OPCODE_WPS_MSG, 0,
+												wps_msg, wps_msg_len,
+												rsp_len);
+					if(!rsp) {
+						ret->ignore = 1;
+						break;
+					}
+					data->state = M2;
+				} else {
+					struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+					char msg[32];
+
+					/* Build M2D message */
+					if (!(wps_msg = eap_wps_build_message_M2D(sm, data, &wps_msg_len)))
+						break;
+
+					rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+												EAP_OPCODE_WPS_MSG, 0,
+												wps_msg, wps_msg_len,
+												rsp_len);
+					if(!rsp) {
+						ret->ignore = 1;
+						break;
+					}
+					os_snprintf(msg, sizeof(msg), "REGISTRAR:%d", conf->nwid_trying_wps);
+					eap_wps_request(sm, CTRL_REQ_TYPE_PASSWORD, msg, os_strlen(msg));
+					data->state = M2D;
+				}
+			}
+			break;
+		}
+		case M2:
+		{
+			/* Should be received M3 message */
+			if (!eap_wps_process_message_M3(sm, data)) {
+				/* Build M4 message */
+				if (!(wps_msg = eap_wps_build_message_M4(sm, data, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = M4;
+			}
+			break;
+		}
+		case M2D:
+		{
+			/* Should be received NACK */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce)) {
+				/* Build NACK */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_NACK, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+
+				data->state = START;
+			}
+			break;
+		}
+		case M4:
+		{
+			/* Should be received M5 message */
+			if (!eap_wps_process_message_M5(sm, data)) {
+				/* Build M6 message */
+				if (!(wps_msg = eap_wps_build_message_M6(sm, data, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = M6;
+			}
+			break;
+		}
+		case M6:
+		{
+			/* Should be received M7 message */
+			if (!eap_wps_process_message_M7(sm, data)) {
+				/* Build M8 message */
+				if (!(wps_msg = eap_wps_build_message_M8(sm, data, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = M8;
+			}
+			break;
+		}
+		case M8:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received Done */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_DONE, target->nonce, data->nonce)) {
+				/* Build ACK */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_ACK, target->nonce, data->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_ACK, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+
+				switch (data->reg_mode) {
+				case WPS_REGMODE_CONFIGURE_AP:
+					/* Select Network Configuration (already added) */
+					(void)eap_wps_select_ssid_configuration(sm, data, data->config, data->config_len, 0);
+					break;
+				case WPS_REGMODE_REGISTER_AP:
+					/* Set Network Configuration */
+					(void)eap_wps_set_ssid_configuration(sm, data, target->config, target->config_len, 0);
+					break;
+				default:
+					break;
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				data->state = START;
+			}
+			break;
+		}
+		case NACK:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+			char msg[32];
+
+			/* Should be received NACK */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce)) {
+				/* Build NACK */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_NACK, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				os_snprintf(msg, sizeof(msg), "%d", conf->nwid_trying_wps);
+				eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+
+				data->state = START;
+			}
+
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+	} while (0);
+
+	if (wps_msg) {
+		os_free(wps_msg);
+		wps_msg = 0;
+	}
+
+	if (!rsp && rsp_len)
+		*rsp_len = 0;
+
+	if (!ret->ignore && !rsp) {
+		struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+		char msg[32];
+
+		do {
+			/* Build NACK */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce, &wps_msg_len)))
+				break;
+
+			rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										rsp_len);
+		} while (0);
+
+		if (conf->dev_pwd_len) {
+			conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+			conf->dev_pwd_len = 0;
+		}
+
+		if (conf->set_pub_key) {
+			if (conf->dh_secret)
+				eap_wps_free_dh(&conf->dh_secret);
+			os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+			conf->set_pub_key = 0;
+		}
+
+		if (data->preset_pubKey) {
+			data->dh_secret = 0;
+			os_memset(data->pubKey, 0, sizeof(data->pubKey));
+			data->preset_pubKey = 0;
+		}
+
+		os_snprintf(msg, sizeof(msg), "%d", conf->nwid_trying_wps);
+		eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+
+		data->state = START;
+
+		if (wps_msg) {
+			os_free(wps_msg);
+			wps_msg = 0;
+		}
+
+		if (!rsp) {
+			ret->ignore = 1;
+			if (rsp_len)
+				*rsp_len = 0;
+		}
+	}
+
+	return rsp;
+}
+
+
+static u8 *eap_wps_process_enrollee(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									struct eap_method_ret *ret,
+									u8 req_identifier,
+									u8 req_op_code, size_t *rsp_len)
+{
+	u8 *rsp = 0;
+	u8 *wps_msg = 0;
+	size_t wps_msg_len;
+	struct eap_wps_target_info *target = data->target;
+
+	do {
+		if (data->mode != ENROLLEE)
+			break;
+
+		switch (req_op_code) {
+		case EAP_OPCODE_WPS_START:
+			data->state = START;
+			break;
+		case EAP_OPCODE_WPS_MSG:
+			break;
+		case EAP_OPCODE_WPS_NACK:
+			data->state = NACK;
+			break;
+		default:
+			break;
+		}
+
+		switch (data->state) {
+		case START:
+		{
+			/* Should be received Start Message */
+			/* Build M1 message */
+			if (!(wps_msg = eap_wps_build_message_M1(sm, data, &wps_msg_len)))
+				break;
+
+			rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										rsp_len);
+			if(!rsp)
+				break;
+			data->state = M1;
+			break;
+		}
+		case M1:
+		case ACK:
+		{
+			Boolean with_config;
+			u8 op_code;
+			int next;
+
+			/* Should be received M2/M2D message */
+			if (!eap_wps_process_message_M2(sm, data, &with_config)) {
+				/* Received M2 */
+				if (with_config) {
+					/* Build Done */
+					if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_DONE, data->nonce, target->nonce, &wps_msg_len)))
+						break;
+
+					/* Set Network Configuration */
+					(void)eap_wps_set_ssid_configuration(sm, data, target->config, target->config_len, 1);
+
+					op_code = EAP_OPCODE_WPS_DONE;
+					next = START;
+				} else {
+					/* Build M3 message */
+					if (!(wps_msg = eap_wps_build_message_M3(sm, data, &wps_msg_len)))
+						break;
+					op_code = EAP_OPCODE_WPS_MSG;
+					next = M3;
+				}
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											op_code, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = next;
+			} else if (!eap_wps_process_message_M2D(sm, data)) {
+				struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+				char msg[32];
+				int len;
+
+				/* Received M2D */
+				/* Build ACK */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_ACK, data->nonce, target->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_ACK, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+
+				if (ACK != data->state) {
+					len = os_snprintf(msg, sizeof(msg), "ENROLLEE:%d", conf->nwid_trying_wps);
+					if ((data->dev_pwd_id == WPS_DEVICEPWDID_DEFAULT) &&
+						data->dev_pwd_len) {
+						len += os_snprintf(msg + len, sizeof(msg) - len, "-");
+						strncpy(msg + len, (char *)data->dev_pwd, 8);
+						len += 8;
+						msg[len] = 0;
+					}
+
+					eap_wps_request(sm, CTRL_REQ_TYPE_PASSWORD, msg, os_strlen(msg));
+					data->state = ACK;
+				}
+			}
+			break;
+		}
+		case M3:
+		{
+			/* Should be received M4 message */
+			if (!eap_wps_process_message_M4(sm, data)) {
+				/* Build M5 message */
+				if (!(wps_msg = eap_wps_build_message_M5(sm, data, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = M5;
+			}
+			break;
+		}
+		case M5:
+		{
+			/* Should be received M6 message */
+			if (!eap_wps_process_message_M6(sm, data)) {
+				/* Build M7 message */
+				if (!(wps_msg = eap_wps_build_message_M7(sm, data, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+				data->state = M7;
+			}
+			break;
+		}
+		case M7:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received M8 message */
+			if (!eap_wps_process_message_M8(sm, data)) {
+				/* Build Done */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_DONE, data->nonce, target->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_DONE, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+				if(!rsp)
+					break;
+
+				/* Set Network Configuration */
+				(void)eap_wps_set_ssid_configuration(sm, data, target->config, target->config_len, 1);
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				data->state = START;
+			}
+			break;
+		}
+		case NACK:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+			char msg[32];
+
+			/* Should be received NACK message */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce)) {
+				/* Build NACK */
+				if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce, &wps_msg_len)))
+					break;
+
+				rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+											EAP_OPCODE_WPS_NACK, 0,
+											wps_msg, wps_msg_len,
+											rsp_len);
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				if (data->preset_pubKey) {
+					data->dh_secret = 0;
+					os_memset(data->pubKey, 0, sizeof(data->pubKey));
+					data->preset_pubKey = 0;
+				}
+
+				os_snprintf(msg, sizeof(msg), "%d", conf->nwid_trying_wps);
+				eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+
+				data->state = START;
+			}
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+	} while (0);
+
+	if (wps_msg) {
+		os_free(wps_msg);
+		wps_msg = 0;
+	}
+
+	if (!rsp && rsp_len)
+		*rsp_len = 0;
+
+	if (!ret->ignore && !rsp) {
+		struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+		char msg[32];
+
+		do {
+			/* Build NACK */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce, &wps_msg_len)))
+				break;
+
+			rsp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										rsp_len);
+		} while (0);
+
+		if (conf->dev_pwd_len) {
+			conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+			conf->dev_pwd_len = 0;
+		}
+
+		if (conf->set_pub_key) {
+			if (conf->dh_secret)
+				eap_wps_free_dh(&conf->dh_secret);
+			os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+			conf->set_pub_key = 0;
+		}
+
+		if (data->preset_pubKey) {
+			data->dh_secret = 0;
+			os_memset(data->pubKey, 0, sizeof(data->pubKey));
+			data->preset_pubKey = 0;
+		}
+
+		os_snprintf(msg, sizeof(msg), "%d", conf->nwid_trying_wps);
+		eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, msg, os_strlen(msg));
+
+		data->state = START;
+
+		if (wps_msg) {
+			os_free(wps_msg);
+			wps_msg = 0;
+		}
+
+		if (!rsp) {
+			ret->ignore = 1;
+			if (rsp_len)
+				*rsp_len = 0;
+		}
+	}
+
+	return rsp;
+}
+
+
+static u8 *eap_wps_process(struct eap_sm *sm, void *priv,
+						   struct eap_method_ret *ret,
+						   const u8 *reqData, size_t reqDataLen,
+						   size_t *respDataLen)
+{
+	u8 *resp = 0;
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+	struct eap_hdr *req_hdr = (struct eap_hdr *)reqData;
+	struct eap_format *req_fmt;
+	const u8 *identity;
+	size_t identity_len;
+	u8 *raw;
+	u16 msg_len;
+
+	do {
+		ret->ignore = 0;
+
+		req_fmt = (struct eap_format *)(req_hdr + 1);
+		if (be_to_host16(req_hdr->length) != reqDataLen) {
+			ret->ignore = 1;
+			break;
+		} else if ((EAP_TYPE_EXPANDED != req_fmt->type) ||
+				   (0 != os_memcmp(req_fmt->vendor_id, EAP_VENDOR_ID_WPS,
+				                sizeof(req_fmt->vendor_id))) ||
+				   (0 != os_memcmp(req_fmt->vendor_type, EAP_VENDOR_TYPE_WPS,
+				                sizeof(req_fmt->vendor_type)))) {
+			ret->ignore = 1;
+			break;
+		}
+
+		if (req_fmt->flags & EAP_FLAG_LF) {
+			raw = (u8 *)(req_fmt + 1);
+			msg_len = req_hdr->length - (sizeof(*req_hdr) + sizeof(*req_fmt));
+			if (msg_len != WPA_GET_BE16((u8 *)req_fmt + 1)) {
+				ret->ignore = 1;
+				return 0;
+			}
+		} else {
+			raw = (u8 *)(req_fmt + 1);
+			msg_len = reqDataLen - (sizeof(*req_hdr) + sizeof(*req_fmt));
+		}
+
+		if (data->fragment) {
+			data->fragment = 0;
+			data->rcvMsg = (u8 *)os_realloc(data->rcvMsg, data->rcvMsgLen + msg_len);
+			if (data->rcvMsg) {
+				os_memcpy(data->rcvMsg + data->rcvMsgLen, raw, msg_len);
+				data->rcvMsgLen += msg_len;
+			}
+		} else {
+			if (data->rcvMsg)
+				os_free(data->rcvMsg);
+			data->rcvMsg = (u8 *)os_malloc(msg_len);
+			if (data->rcvMsg) {
+				os_memcpy(data->rcvMsg, raw, msg_len);
+				data->rcvMsgLen = msg_len;
+			}
+		}
+
+		if (!data->rcvMsg) {
+			/* Memory allocation Error */
+			data->rcvMsgLen = 0;
+			break;
+		}
+
+		if (req_fmt->flags & EAP_FLAG_MF) {
+			data->fragment = 1;
+			resp = eap_wps_build_packet(EAP_CODE_RESPONSE, req_hdr->identifier,
+										EAP_OPCODE_WPS_FLAG_ACK, 0, NULL, 0,
+										respDataLen);
+			if (resp)
+				data->fragment = 1;
+			break;
+		}
+
+		identity = eap_get_config_identity(sm, &identity_len);
+		if (0 == os_strcmp((char *)identity, WPS_IDENTITY_REGISTRAR))
+			data->mode = REGISTRAR;
+		else if (0 == os_strcmp((char *)identity, WPS_IDENTITY_ENROLLEE))
+			data->mode = ENROLLEE;
+		else {
+			/* Error */
+			ret->ignore = 1;
+			return 0;
+		}
+
+		switch (data->mode) {
+		case REGISTRAR:
+			resp = eap_wps_process_registrar(sm, data, ret,
+											 req_hdr->identifier,
+											 req_fmt->op_code,
+											 respDataLen);
+			break;
+		case ENROLLEE:
+			resp = eap_wps_process_enrollee(sm, data, ret,
+											req_hdr->identifier,
+											req_fmt->op_code,
+											respDataLen);
+			break;
+		default:
+			break;
+		}
+	} while (0);
+
+	return resp;
+}
+
+int eap_peer_wps_register(void)
+{
+	struct eap_method *eap;
+	int ret;
+
+	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
+				    WPA_GET_BE24(EAP_VENDOR_ID_WPS), WPA_GET_BE32(EAP_VENDOR_TYPE_WPS), "WPS");
+	if (eap == NULL)
+		return -1;
+
+	eap->init = eap_wps_init;
+	eap->deinit = eap_wps_deinit;
+	eap->process = eap_wps_process;
+
+	ret = eap_peer_method_register(eap);
+	if (ret)
+		eap_peer_method_free(eap);
+	return ret;
+}
+
+
+static int eap_wps_set_pbc_ie(struct wpa_supplicant *wpa_s, struct wps_config *wps, int enabled)
+{
+	int ret = -1;
+	u8 *iebuf = 0;
+	size_t iebuflen;
+
+	do {
+		if (!wpa_s || !wps)
+			break;
+
+		if (enabled) {
+			os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+			wps_config_free_dh(&wps->dh_secret);
+			wps->set_pub_key = 0;
+
+			wps->dev_pwd_id = WPS_DEVICEPWDID_PUSH_BTN;
+			os_memcpy(wps->dev_pwd, "00000000", 8);
+			wps->dev_pwd_len = 8;
+
+			/* Create WPS ProbeReq IE */
+			if (wps_config_create_probe_req_ie(wpa_s, &iebuf, &iebuflen)) {
+				break;
+			}
+			/* Set WPS ProbeReq IE */
+			if (wpa_drv_set_wps_probe_req_ie(wpa_s, iebuf, iebuflen)) {
+				break;
+			}
+			free(iebuf);
+			iebuf = 0;
+			iebuflen = 0;
+			/* Create WPS AssocReq IE */
+			if (wps_config_create_assoc_req_ie(wpa_s, &iebuf, &iebuflen)) {
+				break;
+			}
+			/* Set WPS AssocReq IE */
+			if (wpa_drv_set_wps_assoc_req_ie(wpa_s, iebuf, iebuflen)) {
+				break;
+			}
+		} else {
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+			wps->dev_pwd_len = 0;
+
+			/* Clear WPS ProbeReq IE */
+			if (wpa_drv_set_wps_probe_req_ie(wpa_s, 0, 0)) {
+				break;
+			}
+			/* Set WPS AssocReq IE */
+			if (wpa_drv_set_wps_assoc_req_ie(wpa_s, 0, 0)) {
+				break;
+			}
+		}
+
+		ret = 0;
+	} while (0);
+	if (iebuf)
+		os_free(iebuf);
+
+	return ret;
+}
+
+
+static void eap_wps_pbc_timer_tick(void *ctx, void *conf)
+{
+	struct wpa_supplicant *wpa_s = ctx;
+	struct wps_config *wps = conf;
+	struct os_time now;
+	int timeout = 0;
+
+	if(!wps->enabled_pbc) {
+		os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+		return;
+	}
+
+	os_get_time(&now);
+	if (now.sec > wps->end_pbc_time.sec)
+		timeout = 1;
+	else if ((now.sec == wps->end_pbc_time.sec) &&
+			 (now.usec >= wps->end_pbc_time.usec))
+		timeout = 1;
+
+	if (timeout) {
+		if (wps->nwid_trying_wps != -1) {
+			(void)wps_config_remove_network(wpa_s,
+											wps->nwid_trying_wps);
+			wps->nwid_trying_wps = -1;
+		}
+		wps->enabled_pbc = 0;
+		os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+		wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+		(void)eap_wps_set_pbc_ie(ctx, conf, 0);
+
+		wpa_msg(wpa_s, MSG_INFO, "WPS-PBC timeout");
+	} else
+		eloop_register_timeout(EAP_WPS_PBC_PERIOD_SEC, EAP_WPS_PBC_PERIOD_USEC, eap_wps_pbc_timer_tick, ctx, conf);
+}
+
+
+int eap_wps_enabled_pbc(struct wpa_supplicant *wpa_s, struct wps_config *wps, int enabled)
+{
+	int ret = -1;
+
+	do {
+		if (enabled) {
+			(void)os_get_time(&wps->end_pbc_time);
+			wps->end_pbc_time.sec += EAP_WPS_PBC_TIMEOUT_SEC;
+			wps->end_pbc_time.usec += EAP_WPS_PBC_TIMEOUT_USEC;
+
+			if (!wps->enabled_pbc) {
+				if (eap_wps_set_pbc_ie(wpa_s, wps, enabled))
+					break;
+
+				wps->nwid_trying_wps = -1;
+				wpa_msg(wpa_s, MSG_INFO, "WPS-PBC start");
+				eloop_register_timeout(EAP_WPS_PBC_PERIOD_SEC, EAP_WPS_PBC_PERIOD_USEC, eap_wps_pbc_timer_tick, wpa_s, wps);
+			} else
+				wpa_msg(wpa_s, MSG_INFO, "WPS-PBC restart");
+		} else {
+			os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+
+			if (-1 != wps->nwid_trying_wps) {
+				(void)wps_config_remove_network(wpa_s, wps->nwid_trying_wps);
+				wps->nwid_trying_wps = -1;
+			}
+
+			if (wps->enabled_pbc) {
+				if (eap_wps_set_pbc_ie(wpa_s, wps, enabled))
+					break;
+
+				wpa_msg(wpa_s, MSG_INFO, "WPS-PBC stop");
+				eloop_cancel_timeout(eap_wps_pbc_timer_tick, wpa_s, wps);
+			}
+		}
+		wps->enabled_pbc = enabled;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
Index: wps_opt_upnp.h
===================================================================
--- wps_opt_upnp.h	(revision 0)
+++ wps_opt_upnp.h	(revision 2)
@@ -0,0 +1,63 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_upnp.h
+//  Description: EAP-WPS UPnP option source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_OPT_UPNP_H
+#define WPS_OPT_UPNP_H
+
+struct wpa_config;
+struct wps_opt_upnp_sm;
+struct upnp_wps_ctrlpt_device_list;
+
+struct wps_opt_upnp_sm_ctx {
+	void *ctx;		/* pointer to arbitrary upper level context */
+	void *msg_ctx;
+
+	struct wpa_config *(*get_conf)(void *ctx);
+};
+
+struct wps_opt_upnp_sm *wps_opt_upnp_sm_init(struct wps_opt_upnp_sm_ctx *ctx);
+void wps_opt_upnp_sm_deinit(struct wps_opt_upnp_sm *sm);
+
+int wps_opt_upnp_sm_start(struct wps_opt_upnp_sm *sm, char *net_if);
+int wps_opt_upnp_sm_stop(struct wps_opt_upnp_sm *sm);
+
+int wps_opt_upnp_refresh_device(struct wps_opt_upnp_sm *sm, int timeout);
+int wps_opt_upnp_get_scan_result(struct wps_opt_upnp_sm *sm,
+								 struct upnp_wps_ctrlpt_device_list **list);
+int wps_opt_upnp_get_device_info(struct wps_opt_upnp_sm *sm,
+								 char *control_url);
+int wps_opt_upnp_set_selected_registrar(struct wps_opt_upnp_sm *sm,
+										char *control_url,
+										int selected);
+#endif /* WPS_OPT_UPNP_H */
Index: eap_wps.h
===================================================================
--- eap_wps.h	(revision 0)
+++ eap_wps.h	(revision 2)
@@ -0,0 +1,207 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: eap_wps.h
+//  Description: EAP-WPS main source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef EAP_WPS_H
+#define EAP_WPS_H
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+struct wps_config;
+
+struct eap_wps_target_info {
+	u8		version;
+	u8		uuid[SIZE_UUID];
+	int		uuid_set;
+
+	u8		mac[SIZE_MAC_ADDR];
+	int		mac_set;
+
+	u16		auth_type_flags;
+	u16		encr_type_flags;
+	u8		conn_type_flags;
+	u16		config_methods;
+	u8		wps_state;
+	u8		*manufacturer;
+	size_t	manufacturer_len;
+	u8		*model_name;
+	size_t	model_name_len;
+	u8		*model_number;
+	size_t	model_number_len;
+	u8		*serial_number;
+	size_t	serial_number_len;
+	u8		prim_dev_type[SIZE_8_BYTES];
+	u8		*dev_name;
+	size_t	dev_name_len;
+	u8		rf_bands;
+	u16		assoc_state;
+	u16		config_error;
+	u32		os_version;
+
+	u8		nonce[SIZE_NONCE];
+	u8		pubKey[SIZE_PUB_KEY];
+	int		pubKey_set;
+	u16		dev_pwd_id;
+	u8		hash1[SIZE_256_BITS];
+	u8		hash2[SIZE_256_BITS];
+
+	u8		*config;
+	size_t	config_len;
+};
+
+struct eap_wps_data {
+	enum {START, M1, M2, M2D, M3, M4, M5, M6, M7, M8, DONE, ACK, NACK, FAILURE} state;
+	enum {NONE, REGISTRAR, ENROLLEE} mode;
+
+	u8		*rcvMsg;
+	u32		rcvMsgLen;
+	Boolean	fragment;
+
+	u8		*sndMsg;
+	u32		sndMsgLen;
+
+	u16		dev_pwd_id;
+	u8		dev_pwd[SIZE_64_BYTES];
+	u16		dev_pwd_len;
+
+	u16		assoc_state;
+	u16		config_error;
+
+	u8		nonce[SIZE_NONCE];
+	u8		pubKey[SIZE_PUB_KEY];
+	int		preset_pubKey;
+
+	void	*dh_secret;
+
+	u8		authKey[SIZE_256_BITS];
+	u8		keyWrapKey[SIZE_128_BITS];
+	u8		emsk[SIZE_256_BITS];
+
+	u8		snonce1[SIZE_128_BITS];
+	u8		snonce2[SIZE_128_BITS];
+	u8		psk1[SIZE_128_BITS];
+	u8		psk2[SIZE_128_BITS];
+	u8		hash1[SIZE_256_BITS];
+	u8		hash2[SIZE_256_BITS];
+
+	enum wps_reg_mode reg_mode;
+	u8		*config;
+	size_t	config_len;
+
+	struct eap_wps_target_info *target;
+};
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+int eap_wps_free_dh(void **dh);
+int eap_wps_generate_sha256hash(u8 *inbuf, int inbuf_len, u8 *outbuf);
+int eap_wps_generate_public_key(void **dh_secret, u8 *public_key);
+int eap_wps_generate_device_password_id(u16 *dev_pwd_id);
+int eap_wps_generate_device_password(u8 *dev_pwd, int dev_pwd_len);
+int eap_wps_enabled_pbc(struct wpa_supplicant *wpa_s, struct wps_config * wps, int enabled);
+
+int eap_wps_device_password_validation(const u8 *pwd, const int len);
+
+int eap_wps_config_init_data(struct wps_config *conf,
+							 struct eap_wps_data *data);
+void eap_wps_config_deinit_data(struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M1(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M1(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M2(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+u8 * eap_wps_config_build_message_M2D(struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  size_t *msg_len);
+int eap_wps_config_process_message_M2(struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  Boolean *with_config);
+int eap_wps_config_process_message_M2D(struct wps_config *conf,
+									   struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M3(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M3(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M4(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M4(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M5(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M5(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M6(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M6(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M7(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M7(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M8(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M8(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 * eap_wps_config_build_message_special(struct wps_config *conf,
+										  struct eap_wps_data *data,
+										  u8 msg_type,
+										  u8 *e_nonce, u8 *r_nonce,
+										  size_t *msg_len);
+int eap_wps_config_process_message_special(struct wps_config *conf,
+										   struct eap_wps_data *data,
+										   u8 msg_type,
+										   u8 *e_nonce, u8 *r_nonce);
+
+int eap_wps_config_select_ssid_configuration(struct wps_config *conf,
+											 struct eap_wps_data *data,
+											 u8 *raw_data, size_t raw_data_len,
+											 Boolean wrap_credential);
+int eap_wps_config_set_ssid_configuration(struct wps_config *conf,
+										  void *wpa_s,
+										  u8 *raw_data, size_t raw_data_len,
+										  Boolean wrap_credential);
+
+#endif /* EAP_WPS_H */
Index: defconfig
===================================================================
--- defconfig	(revision 1)
+++ defconfig	(revision 2)
@@ -41,7 +41,7 @@
 
 
 # Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
+#CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for Agere driver
 #CONFIG_DRIVER_HERMES=y
@@ -50,9 +50,10 @@
 #CFLAGS += -I../../include/wireless
 
 # Driver interface for madwifi driver
-#CONFIG_DRIVER_MADWIFI=y
+CONFIG_DRIVER_MADWIFI=y
 # Change include directories to match with the local setup
 #CFLAGS += -I../madwifi/wpa
+CFLAGS += -I/usr/src/redhat/BUILD/madwifi-0.9.3.1
 
 # Driver interface for Prism54 driver
 # (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
@@ -316,3 +317,20 @@
 # wireless-dev.git tree).
 #WIRELESS_DEV=/usr/src/wireless-dev
 #CFLAGS += -I$(WIRELESS_DEV)/net/mac80211
+
+# EAP-WPS for the integrated EAP server
+CONFIG_EAP_WPS=y
+CONFIG_WPS_OPT_UPNP=y
+EXTRALIBS = /usr/lib/libupnp.so
+
+CONFIG_WPS_OPT_NFC=y
+CFLAGS += -I/usr/src/redhat/BUILD/WpsNfcLibrary
+EXTRALIBS += /usr/lib/wpsnfc.dll /usr/lib/libnfc_mapping_pn53x.dll
+
+# use Intel-SDK for WPS
+#CONFIG_USE_INTEL_SDK=y
+#DIFF_PORT_FROM_SUPPS=y
+
+# including bugfix
+MODIFIED_BY_SONY=y
+
Index: os_win32.c
===================================================================
--- os_win32.c	(revision 1)
+++ os_win32.c	(revision 2)
@@ -78,7 +78,11 @@
 int os_daemonize(const char *pid_file)
 {
 	/* TODO */
+#ifndef MODIFIED_BY_SONY
 	return -1;
+#else /* MODIFIED_BY_SONY */
+	return FreeConsole()?0:-1;
+#endif /* MODIFIED_BY_SONY */
 }
 
 
Index: win_if_list.c
===================================================================
--- win_if_list.c	(revision 1)
+++ win_if_list.c	(revision 2)
@@ -25,6 +25,32 @@
 #include <winsock.h>
 #endif /* CONFIG_USE_NDISUIO */
 
+#ifdef USE_WINIFLIST
+#include "win_if_list.h"
+
+int win_if_list_free(win_if_t **list)
+{
+	int ret = -1;
+	win_if_t *next, *tmp;
+
+	do {
+		if (!list)
+			break;
+
+		for (next = *list; next;) {
+			tmp = next->next;
+			free(next);
+			next = tmp;
+		}
+	} while (0);
+
+	if (list)
+		*list = 0;
+
+	return ret;
+}
+#endif /* USE_WINIFLIST */
+
 #ifdef CONFIG_USE_NDISUIO
 
 /* from nuiouser.h */
@@ -77,6 +103,7 @@
 }
 
 
+#ifndef USE_WINIFLIST
 static void ndisuio_query_bindings(HANDLE ndisuio)
 {
 	NDISUIO_QUERY_BINDING *b;
@@ -138,6 +165,111 @@
 	CloseHandle(ndisuio);
 }
 
+#else /* USE_WINIFLIST */
+static int ndisuio_query_bindings(HANDLE ndisuio, win_if_t **list)
+{
+	int ret = 0;
+	NDISUIO_QUERY_BINDING *b = 0;
+	size_t blen = sizeof(*b) + 1024;
+	int i, error;
+	DWORD written;
+	char name[256], desc[256];
+	WCHAR *pos;
+	size_t j, len;
+	win_if_t *item = 0, *next;
+
+	do {
+		if (!list) {
+			ret = -1;
+			break;
+		}
+		*list = 0;
+
+		b = malloc(blen);
+		if (b == NULL) {
+			ret = -1;
+			break;
+		}
+
+		for (i = 0; ; i++) {
+			memset(b, 0, blen);
+			b->BindingIndex = i;
+			if (!DeviceIoControl(ndisuio, IOCTL_NDISUIO_QUERY_BINDING,
+						 b, sizeof(NDISUIO_QUERY_BINDING), b,
+						 (DWORD) blen, &written, NULL)) {
+				error = (int) GetLastError();
+				if (error == ERROR_NO_MORE_ITEMS)
+					break;
+				printf("IOCTL_NDISUIO_QUERY_BINDING failed: %d",
+					   error);
+				ret = -1;
+				break;
+			}
+
+			pos = (WCHAR *) ((char *) b + b->DeviceNameOffset);
+			len = b->DeviceNameLength;
+			if (len >= sizeof(name))
+				len = sizeof(name) - 1;
+			for (j = 0; j < len; j++)
+				name[j] = (char) pos[j];
+			name[len] = '\0';
+
+			pos = (WCHAR *) ((char *) b + b->DeviceDescrOffset);
+			len = b->DeviceDescrLength;
+			if (len >= sizeof(desc))
+				len = sizeof(desc) - 1;
+			for (j = 0; j < len; j++)
+				desc[j] = (char) pos[j];
+			desc[len] = '\0';
+
+			next = malloc(sizeof(win_if_t));
+			if (!next)
+				break;
+
+			next->next = 0;
+			snprintf(next->name, sizeof(next->name), "%s", dev->name);
+			snprintf(next->description, sizeof(next->description), "%s", dev->description);
+
+			if (item)
+				item->next = next;
+			if (!*list) *list = item;
+
+			item = next;
+		}
+	} while (0);
+
+	if (b)
+		free(b);
+
+	return ret;
+}
+
+static int ndisuio_enum_bindings(win_if_t **list)
+{
+	int ret = -1;
+	HANDLE ndisuio == INVALID_HANDLE_VALUE;
+
+	do {
+		if (!list)
+			break;
+
+		ndisuio  = ndisuio_open();
+		if (ndisuio == INVALID_HANDLE_VALUE)
+			break;
+
+		ret = ndisuio_query_bindings(ndisuio, list);
+	} while (0);
+
+	if (ndisuio != INVALID_HANDLE_VALUE)
+		CloseHandle(ndisuio);
+
+	if (ret && list)
+		win_if_list_free(list);
+
+	return ret;
+}
+#endif // USE_WINIFLIST
+
 #else /* CONFIG_USE_NDISUIO */
 
 static void show_dev(pcap_if_t *dev)
@@ -147,6 +279,7 @@
 }
 
 
+#ifndef USE_WINIFLIST
 static void pcap_enum_devs(void)
 {
 	pcap_if_t *devs, *dev;
@@ -164,9 +297,55 @@
 	pcap_freealldevs(devs);
 }
 
+#else /* USE_WINIFLIST */
+static int pcap_enum_devs(win_if_t **list)
+{
+	int ret = -1;
+	pcap_if_t *devs = 0, *dev;
+	char err[PCAP_ERRBUF_SIZE + 1];
+	win_if_t *item = 0, *next;
+
+	do {
+		if (!list)
+			break;
+		*list = 0;
+
+		if (pcap_findalldevs(&devs, err) < 0) {
+			fprintf(stderr, "Error - pcap_findalldevs: %s\n", err);
+			break;
+		}
+
+		for (dev = devs; dev; dev = dev->next) {
+			next = malloc(sizeof(win_if_t));
+			if (!next)
+				break;
+
+			next->next = 0;
+			snprintf(next->name, sizeof(next->name), "%s", dev->name);
+			snprintf(next->description, sizeof(next->description), "%s", dev->description);
+
+			if (item)
+				item->next = next;
+			if (!*list) *list = item;
+
+			item = next;
+		}
+
+		ret = 0;
+	} while (0);
+
+	pcap_freealldevs(devs);
+
+	if (ret && list)
+		win_if_list_free(list);
+
+	return ret;
+}
+#endif /* USE_WINIFLIST */
+
 #endif /* CONFIG_USE_NDISUIO */
 
-
+#ifndef USE_WINIFLIST
 int main(int argc, char *argv[])
 {
 #ifdef CONFIG_USE_NDISUIO
@@ -177,3 +356,16 @@
 
 	return 0;
 }
+
+#else /* USE_WINIFLIST */
+int win_if_enum_devs(win_if_t **list)
+{
+#ifdef CONFIG_USE_NDISUIO
+	return ndisuio_enum_bindings(list);
+#else /* CONFIG_USE_NDISUIO */
+	return pcap_enum_devs(list);
+#endif /* CONFIG_USE_NDISUIO */
+}
+
+#endif /* USE_WINIFLIST */
+
Index: eapol_sm.c
===================================================================
--- eapol_sm.c	(revision 1)
+++ eapol_sm.c	(revision 2)
@@ -1702,6 +1702,21 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static const struct wps_config *
+eapol_sm_get_wps_config(void *ctx)
+{
+	struct eapol_sm *sm = ctx;
+	if (sm && sm->ctx && sm->ctx->get_wps_config)
+		return sm->ctx->get_wps_config(sm->ctx->ctx);
+	else
+		return NULL;
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
 static struct eapol_callbacks eapol_cb =
 {
 	eapol_sm_get_config,
@@ -1712,6 +1727,11 @@
 	eapol_sm_get_eapReqData,
 	eapol_sm_set_config_blob,
 	eapol_sm_get_config_blob,
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	eapol_sm_get_wps_config,
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 	eapol_sm_notify_pending
 };
 
Index: driver.h
===================================================================
--- driver.h	(revision 1)
+++ driver.h	(revision 2)
@@ -65,6 +65,11 @@
 	int noise;
 	int level;
 	int maxrate;
+#ifdef EAP_WPS
+#define SSID_MAX_WPS_IE_LEN	0x0800
+	u8 wps_ie[SSID_MAX_WPS_IE_LEN];
+	size_t wps_ie_len;
+#endif /* EAP_WPS */
 };
 
 /**
@@ -752,6 +757,22 @@
 	 * (management frame processing) to wpa_supplicant.
 	 */
 	 int (*mlme_remove_sta)(void *priv, const u8 *addr);
+
+#ifdef EAP_WPS
+#ifdef USE_INTEL_SDK
+	 int (*set_wps_probe_request_ie)(void *priv, u8 *iebuf, int iebuflen);
+	 int (*start_receive_beacons)(void *priv);
+	 int (*stop_receive_beacons)(void *priv);
+	 int (*init_l2_packet)(void *priv, void (*handler)(void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len));
+	 int (*deinit_l2_packet)(void *priv);
+	 int (*process_frame)(void *priv, void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len, unsigned char *newbuf, int *newlen, unsigned char *frameType);
+	 int (*start_receive_pr_resps)(void *priv);
+	 int (*stop_receive_pr_resps)(void *priv);
+#else /* USE_INTEL_SDK */
+	 int (*set_wps_probe_req_ie)(void *priv, u8 *iebuf, int iebuflen);
+	 int (*set_wps_assoc_req_ie)(void *priv, u8 *iebuf, int iebuflen);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
 
 #endif /* DRIVER_H */
Index: eapol_sm.h
===================================================================
--- eapol_sm.h	(revision 1)
+++ eapol_sm.h	(revision 2)
@@ -64,6 +64,12 @@
 struct eapol_sm;
 struct wpa_config_blob;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+struct wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 /**
  * struct eapol_ctx - Global (for all networks) EAPOL state machine context
  */
@@ -197,6 +203,17 @@
 	 * module is not loaded.
 	 */
 	const char *pkcs11_module_path;
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	/**
+	 * get_wps_config - Get a wps configuration
+	 * @ctx: Callback context (ctx)
+	 * Returns: Pointer to blob data or %NULL if not found
+	 */
+	const struct wps_config * (*get_wps_config)(void *ctx);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
 
 
Index: wpa_supplicant_i.h
===================================================================
--- wpa_supplicant_i.h	(revision 1)
+++ wpa_supplicant_i.h	(revision 2)
@@ -28,6 +28,13 @@
 struct wpa_sm;
 struct wpa_supplicant;
 
+#ifdef WPS_OPT_UPNP
+struct wps_opt_upnp_sm;
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+struct wps_opt_nfc_sm;
+#endif /* WPS_OPT_NFC */
+
 /*
  * Forward declarations of private structures used within the ctrl_iface
  * backends. Other parts of wpa_supplicant do not have access to data stored in
@@ -91,6 +98,13 @@
 	 * receiving of EAPOL frames from an additional interface.
 	 */
 	const char *bridge_ifname;
+
+#ifdef WPS_OPT_NFC
+	/**
+	 * nfcname - Optional nfc interface name
+	 */
+	const char *nfcname;
+#endif /* WPS_OPT_NFC */
 };
 
 /**
@@ -342,6 +356,14 @@
 
 	struct wpa_client_mlme mlme;
 	int use_client_mlme;
+
+#ifdef WPS_OPT_UPNP
+	struct wps_opt_upnp_sm *wps_opt_upnp;
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+	char *nfcname;
+	struct wps_opt_nfc_sm *wps_opt_nfc;
+#endif /* WPS_OPT_NFC */
 };
 
 
@@ -693,4 +715,102 @@
 	return -1;
 }
 
+#ifdef EAP_WPS
+#ifdef USE_INTEL_SDK
+static inline int wpa_drv_set_wps_probe_request_ie(
+					struct wpa_supplicant *wpa_s,
+					u8 *iebuf, int iebuflen)
+{
+	if (wpa_s->driver->set_wps_probe_request_ie)
+		return wpa_s->driver->set_wps_probe_request_ie(wpa_s->drv_priv,
+						 iebuf, iebuflen);
+	return -1;
+}
+
+static inline int wpa_drv_start_receive_beacons(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->start_receive_beacons)
+		return wpa_s->driver->start_receive_beacons(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_stop_receive_beacons(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->stop_receive_beacons)
+		return wpa_s->driver->stop_receive_beacons(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_init_l2_packet(
+					struct wpa_supplicant *wpa_s,
+					void (*handler)(void *ctx, const unsigned char *src_addr, 
+							const unsigned char *buf, size_t len))
+{
+	if (wpa_s->driver->init_l2_packet)
+		return wpa_s->driver->init_l2_packet(wpa_s->drv_priv, handler);
+	return -1;
+}
+
+static inline int wpa_drv_deinit_l2_packet(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->deinit_l2_packet)
+		return wpa_s->driver->deinit_l2_packet(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_process_frame(
+					struct wpa_supplicant *wpa_s,
+					void *ctx,
+					const unsigned char *src_addr, const unsigned char *buf, 
+					size_t len, unsigned char *newbuf, int *newlen,
+					unsigned char *frameType)
+{
+	if (wpa_s->driver->process_frame)
+		return wpa_s->driver->process_frame(wpa_s->drv_priv, ctx, src_addr, 
+							buf, len, newbuf, newlen, frameType);
+	return -1;
+}
+
+static inline int wpa_drv_start_receive_pr_resps(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->start_receive_pr_resps)
+		return wpa_s->driver->start_receive_pr_resps(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_stop_receive_pr_resps(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->stop_receive_pr_resps)
+		return wpa_s->driver->stop_receive_pr_resps(wpa_s->drv_priv);
+	return -1;
+}
+
+#else /* USE_INTEL_SDK */
+static inline int wpa_drv_set_wps_probe_req_ie(
+					struct wpa_supplicant *wpa_s,
+					u8 *iebuf, int iebuflen)
+{
+	if (wpa_s->driver->set_wps_probe_req_ie)
+		return wpa_s->driver->set_wps_probe_req_ie(wpa_s->drv_priv,
+						 iebuf, iebuflen);
+	return 0;
+}
+
+static inline int wpa_drv_set_wps_assoc_req_ie(
+					struct wpa_supplicant *wpa_s,
+					u8 *iebuf, int iebuflen)
+{
+	if (wpa_s->driver->set_wps_assoc_req_ie)
+		return wpa_s->driver->set_wps_assoc_req_ie(wpa_s->drv_priv,
+						 iebuf, iebuflen);
+	return 0;
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 #endif /* WPA_SUPPLICANT_I_H */
