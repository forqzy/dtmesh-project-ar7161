Index: ctrl_iface.c
===================================================================
--- ctrl_iface.c	(revision 1)
+++ ctrl_iface.c	(revision 2)
@@ -31,7 +31,24 @@
 #include "sta_info.h"
 #include "accounting.h"
 
+#ifdef MODIFIED_BY_SONY
+#include "driver.h"
+#include "config.h"
+#endif /* MODIFIED_BY_SONY */
 
+#ifdef EAP_WPS
+#include "driver.h"
+#include "wps_config.h"
+#include "eap_wps.h"
+#ifdef WPS_OPT_UPNP
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+#include "wps_opt_nfc.h"
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
+
+
 struct wpa_ctrl_dst {
 	struct wpa_ctrl_dst *next;
 	struct sockaddr_un addr;
@@ -142,6 +159,12 @@
 	if (res >= 0)
 		len += res;
 
+#ifdef EAP_WPS
+	res = wps_get_wps_ie_txt(hapd, sta->wps_ie, sta->wps_ie_len, buf + len, buflen - len);
+	if (res >= 0)
+		len += res;
+#endif /* EAP_WPS */
+
 	return len;
 }
 
@@ -217,6 +240,405 @@
 }
 
 
+#ifdef MODIFIED_BY_SONY
+static int hostapd_ctrl_iface_status(struct hostapd_data *hapd,
+				      char *buf, size_t buflen)
+{
+	char *pos, *end, tmp[30];
+	int res, ret;
+#ifdef EAP_WPS
+	struct wps_config *wps = hapd->iconf->wps;
+#endif /* EAP_WPS */
+
+	pos = buf;
+	end = buf + buflen;
+
+	ret = os_snprintf(pos, end - pos, "bssid=" MACSTR "\n",
+			   MAC2STR(hapd->own_addr));
+	if (ret < 0 || ret >= end - pos)
+		return pos - buf;
+	pos += ret;
+	if (hapd->conf) {
+		struct hostapd_bss_config *bss = hapd->conf;
+		struct hostapd_ssid *ssid = &bss->ssid;
+		u8 *_ssid = (u8 *)ssid->ssid;
+		size_t ssid_len = ssid->ssid_len;
+		u8 ssid_buf[HOSTAPD_MAX_SSID_LEN];
+		if (ssid_len == 0) {
+			res = hostapd_get_ssid(hapd, ssid_buf, sizeof(ssid_buf));
+			if (res < 0)
+				ssid_len = 0;
+			else
+				ssid_len = res;
+			_ssid = ssid_buf;
+		} else {
+			memcpy(ssid_buf, _ssid, ssid_len);
+		}
+		ssid_buf[ssid_len] = 0;
+		ret = os_snprintf(pos, end - pos, "ssid=%s\n", ssid_buf);
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+
+		ret = os_snprintf(pos, end - pos, "encription=");
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+		if (bss->wpa) {
+			if (bss->wpa_pairwise & WPA_CIPHER_CCMP) {
+				ret = os_snprintf(pos, end - pos, "CCMP ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			}
+			if (bss->wpa_pairwise & WPA_CIPHER_TKIP) {
+				ret = os_snprintf(pos, end - pos, "TKIP ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			}
+		} else {
+			if (ssid->wep.keys_set) {
+				ret = os_snprintf(pos, end - pos, "WEP ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			} else {
+				ret = os_snprintf(pos, end - pos, "NONE ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			}
+		}
+		ret = os_snprintf(pos, end - pos, "\n");
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+
+		ret = os_snprintf(pos, end - pos, "key_mgmt=");
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+		if (bss->wpa) {
+			if (bss->wpa & HOSTAPD_WPA_VERSION_WPA2) {
+				ret = os_snprintf(pos, end - pos, "WPA2 ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			}
+			if (bss->wpa & HOSTAPD_WPA_VERSION_WPA) {
+				ret = os_snprintf(pos, end - pos, "WPA ");
+				if (ret < 0 || ret >= end - pos)
+					return pos - buf;
+				pos += ret;
+			}
+		} else if (bss->auth_algs & HOSTAPD_AUTH_SHARED_KEY) {
+			ret = os_snprintf(pos, end - pos, "SHARED ");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		} else {
+			ret = os_snprintf(pos, end - pos, "OPEN ");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		}
+		ret = os_snprintf(pos, end - pos, "\n");
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+
+		ret = os_snprintf(pos, end - pos, "ip_address=%s\n",
+					   hostapd_ip_txt(&bss->own_ip_addr, tmp, sizeof(tmp)));
+		if (ret < 0 || ret >= end - pos)
+			return pos - buf;
+		pos += ret;
+	}
+
+#ifdef EAP_WPS
+	if (wps) {
+		if (WPS_WPSSTATE_UNCONFIGURED == wps->wps_state) {
+			ret = os_snprintf(pos, end - pos, "wps_state=Unconfigured\n");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		} else if (WPS_WPSSTATE_CONFIGURED == wps->wps_state) {
+			ret = os_snprintf(pos, end - pos, "wps_state=Configured\n");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		}
+
+		if (!wps->selreg) {
+			ret = os_snprintf(pos, end - pos, "selected_registrar=FALSE\n");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		} else {
+			ret = os_snprintf(pos, end - pos, "selected_registrar=TRUE\n");
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+
+			tmp[0] = 0;
+			switch (wps->dev_pwd_id) {
+			case WPS_DEVICEPWDID_DEFAULT:
+				os_snprintf(tmp, sizeof(tmp), "Default");
+				break;
+			case WPS_DEVICEPWDID_USER_SPEC:
+				os_snprintf(tmp, sizeof(tmp), "User-specified");
+				break;
+			case WPS_DEVICEPWDID_MACHINE_SPEC:
+				os_snprintf(tmp, sizeof(tmp), "Machine-specified");
+				break;
+			case WPS_DEVICEPWDID_PUSH_BTN:
+				os_snprintf(tmp, sizeof(tmp), "PushButton");
+				break;
+			case WPS_DEVICEPWDID_REG_SPEC:
+				os_snprintf(tmp, sizeof(tmp), "Registrar-specified");
+				break;
+			default:
+				os_snprintf(tmp, sizeof(tmp), "%04X", wps->dev_pwd_id);
+				break;
+			}
+			ret = os_snprintf(pos, end - pos, "dev_pwd_id=%s\n", tmp);
+			if (ret < 0 || ret >= end - pos)
+				return pos - buf;
+			pos += ret;
+		}
+	}
+#endif /* EAP_WPS */
+
+	return pos - buf;
+}
+#endif	/* MODIFIED_BY_SONY */
+
+
+#ifdef EAP_WPS
+static int hostapd_ctrl_iface_set_wps_state(struct hostapd_data *hapd,
+				      char *cmd)
+{
+	int ret = -1;
+	int wps_state;
+	struct wps_config *wps = hapd->iconf->wps;
+
+	wps_state = atoi(cmd);
+
+	do {
+		if (!wps)
+			break;
+
+		if (wps_state == WPS_WPSSTATE_UNCONFIGURED)
+			wps->wps_state = WPS_WPSSTATE_UNCONFIGURED;
+		else if (wps_state == WPS_WPSSTATE_CONFIGURED)
+			wps->wps_state = WPS_WPSSTATE_CONFIGURED;
+		else
+			break;
+
+		if (eap_wps_set_ie(hapd))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int hostapd_ctrl_iface_wps_pbc_enabed(struct hostapd_data *hapd,
+				      char *cmd)
+{
+	int enabled;
+	enabled = atoi(cmd);
+
+#ifdef WPS_OPT_UPNP
+		if (hapd->iconf->wps)
+			hapd->iconf->wps->upnp_enabled = 0;
+#endif /* WPS_OPT_UPNP */
+
+	if (eap_wps_enabled_pbc(hapd, hapd->iconf->wps, enabled))
+		return -1;
+
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_wps_set_password(struct hostapd_data *hapd,
+				      char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = hapd->iconf->wps;
+	char *password;
+	size_t pwd_len;
+
+	do {
+		if (!wps)
+			break;
+
+		password = strchr(cmd, '\n');
+		if (password)
+			*password = 0;
+		password = cmd;
+		pwd_len = strlen(password);
+
+		os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+		wps->dev_pwd_len = pwd_len;
+		os_memcpy(wps->dev_pwd, password, wps->dev_pwd_len);
+
+		if (pwd_len) {
+			if ((8 == pwd_len) &&
+				!eap_wps_device_password_validation((u8 *)password, pwd_len))
+				wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			else
+				wps->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+
+			if (wps->set_pub_key) {
+				if (wps->dh_secret)
+					eap_wps_free_dh(&wps->dh_secret);
+				os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+				wps->set_pub_key = 0;
+			}
+		} else {
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+			if (wps->set_pub_key) {
+				if (wps->dh_secret)
+					eap_wps_free_dh(&wps->dh_secret);
+				os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+				wps->set_pub_key = 0;
+			}
+		}
+
+		ret = 0;
+	} while(0);
+
+	return ret;
+}
+
+
+static int hostapd_ctrl_iface_wps_clear_password(struct hostapd_data *hapd)
+{
+	int ret = -1;
+	struct wps_config *wps = hapd->iconf->wps;
+
+	do {
+		if (!wps)
+			break;
+
+		os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+		wps->dev_pwd_len = 0;
+		wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+		if (wps->set_pub_key) {
+			if (wps->dh_secret)
+				eap_wps_free_dh(&wps->dh_secret);
+			os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+			wps->set_pub_key = 0;
+		}
+
+		ret = 0;
+	} while(0);
+
+	return ret;
+}
+
+
+static int hostapd_ctrl_iface_wps_set_regmode(struct hostapd_data *hapd,
+				      char *cmd)
+{
+	int ret = -1;
+	struct wps_config *wps = hapd->iconf->wps;
+	int regmode = atoi(cmd);
+
+	do {
+		if (!wps)
+			break;
+
+		if (0 == regmode)
+			wps->reg_mode = WPS_REGMODE_NONE_GET_CONF;
+		else if (1 == regmode)
+			wps->reg_mode = WPS_REGMODE_NONE_ADDED;
+		else if (2 == regmode)
+			wps->reg_mode = WPS_REGMODE_REGISTER_STA;
+		else
+			break;
+
+		if (eap_wps_set_ie(hapd))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+static int hostapd_ctrl_iface_reconfigure(struct hostapd_data *hapd)
+{
+	if (hostapd_reload_configuration(hapd))
+		return -1;
+
+	return 0;
+}
+
+
+#ifdef WPS_OPT_NFC
+static int hostapd_ctrl_iface_cancel_nfc_command(
+	struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: CANCEL_NFC_COMMAND");
+
+	if (wps_opt_nfc_cancel_nfc_comand(hapd->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_read_password_token(
+	struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: READ_PASSWORD_TOKEN");
+
+	if (wps_opt_nfc_read_password_token(hapd->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_write_password_token(
+	struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: WRITE_PASSWORD_TOKEN");
+
+	if (wps_opt_nfc_write_password_token(hapd->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_read_config_token(
+	struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: READ_CONFIG_TOKEN");
+
+	if (wps_opt_nfc_read_config_token(hapd->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_write_config_token(
+	struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: WRITE_CONFIG_TOKEN");
+
+	if (wps_opt_nfc_write_config_token(hapd->wps_opt_nfc))
+		return -1;
+	return 0;
+}
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
+
+
 static void hostapd_ctrl_iface_receive(int sock, void *eloop_ctx,
 				       void *sock_ctx)
 {
@@ -236,6 +658,12 @@
 		return;
 	}
 	buf[res] = '\0';
+#ifdef MODIFIED_BY_SONY
+	if ((0 == strncmp(buf, "PING", 4)) ||
+		(0 == strncmp(buf, "STATUS", 6)))
+		wpa_hexdump_ascii(MSG_MSGDUMP, "RX ctrl_iface", (u8 *) buf, res);
+	else
+#endif /* MODIFIED_BY_SONY */
 	wpa_hexdump_ascii(MSG_DEBUG, "RX ctrl_iface", (u8 *) buf, res);
 
 	reply = malloc(reply_size);
@@ -300,6 +728,47 @@
 	} else if (strncmp(buf, "NEW_STA ", 8) == 0) {
 		if (hostapd_ctrl_iface_new_sta(hapd, buf + 8))
 			reply_len = -1;
+#ifdef MODIFIED_BY_SONY
+	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
+		reply_len = hostapd_ctrl_iface_status(hapd, reply, reply_size);
+#endif	/* MODIFIED_BY_SONY */
+#ifdef EAP_WPS
+	} else if (os_strncmp(buf, "SET_WPS_STATE ", 14) == 0) {
+		if (hostapd_ctrl_iface_set_wps_state(hapd, buf + 14))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_PBC_ENABLED ", 16) == 0) {
+		if (hostapd_ctrl_iface_wps_pbc_enabed(hapd, buf + 16))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_PASSWORD ", 17) == 0) {
+		if (hostapd_ctrl_iface_wps_set_password(hapd, buf + 17))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_CLEAR_PASSWORD ", 18) == 0) {
+		if (hostapd_ctrl_iface_wps_clear_password(hapd))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WPS_SET_REGMODE ", 16) == 0) {
+		if (hostapd_ctrl_iface_wps_set_regmode(hapd, buf + 16))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "RECONFIGURE", 11) == 0) {
+		if (hostapd_ctrl_iface_reconfigure(hapd))
+			reply_len = -1;
+#ifdef WPS_OPT_NFC
+	} else if (os_strncmp(buf, "CANCEL_NFC_COMMAND", 18) == 0) {
+		if (hostapd_ctrl_iface_cancel_nfc_command(hapd))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "READ_PASSWORD_TOKEN", 19) == 0) {
+		if (hostapd_ctrl_iface_read_password_token(hapd))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WRITE_PASSWORD_TOKEN", 20) == 0) {
+		if (hostapd_ctrl_iface_write_password_token(hapd))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "READ_CONFIG_TOKEN", 17) == 0) {
+		if (hostapd_ctrl_iface_read_config_token(hapd))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "WRITE_CONFIG_TOKEN", 18) == 0) {
+		if (hostapd_ctrl_iface_write_config_token(hapd))
+			reply_len = -1;
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
 	} else {
 		memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
Index: driver_madwifi.c
===================================================================
--- driver_madwifi.c	(revision 1)
+++ driver_madwifi.c	(revision 2)
@@ -53,7 +53,13 @@
 #include "accounting.h"
 #include "common.h"
 
+#if EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 struct madwifi_driver_data {
 	struct driver_ops ops;			/* base class */
 	struct hostapd_data *hapd;		/* back pointer */
@@ -73,6 +79,19 @@
 
 static int madwifi_sta_deauth(void *priv, const u8 *addr, int reason_code);
 
+#if EAP_WPS
+static int madwifi_set_wps_beacon_ie(void *priv, u8 *iebuf, int iebuflen);
+static int madwifi_set_wps_probe_resp_ie(void *priv, u8 *iebuf, int iebuflen);
+static int madwifi_set_wps_assoc_resp_ie(void *priv, u8 *iebuf, int iebuflen);
+#endif /* EAP_WPS */
+
+#ifdef MODIFIED_BY_SONY
+static int wext_set_key(void *priv, int alg,
+						const u8 *addr, int key_idx,
+						int set_tx, const u8 *seq, size_t seq_len,
+						const u8 *key, size_t key_len);
+#endif /* MODIFIED_BY_SONY */
+
 static int
 set80211priv(struct madwifi_driver_data *drv, int op, void *data, int len)
 {
@@ -84,6 +103,14 @@
 		/*
 		 * Argument data fits inline; put it there.
 		 */
+#ifdef EAP_WPS
+#ifdef ATH_WPS_IE
+		if (op == IEEE80211_IOCTL_SET_APPIEBUF) {
+			iwr.u.data.pointer = data;
+			iwr.u.data.length = len;
+		} else
+#endif /* ATH_WPS_IE */
+#endif /* EAP_WPS */
 		memcpy(iwr.u.name, data, len);
 	} else {
 		/*
@@ -344,6 +371,10 @@
 
 	if (!enabled) {
 		/* XXX restore state */
+#ifdef EAP_WPS
+		if (0 != madwifi_set_iface_flags(priv, 1))
+			return -1;
+#endif /* EAP_WPS */
 		return set80211param(priv, IEEE80211_PARAM_AUTHMODE,
 			IEEE80211_AUTH_AUTO);
 	}
@@ -466,7 +497,12 @@
 		__func__, alg, ether_sprintf(addr), key_idx);
 
 	if (strcmp(alg, "WEP") == 0)
+#ifndef MODIFIED_BY_SONY
 		cipher = IEEE80211_CIPHER_WEP;
+#else /* MODIFIED_BY_SONY */
+		return wext_set_key(priv, WPA_ALG_WEP,
+							addr, key_idx, txkey, NULL, 0, key, key_len);
+#endif /* MODIFIED_BY_SONY */
 	else if (strcmp(alg, "TKIP") == 0)
 		cipher = IEEE80211_CIPHER_TKIP;
 	else if (strcmp(alg, "CCMP") == 0)
@@ -766,6 +802,9 @@
 	struct ieee80211req_wpaie ie;
 	int ielen, res;
 	u8 *iebuf;
+#ifdef EAP_WPS
+	struct hostapd_bss_config *conf = hapd->conf;
+#endif /* EAP_WPS */
 
 	/*
 	 * Fetch negotiated WPA/RSN parameters from the system.
@@ -778,6 +817,7 @@
 		printf("Failed to get WPA/RSN information element.\n");
 		return -1;		/* XXX not right */
 	}
+#ifndef EAP_WPS
 	iebuf = ie.wpa_ie;
 #ifdef MADWIFI_NG
 	if (iebuf[1] == 0 && ie.rsn_ie[1] > 0) {
@@ -792,18 +832,57 @@
 		return -1;		/* XXX not right */
 	}
 	ielen += 2;
+#else /* EAP_WPS */
+	do {
+		iebuf = 0; ielen = 0;
+		if (conf->wpa & HOSTAPD_WPA_VERSION_WPA) {
+			iebuf = ie.wpa_ie;
+			if ((iebuf[0] == WLAN_EID_GENERIC) && iebuf[1]) {
+				ielen = iebuf[1];
+				break;
+			}
+		}
+#ifdef MADWIFI_NG
+		if (conf->wpa & HOSTAPD_WPA_VERSION_WPA2) {
+			iebuf = ie.rsn_ie;
+			if ((iebuf[0] == WLAN_EID_RSN) && iebuf[1]) {
+				ielen = iebuf[1];
+				break;
+			}
+		}
+#endif /* MADWIFI_NG */
+	} while (0);
+
+	if ((ie.wps_ie[0] == WLAN_EID_GENERIC) && ie.wps_ie[1]) {
+		os_memcpy(sta->wps_ie, ie.wps_ie, ie.wps_ie[1] + 2);
+		sta->wps_ie_len = ie.wps_ie[1] + 2;
+	}
+#endif /* EAP_WPS */
+
 	if (sta->wpa_sm == NULL)
 		sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth, sta->addr);
 	if (sta->wpa_sm == NULL) {
 		printf("Failed to initialize WPA state machine\n");
 		return -1;
 	}
+
+#ifdef EAP_WPS
+	if (!ielen) {
+		(void)wpa_wps_prepare(sta->wpa_sm);
+		printf("Prepared EAP-WPS\n");
+	} else {
+		ielen += 2;
+#endif /* EAP_WPS */
 	res = wpa_validate_wpa_ie(hapd->wpa_auth, sta->wpa_sm,
 				  iebuf, ielen);
 	if (res != WPA_IE_OK) {
 		printf("WPA/RSN information element rejected? (res %u)\n", res);
 		return -1;
 	}
+#ifdef EAP_WPS
+	}
+#endif /* EAP_WPS */
+
 	return 0;
 }
 
@@ -1205,7 +1284,15 @@
 	struct madwifi_driver_data *drv;
 	struct ifreq ifr;
 	struct iwreq iwr;
+#if EAP_WPS
+#ifndef USE_INTEL_SDK
+	int ret = -1;
+	u8 *iebuf = 0;
+	size_t iebuflen;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 	drv = wpa_zalloc(sizeof(struct madwifi_driver_data));
 	if (drv == NULL) {
 		printf("Could not allocate memory for madwifi driver data\n");
@@ -1262,6 +1349,55 @@
 	madwifi_set_privacy(drv->iface, drv, 0); /* default to no privacy */
 
 	hapd->driver = &drv->ops;
+
+#if EAP_WPS
+#ifndef USE_INTEL_SDK
+	do {
+		/* Create WPS Beacon IE */
+		if (wps_config_create_beacon_ie(drv->hapd, &iebuf, &iebuflen)) {
+			perror("Create WPS Beacon IE error");
+			break;
+		}
+		/* Set WPS Beacon IE */
+		if (madwifi_set_wps_beacon_ie(drv, iebuf, iebuflen)) {
+			perror("Set WPS Beacon IE error");
+			break;
+		}
+		os_free(iebuf);
+		iebuf = 0;
+		/* Create WPS ProbeResp IE */
+		if (wps_config_create_probe_resp_ie(drv->hapd, &iebuf, &iebuflen)) {
+			perror("Create WPS ProbeResp IE error");
+			break;
+		}
+		/* Set WPS ProbeResp IE */
+		if (madwifi_set_wps_probe_resp_ie(drv, iebuf, iebuflen)) {
+			perror("Set WPS ProbeResp IE error");
+			break;
+		}
+		os_free(iebuf);
+		iebuf = 0;
+		/* Create WPS AssocResp IE */
+		if (wps_config_create_assoc_resp_ie(drv->hapd, &iebuf, &iebuflen)) {
+			perror("Create WPS AssocResp IE error");
+			break;
+		}
+		/* Set WPS AssocResp IE */
+		if (madwifi_set_wps_assoc_resp_ie(drv, iebuf, iebuflen)) {
+			perror("Set WPS AssocResp IE error");
+			break;
+		}
+		ret = 0;
+	} while (0);
+
+	if (iebuf)
+		os_free(iebuf);
+
+	if (ret)
+		return -1;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	return 0;
 bad:
 	if (drv->sock_xmit != NULL)
@@ -1346,6 +1482,50 @@
 	return madwifi_set_iface_flags(priv, 1);
 }
 
+#ifdef EAP_WPS
+static int
+madwifi_set_wps_ie(void *priv, u8 *iebuf, int iebuflen, u32 frametype)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct hostapd_data *hapd = drv->hapd;
+	u8 buf[256];
+	struct ieee80211req_getset_appiebuf * ie;
+	// int i;
+
+	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL, "%s buflen = %d\n", 
+			__func__, iebuflen);
+
+	ie = (struct ieee80211req_getset_appiebuf *) buf;
+	ie->app_frmtype = frametype;
+	ie->app_buflen = iebuflen;
+	os_memcpy(&(ie->app_buf[0]), iebuf, iebuflen);
+	
+	return set80211priv(priv, IEEE80211_IOCTL_SET_APPIEBUF, ie,
+			sizeof(struct ieee80211req_getset_appiebuf) + iebuflen);
+}
+
+static int
+madwifi_set_wps_beacon_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wps_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_BEACON);
+}
+
+static int
+madwifi_set_wps_probe_resp_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wps_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_PROBE_RESP);
+}
+
+static int
+madwifi_set_wps_assoc_resp_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	return madwifi_set_wps_ie(priv, iebuf, iebuflen, 
+			IEEE80211_APPIE_FRAME_ASSOC_RESP);
+}
+#endif /* EAP_WPS */
+
 static const struct driver_ops madwifi_driver_ops = {
 	.name			= "madwifi",
 	.init			= madwifi_init,
@@ -1368,9 +1548,70 @@
 	.set_countermeasures	= madwifi_set_countermeasures,
 	.sta_clear_stats        = madwifi_sta_clear_stats,
 	.commit			= madwifi_commit,
+#ifdef EAP_WPS
+	.set_wps_beacon_ie		= madwifi_set_wps_beacon_ie,
+	.set_wps_probe_resp_ie	= madwifi_set_wps_probe_resp_ie,
+	.set_wps_assoc_resp_ie	= madwifi_set_wps_assoc_resp_ie,
+#endif /* EAP_WPS */
 };
 
 void madwifi_driver_register(void)
 {
 	driver_register(madwifi_driver_ops.name, &madwifi_driver_ops);
 }
+
+#ifdef MODIFIED_BY_SONY
+int wext_set_key(void *priv, int alg,
+				 const u8 *addr, int key_idx,
+				 int set_tx, const u8 *seq, size_t seq_len,
+				 const u8 *key, size_t key_len)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct hostapd_data *hapd = drv->hapd;
+	struct hostapd_bss_config *conf = hapd->conf;
+	struct iwreq iwr;
+	int ret = 0;
+	int ioctl_sock;
+
+	wpa_printf(MSG_DEBUG,"%s: alg=%d key_idx=%d set_tx=%d seq_len=%lu "
+		   "key_len=%lu", __FUNCTION__, alg, key_idx, set_tx,
+		   (unsigned long) seq_len, (unsigned long) key_len);
+
+	ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (ioctl_sock < 0) {
+		perror("socket(PF_INET,SOCK_DGRAM)");
+		return -1;
+	}
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.encoding.flags = key_idx + 1;
+	if (alg == WPA_ALG_NONE)
+		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
+	if (conf->auth_algs & HOSTAPD_AUTH_OPEN)
+		iwr.u.encoding.flags |= IW_ENCODE_OPEN;
+	if (conf->auth_algs & HOSTAPD_AUTH_SHARED_KEY)
+		iwr.u.encoding.flags |= IW_ENCODE_RESTRICTED;
+	iwr.u.encoding.pointer = (caddr_t) key;
+	iwr.u.encoding.length = key_len;
+	if (ioctl(ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWENCODE]");
+		ret = -1;
+	}
+
+	if (set_tx && alg != WPA_ALG_NONE) {
+		os_memset(&iwr, 0, sizeof(iwr));
+		os_strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+		iwr.u.encoding.flags = key_idx + 1;
+		iwr.u.encoding.pointer = (caddr_t) key;
+		iwr.u.encoding.length = 0;
+		if (ioctl(ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
+			perror("ioctl[SIOCSIWENCODE] (set_tx)");
+			ret = -1;
+		}
+	}
+
+	close(ioctl_sock);
+	return ret;
+}
+#endif /* MODIFIED_BY_SONY */
Index: wps_config.c
===================================================================
--- wps_config.c	(revision 0)
+++ wps_config.c	(revision 2)
@@ -0,0 +1,1048 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_config.c
+//  Description: EAP-WPS config source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "hostapd.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wps_parser.h"
+#include "eap_wps.h"
+
+extern int eap_wps_free_dh(void **dh);
+extern int is_hex(const u8 *data, size_t len);
+
+int wps_config_free_dh(void **dh)
+{
+	return eap_wps_free_dh(dh);
+}
+
+int wps_get_ssid_configuration(void *ctx, u8 **buf, size_t *len, int inband)
+{
+	int ret = -1;
+	struct hostapd_data *hapd = ctx;
+	struct hostapd_bss_config *conf = hapd->conf;
+	struct wps_data *wps = 0;
+	struct hostapd_ssid *ssid;
+	u16 auth, encr;
+	Boolean enabled8021x = 0;
+	u8 nwKeyIdx = -1;
+	u8 *nwKey;
+	u16 length;
+
+	do {
+		if (!conf || !buf || !len)
+			break;
+		*buf = 0;
+		*len = 0;
+
+		ssid = &conf->ssid;
+
+		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
+			auth = 0;
+			if (conf->wpa & HOSTAPD_WPA_VERSION_WPA2)
+				auth = WPS_AUTHTYPE_WPA2;
+			else if (conf->wpa & HOSTAPD_WPA_VERSION_WPA)
+				auth = WPS_AUTHTYPE_WPA;
+
+			if (!auth) {
+				auth = WPS_AUTHTYPE_OPEN;
+				encr = WPS_ENCRTYPE_WEP;
+			} else {
+				if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
+					encr = WPS_ENCRTYPE_AES;
+				else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
+					encr = WPS_ENCRTYPE_TKIP;
+			}
+			enabled8021x = 1;
+		} else if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK) {
+			if (conf->wpa & HOSTAPD_WPA_VERSION_WPA2)
+				auth = WPS_AUTHTYPE_WPA2PSK;
+			else if (conf->wpa & HOSTAPD_WPA_VERSION_WPA)
+				auth = WPS_AUTHTYPE_WPAPSK;
+			else
+				break;
+
+			if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
+				encr = WPS_ENCRTYPE_AES;
+			else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
+				encr = WPS_ENCRTYPE_TKIP;
+			nwKeyIdx = 0;
+		} else {
+			if (conf->auth_algs & HOSTAPD_AUTH_SHARED_KEY) {
+				auth = WPS_AUTHTYPE_SHARED;
+				nwKeyIdx = ssid->wep.idx + 1;
+			} else
+				auth = WPS_AUTHTYPE_OPEN;
+
+			if (ssid->wep.keys_set) {
+				encr = WPS_ENCRTYPE_WEP;
+				nwKeyIdx = ssid->wep.idx + 1;
+			} else
+				encr = WPS_ENCRTYPE_NONE;
+		}
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* SSID */
+		if (wps_set_value(wps, WPS_TYPE_SSID, ssid->ssid, ssid->ssid_len))
+			break;
+
+		if (inband) {
+			/* MAC Address */
+			if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, hapd->own_addr, ETH_ALEN))
+				break;
+		}
+
+		/* Authentication Type */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE, &auth, 0))
+			break;
+
+		/* Encryption Type */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE, &encr, 0))
+			break;
+
+		if (nwKeyIdx != (u8)-1) {
+			int allocated = 0;
+
+			if (encr == WPS_ENCRTYPE_WEP) {
+				if ((1 > nwKeyIdx) || (4 < nwKeyIdx)) {
+					wpa_printf(MSG_WARNING, "Network Key Index is fixed. %d -> 1\n", nwKeyIdx);
+					nwKeyIdx = 1;
+				}
+
+				/* Network Key Index (Option) */
+				if (wps_set_value(wps, WPS_TYPE_NW_KEY_INDEX, &nwKeyIdx, 0))
+					break;
+			}
+
+			/* Network Key */
+			if (ssid->wpa_passphrase) {
+				length = os_strlen(ssid->wpa_passphrase);
+				nwKey = (u8 *)ssid->wpa_passphrase;
+			} else if (ssid->wpa_psk) {
+				nwKey = wpa_zalloc(PMK_LEN * 2 + 1);
+				if (!nwKey)
+					break;
+				allocated = 1;
+				length = wpa_snprintf_hex_uppercase((char *)nwKey, PMK_LEN * 2 + 1, ssid->wpa_psk->psk, sizeof(ssid->wpa_psk->psk));
+				if (length != PMK_LEN * 2) {
+					os_free(nwKey);
+					allocated = 0;
+					break;
+				}
+			} else {
+				if (is_hex(ssid->wep.key[nwKeyIdx - 1], ssid->wep.len[nwKeyIdx - 1])) {
+					nwKey = wpa_zalloc(ssid->wep.len[nwKeyIdx - 1] * 2 + 1);
+					if (!nwKey)
+						break;
+					allocated = 1;
+					length = wpa_snprintf_hex_uppercase((char *)nwKey, ssid->wep.len[nwKeyIdx - 1] * 2 + 1,
+														ssid->wep.key[nwKeyIdx - 1], ssid->wep.len[nwKeyIdx - 1]);
+					if (length != ssid->wep.len[nwKeyIdx - 1] * 2) {
+						os_free(nwKey);
+						allocated = 0;
+						break;
+					}
+				} else {
+					length = ssid->wep.len[nwKeyIdx - 1];
+					nwKey = wpa_zalloc(length + 1);
+					if (!nwKey)
+						break;
+					allocated = 1;
+					os_memcpy((char *)nwKey, ssid->wep.key[nwKeyIdx - 1], length);
+				}
+			}
+			if (wps_set_value(wps, WPS_TYPE_NW_KEY, nwKey, length)) {
+				if (nwKey && allocated)
+					os_free(nwKey);
+				break;
+			}
+			if (nwKey && allocated)
+				os_free(nwKey);
+		} else {
+			/* Network Key (No Key) */
+			if (wps_set_value(wps, WPS_TYPE_NW_KEY, 0, 0)) {
+				break;
+			}
+		}
+
+		if (!inband) {
+			/* MAC Address */
+			if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, hapd->own_addr, ETH_ALEN))
+				break;
+		}
+
+		if (enabled8021x) {
+			/* EAP Type (Option) */
+
+			/* EAP Identity (Option) */
+
+			/* Key Provided Automaticaly (Option) */
+
+			/* 802.1X Enabled (Option) */
+			if (wps_set_value(wps, WPS_TYPE_8021X_ENABLED, &enabled8021x, 0))
+				break;
+		}
+
+		if (wps_write_wps_data(wps, buf, (u16 *)len))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (buf && *buf) {
+			os_free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+static char num2hex(u8 n, int upper)
+{
+	char c = '0';
+	if (0xa > n)
+		c = n + '0';
+	else if (0xa <= n && 0xf >= n)
+		c = (n - 0xa) + (upper?'A':'a');
+	return c;
+}
+
+
+int wps_get_auto_configuration(void *ctx, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct hostapd_data *hapd = ctx;
+	struct wps_data *wps = 0;
+	char ssid[SIZE_32_BYTES + 1];
+	u16 auth, encr;
+	u8 nwKeyIdx;
+	char nwKey[SIZE_64_BYTES + 1];
+	u8 tmp[SIZE_32_BYTES];
+	int i;
+
+	do {
+		if (!buf || !len)
+			break;
+		*buf = 0;
+		*len = 0;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Generate SSID */
+		if (eap_wps_generate_device_password(tmp, SIZE_16_BYTES))
+			break;
+		for (i = 0; i < SIZE_16_BYTES; i++) {
+			ssid[(2 * i) + 0] = num2hex((tmp[i] >> 4) & 0x0f, 1);
+			ssid[(2 * i) + 1] = num2hex((tmp[i] >> 0) & 0x0f, 1);
+		}
+		ssid[SIZE_32_BYTES] = 0;
+		/* SSID */
+		if (wps_set_value(wps, WPS_TYPE_SSID, ssid, SIZE_32_BYTES))
+			break;
+
+		/* Authentication Type */
+		auth = WPS_AUTHTYPE_WPAPSK;
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE, &auth, 0))
+			break;
+
+		/* Encryption Type */
+		encr = WPS_ENCRTYPE_TKIP;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE, &encr, 0))
+			break;
+
+		/* Network Key Index (Option) */
+		nwKeyIdx = 1;
+		if (wps_set_value(wps, WPS_TYPE_NW_KEY_INDEX, &nwKeyIdx, 0))
+			break;
+
+		/* Generate Network Key */
+		if (eap_wps_generate_device_password(tmp, SIZE_32_BYTES))
+			break;
+		for (i = 0; i < SIZE_32_BYTES; i++) {
+			nwKey[(2 * i) + 0] = num2hex((tmp[i] >> 4) & 0x0f, 1);
+			nwKey[(2 * i) + 1] = num2hex((tmp[i] >> 0) & 0x0f, 1);
+		}
+		nwKey[SIZE_64_BYTES] = 0;
+		/* Network Key */
+		if (wps_set_value(wps, WPS_TYPE_NW_KEY, nwKey, SIZE_64_BYTES))
+			break;
+
+		/* MAC Address */
+		if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, hapd->own_addr, ETH_ALEN))
+			break;
+
+		if (wps_write_wps_data(wps, buf, (u16 *)len))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (buf && *buf) {
+			os_free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_set_ssid_configuration(void *ctx, char *filename, u8 *buf, size_t len)
+{
+	int ret = -1;
+	struct hostapd_data *hapd = ctx;
+	struct hostapd_bss_config *conf;
+	struct wps_data *wps = 0;
+	u8 nwIdx;
+	u8 str_ssid[33];
+	u16 ssid_length;
+	u16 auth, encr;
+	u8 nwKeyIdx;
+	u8 *nwKey = 0;
+	u16 nwKey_length;
+	u8 macAddr[6];
+	char *eapType = 0;
+	char *eapIdentity = 0;
+	Boolean keyProvideAuto;
+	Boolean enabled8021X;
+	u16 length;
+	int value, wpa;
+	char *tmp;
+	FILE *f = 0;
+
+	do {
+		if (!hapd || !hapd->conf)
+			break;
+		conf = hapd->conf;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* Network Index */
+		(void)wps_get_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, NULL);
+		/** Ignore Network Index **/
+
+		/* SSID */
+		ssid_length = sizeof(str_ssid);
+		if(wps_get_value(wps, WPS_TYPE_SSID, str_ssid, &ssid_length))
+			break;
+		str_ssid[ssid_length] = 0;
+
+		/* Authentication Type */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE, &auth, NULL))
+			break;
+
+		/* Encryption Type */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE, &encr, NULL))
+			break;
+
+		/* Network Key Index (Option) */
+		if(wps_get_value(wps, WPS_TYPE_NW_KEY_INDEX, &nwKeyIdx, NULL))
+			nwKeyIdx = 1;
+		if ((1 > nwKeyIdx) || (4 < nwKeyIdx)) {
+			wpa_printf(MSG_WARNING, "Network Key Index is fixed. %d -> 1\n", nwKeyIdx);
+			nwKeyIdx = 1;
+		}
+
+		/* Network Key */
+		nwKey_length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_NW_KEY, NULL, &nwKey_length);
+		if (nwKey_length) {
+			nwKey = (u8 *)calloc(1, nwKey_length + 1);
+			if (!nwKey)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_NW_KEY, nwKey, &nwKey_length)) {
+				break;
+			}
+			nwKey[nwKey_length] = 0;
+		}
+
+		/* MAC Address */
+		length = sizeof(macAddr);
+		if(wps_get_value(wps, WPS_TYPE_MAC_ADDR, macAddr, &length))
+			break;
+
+		/* EAP Type (Option) */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_EAP_TYPE, NULL, &length);
+		if (length) {
+			eapType = (char *)calloc(1, length + 1);
+			if (!eapType)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_EAP_TYPE, eapType, &length)) {
+				break;
+			}
+			eapType[length] = 0;
+		}
+
+		/* EAP Identity (Option) */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_EAP_IDENTITY, NULL, &length);
+		if (length) {
+			eapIdentity = (char *)calloc(1, length + 1);
+			if (!eapIdentity)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_EAP_IDENTITY, eapIdentity, &length)) {
+				break;
+			}
+			eapIdentity[length] = 0;
+		}
+
+		/* Key Provided Automaticaly (Option) */
+		if(wps_get_value(wps, WPS_TYPE_KEY_PROVIDED_AUTO, &keyProvideAuto, NULL))
+			keyProvideAuto = 0;
+
+		/* 802.1X Enabled (Option) */
+		if(wps_get_value(wps, WPS_TYPE_8021X_ENABLED, &enabled8021X, NULL))
+			enabled8021X = 0;
+
+		/* Set Configuration */
+		f = fopen(filename, "w");
+		if (!f)
+			break;
+
+		/* ssid */
+		fprintf(f, "ssid=%s\n", str_ssid);
+
+		/* auth_algs */
+		if (WPS_AUTHTYPE_SHARED == auth)
+			value = 2;
+		else
+			value = 1;
+		fprintf(f, "auth_algs=%d\n", value);
+
+		/* wpa */
+		switch (auth) {
+		case WPS_AUTHTYPE_WPA:
+		case WPS_AUTHTYPE_WPAPSK:
+			wpa = 1;
+			break;
+		case WPS_AUTHTYPE_WPA2:
+		case WPS_AUTHTYPE_WPA2PSK:
+			wpa = 2;
+			break;
+		default:
+			wpa = 0;
+			break;
+		}
+		fprintf(f, "wpa=%d\n", wpa);
+
+		/* wpa_key_mgmt */
+		if (wpa) {
+			switch (auth) {
+			case WPS_AUTHTYPE_WPAPSK:
+			case WPS_AUTHTYPE_WPA2PSK:
+				tmp = "WPA-PSK";
+				break;
+			case WPS_AUTHTYPE_WPA:
+			case WPS_AUTHTYPE_WPA2:
+				if (nwKey_length)
+					tmp = "WPA-PSK WPA-EAP";
+				else
+					tmp = "WPA-EAP";
+				break;
+			default:
+				tmp = 0;
+				break;
+			}
+			if (tmp)
+				fprintf(f, "wpa_key_mgmt=%s\n", tmp);
+
+			/* wpa_pairwise */
+			switch (encr) {
+			case WPS_ENCRTYPE_TKIP:
+				tmp = "TKIP";
+				break;
+			case WPS_ENCRTYPE_AES:
+				tmp = "CCMP";
+				break;
+			default:
+				tmp = 0;
+				break;
+			}
+			if (tmp)
+				fprintf(f, "wpa_pairwise=%s\n", tmp);
+		}
+
+		/* wep_tx_keyidx */
+		switch (encr) {
+		case WPS_ENCRTYPE_WEP:
+			fprintf(f, "wep_default_key=%d\n", nwKeyIdx - 1);
+			break;
+		default:
+			value = 0;
+			break;
+		}
+
+		/* wep_keyn */
+		switch (encr) {
+		case WPS_ENCRTYPE_WEP:
+			if (is_hex(nwKey, nwKey_length)) {
+				int i;
+				fprintf(f, "wep_key%d=", nwKeyIdx - 1);
+				for (i = 0; i < nwKeyIdx; i++)
+					fprintf(f, "%02X", nwKey[i]);
+				fprintf(f, "\n");
+			} else if ((5 == nwKey_length) || (13 == nwKey_length))
+				fprintf(f, "wep_key%d=\"%s\"\n", nwKeyIdx - 1, nwKey);
+			else
+				fprintf(f, "wep_key%d=%s\n", nwKeyIdx - 1, nwKey);
+			break;
+		default:
+			break;
+		}
+
+		/* psk */
+		switch (auth) {
+		case WPS_AUTHTYPE_WPA:
+		case WPS_AUTHTYPE_WPA2:
+		case WPS_AUTHTYPE_WPAPSK:
+		case WPS_AUTHTYPE_WPA2PSK:
+			if (64 > nwKey_length)
+				fprintf(f, "wpa_passphrase=%s\n", nwKey);
+			else if (64 == nwKey_length)
+				fprintf(f, "wpa_psk=%s\n", nwKey);
+			break;
+		default:
+			break;
+		}
+		
+		fprintf(f, "wps_state=%d\n", WPS_WPSSTATE_CONFIGURED);
+
+		ret = 0;
+	} while (0);
+
+	if (f)
+		fclose(f);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (nwKey)
+		os_free(nwKey);
+	if (eapType)
+		os_free(eapType);
+	if (eapIdentity)
+		os_free(eapIdentity);
+
+	return ret;
+}
+
+
+#define IE_CON_FOR_WIN_LEGACY_STA "\xdd\x05\x00\x50\xf2\x05\x00"
+#define IE_LEN_FOR_WIN_LEGACY_STA 7
+
+
+int wps_config_create_beacon_ie(void *hapd, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_config *wps;
+	struct wps_data *wps_ie;
+	struct hostapd_bss_config *bss = ((struct hostapd_data *)hapd)->conf;
+	struct hostapd_ssid *ssid = &bss->ssid;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!hapd || !buf || !len)
+			break;
+
+		*buf = 0;
+		*len = 0;
+
+		conf = ((struct hostapd_data *)hapd)->iconf;
+		if (!conf)
+			break;
+
+		wps = conf->wps;
+		if (!wps)
+			break;
+
+		if (wps_create_wps_data(&wps_ie))
+			break;
+
+		/* Version */
+		if (!wps->version)
+			u8val = WPS_VERSION;
+		else
+			u8val = wps->version;
+		if (wps_set_value(wps_ie, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Wi-Fi Protected Setup State */
+		if (wps_set_value(wps_ie, WPS_TYPE_WPSSTATE, &wps->wps_state, 0))
+			break;
+
+		if (wps->ap_setup_locked) {
+			/* AP Setup Locked */
+			if (wps_set_value(wps_ie, WPS_TYPE_AP_SETUP_LOCKED, &wps->ap_setup_locked, 0))
+				break;
+		}
+
+		if (wps->selreg) {
+			/* Seletected Registrar */
+			if (wps_set_value(wps_ie, WPS_TYPE_SEL_REGISTRAR, &wps->selreg, 0))
+				break;
+
+			/* Device Password ID */
+			if (wps_set_value(wps_ie, WPS_TYPE_DEVICE_PWD_ID, &wps->dev_pwd_id, 0))
+				break;
+
+			/* Selected Registrar Config Methods */
+			if (wps_set_value(wps_ie, WPS_TYPE_SEL_REG_CFG_METHODS, &wps->selreg_config_methods, 0))
+				break;
+		}
+
+		length = 0;
+		if (wps_write_wps_ie(wps_ie, buf, &length))
+			break;
+		*len += length;
+
+		if (!(bss->wpa & (HOSTAPD_WPA_VERSION_WPA|HOSTAPD_WPA_VERSION_WPA2)) &&
+			 ssid->wep.keys_set) {
+			*buf = (u8 *)os_realloc(*buf, length + IE_LEN_FOR_WIN_LEGACY_STA);
+			if (!*buf)
+				break;
+			os_memcpy(*buf + length, IE_CON_FOR_WIN_LEGACY_STA, IE_LEN_FOR_WIN_LEGACY_STA);
+			*len += IE_LEN_FOR_WIN_LEGACY_STA;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (buf && *buf) {
+			os_free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_config_create_probe_resp_ie(void *hapd, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_config *wps;
+	struct wps_data *wps_ie = 0;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!hapd || !buf || !len)
+			break;
+
+		*buf = 0;
+		*len = 0;
+
+		conf = ((struct hostapd_data *)hapd)->iconf;
+		if (!conf)
+			break;
+
+		wps = conf->wps;
+		if (!wps)
+			break;
+
+		if (wps_create_wps_data(&wps_ie))
+			break;
+
+		/* Version */
+		if (!wps->version)
+			u8val = WPS_VERSION;
+		else
+			u8val = wps->version;
+		if (wps_set_value(wps_ie, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Wi-Fi Protected Setup State */
+		if (wps_set_value(wps_ie, WPS_TYPE_WPSSTATE, &wps->wps_state, 0))
+			break;
+
+		if (wps->ap_setup_locked) {
+			/* AP Setup Locked */
+			if (wps_set_value(wps_ie, WPS_TYPE_AP_SETUP_LOCKED, &wps->ap_setup_locked, 0))
+				break;
+		}
+
+		if (wps->selreg) {
+			/* Seletected Registrar */
+			if (wps_set_value(wps_ie, WPS_TYPE_SEL_REGISTRAR, &wps->selreg, 0))
+				break;
+
+			/* Device Password ID */
+			if (wps_set_value(wps_ie, WPS_TYPE_DEVICE_PWD_ID, &wps->dev_pwd_id, 0))
+				break;
+
+			/* Selected Registrar Config Methods */
+			if (wps_set_value(wps_ie, WPS_TYPE_SEL_REG_CFG_METHODS, &wps->selreg_config_methods, 0))
+				break;
+		}
+
+		/* Response Type */
+		if (WPS_REGMODE_NONE_GET_CONF == wps->reg_mode)
+			u8val = WPS_RESTYPE_ENROLLEE_INFO_ONLY;
+		else
+			u8val = WPS_RESTYPE_AP;
+		if (wps_set_value(wps_ie, WPS_TYPE_RESP_TYPE, &u8val, 0))
+			break;
+
+		/* UUID-E */
+		if (!wps->uuid_set)
+			break;
+		if (wps_set_value(wps_ie, WPS_TYPE_UUID_E, wps->uuid, sizeof(wps->uuid)))
+			break;
+
+		/* Manufacturer */
+		if (wps_set_value(wps_ie, WPS_TYPE_MANUFACTURER, wps->manufacturer, wps->manufacturer_len))
+			break;
+
+		/* Model Name */
+		if (wps_set_value(wps_ie, WPS_TYPE_MODEL_NAME, wps->model_name, wps->model_name_len))
+			break;
+
+		/* Model Number */
+		if (wps_set_value(wps_ie, WPS_TYPE_MODEL_NUMBER, wps->model_number, wps->model_number_len))
+			break;
+
+		/* Serial Number */
+		if (wps_set_value(wps_ie, WPS_TYPE_SERIAL_NUM, wps->serial_number, wps->serial_number_len))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps_ie, WPS_TYPE_PRIM_DEV_TYPE, wps->prim_dev_type, sizeof(wps->prim_dev_type)))
+			break;
+
+		/* Device Name */
+		if (wps_set_value(wps_ie, WPS_TYPE_DEVICE_NAME, wps->dev_name, wps->dev_name_len))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps_ie, WPS_TYPE_CONFIG_METHODS, &wps->config_methods, 0))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps_ie, WPS_TYPE_RF_BANDS, &wps->rf_bands, 0))
+			break;
+
+		length = 0;
+		if (wps_write_wps_ie(wps_ie, buf, &length))
+			break;
+		*len += length;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (buf && *buf) {
+			os_free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_config_create_assoc_resp_ie(void *hapd, u8 **buf, size_t *len)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_config *wps;
+	struct wps_data *wps_ie = 0;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!hapd || !buf || !len)
+			break;
+
+		*buf = 0;
+		*len = 0;
+
+		conf = ((struct hostapd_data *)hapd)->iconf;
+		if (!conf)
+			break;
+
+		wps = conf->wps;
+		if (!wps)
+			break;
+
+		if (wps_create_wps_data(&wps_ie))
+			break;
+
+		/* Version */
+		if (!wps->version)
+			u8val = WPS_VERSION;
+		else
+			u8val = wps->version;
+		if (wps_set_value(wps_ie, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+
+		/* Response Type */
+		if (WPS_REGMODE_NONE_GET_CONF == wps->reg_mode)
+			u8val = WPS_RESTYPE_ENROLLEE_INFO_ONLY;
+		else
+			u8val = WPS_RESTYPE_AP;
+		if (wps_set_value(wps_ie, WPS_TYPE_RESP_TYPE, &u8val, 0))
+			break;
+
+		length = 0;
+		if (wps_write_wps_ie(wps_ie, buf, &length))
+			break;
+		*len += length;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (buf && *buf) {
+			os_free(*buf);
+			*buf = 0;
+		}
+		if (len)
+			*len = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_get_wps_ie_txt(void *hapd, u8 *ie, size_t ie_len, char *buf, size_t buf_len)
+{
+	int ret = -1;
+	struct wps_data *data = 0;
+	u8 rfbands;
+	u8 uuid[SIZE_UUID];
+	u8 devtype[SIZE_8_BYTES];
+	u16 len;
+	size_t written, total = 0;
+
+	do {
+		if (!hapd || !ie || !ie_len || !buf || !buf_len)
+			break;
+
+		if (wps_create_wps_data(&data))
+			break;
+
+		if (wps_parse_wps_ie(ie, ie_len, data))
+			break;
+
+		/* UUID-E */
+		len = sizeof(uuid);
+		if(!wps_get_value(data, WPS_TYPE_UUID_E, uuid, &len)) {
+			written = os_snprintf(buf + total, buf_len - total, "UUID-E=");
+			if (written >= 0)
+				total += written;
+			written = wpa_snprintf_hex_uppercase(buf + total, buf_len - total, uuid, len);
+			if (written >= 0)
+				total += written;
+			written = os_snprintf(buf + total, buf_len - total, "\n");
+			if (written >= 0)
+				total += written;
+		}
+
+		/* UUID-R */
+		len = sizeof(uuid);
+		if(!wps_get_value(data, WPS_TYPE_UUID_R, uuid, &len)) {
+			written = os_snprintf(buf + total, buf_len - total, "UUID-R=");
+			if (written >= 0)
+				total += written;
+			written = wpa_snprintf_hex_uppercase(buf + total, buf_len - total, uuid, len);
+			if (written >= 0)
+				total += written;
+			written = os_snprintf(buf + total, buf_len - total, "\n");
+			if (written >= 0)
+				total += written;
+		}
+
+		/* Primary Device Type */
+		len = sizeof(devtype);
+		if(!wps_get_value(data, WPS_TYPE_PRIM_DEV_TYPE, devtype, &len)) {
+			u16 category_id, sub_category_id;
+			char *category = 0, *sub_category = 0;
+
+			category_id = WPA_GET_BE16(devtype);
+			sub_category_id = WPA_GET_BE16(devtype + 6);
+			switch (category_id) {
+			case 1:		/* Computer */
+				category = "Computer";
+				switch (sub_category_id) {
+				case 1: sub_category = "PC"; break;
+				case 2: sub_category = "Server"; break;
+				default: break;
+				}
+				break;
+			case 2:		/* Input Device */
+				category = "Input Device";
+				break;
+			case 3:		/* Printers, Scanners, Faxes and Copiers */
+				category = "Printers, Scanners, Faxes and Copiers";
+				switch (sub_category_id) {
+				case 1: sub_category = "Printer"; break;
+				case 2: sub_category = "Scanner"; break;
+				default: break;
+				}
+				break;
+			case 4:		/* Camera */
+				category = "Camera";
+				switch (sub_category_id) {
+				case 1: sub_category = "Digital Still Camera"; break;
+				default: break;
+				}
+				break;
+			case 5:		/* Storage */
+				category = "Storage";
+				switch (sub_category_id) {
+				case 1: sub_category = "NAS"; break;
+				default: break;
+				}
+				break;
+			case 6:		/* Network Infrastructure */
+				category = "Network Infrastructure";
+				switch (sub_category_id) {
+				case 1: sub_category = "AP"; break;
+				case 2: sub_category = "Router"; break;
+				case 3: sub_category = "Switch"; break;
+				default: break;
+				}
+				break;
+			case 7:		/* Displays */
+				category = "Displays";
+				switch (sub_category_id) {
+				case 1: sub_category = "Television"; break;
+				case 2: sub_category = "Electronic Picture Frame"; break;
+				case 3: sub_category = "Projector"; break;
+				default: break;
+				}
+				break;
+			case 8:		/* Multimedia Devices */
+				category = "Multimedia Devices";
+				switch (sub_category_id) {
+				case 1: sub_category = "DAR"; break;
+				case 2: sub_category = "PVR"; break;
+				case 3: sub_category = "MCX"; break;
+				default: break;
+				}
+				break;
+			case 9:		/* Gaming Devices */
+				category = "Gaming Devices";
+				switch (sub_category_id) {
+				case 1: sub_category = "Xbox"; break;
+				case 2: sub_category = "Xbox360"; break;
+				case 3: sub_category = "Playstation"; break;
+				default: break;
+				}
+				break;
+			case 10:	/* Telephone */
+				category = "Telephone";
+				switch (sub_category_id) {
+				case 1: sub_category = "Windows Mobile"; break;
+				default: break;
+				}
+				break;
+			default:
+				break;
+			}
+
+			if (category) {
+				written = os_snprintf(buf + total, buf_len - total, "Category=%s\n", category);
+				if (written >= 0)
+					total += written;
+			}
+			written = os_snprintf(buf + total, buf_len - total, "Device OUI=");
+			if (written >= 0)
+				total += written;
+			written = wpa_snprintf_hex_uppercase(buf + total, buf_len - total, devtype + 2, 4);
+			if (written >= 0)
+				total += written;
+			written = os_snprintf(buf + total, buf_len - total, "\n");
+			if (written >= 0)
+				total += written;
+			if (sub_category) {
+				written = os_snprintf(buf + total, buf_len - total, "Sub Category=%s\n", sub_category);
+				if (written >= 0)
+					total += written;
+			}
+		}
+
+		/* RF Bands */
+		if(!wps_get_value(data, WPS_TYPE_RF_BANDS, &rfbands, 0)) {
+			if (rfbands) {
+				written = os_snprintf(buf + total, buf_len - total, "RF Bands=%s%s%sGHz\n",
+								   (rfbands & WPS_RFBAND_50GHZ)?"5.0":"",
+								   (rfbands & (WPS_RFBAND_50GHZ|WPS_RFBAND_24GHZ))?",":"",
+								   (rfbands & WPS_RFBAND_24GHZ)?"2.4":"");
+				if (written >= 0)
+					total += written;
+			}
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&data);
+
+	if (ret)
+		return -1;
+	return total;
+}
+
+
Index: wps_config.h
===================================================================
--- wps_config.h	(revision 0)
+++ wps_config.h	(revision 2)
@@ -0,0 +1,431 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_config.h
+//  Description: EAP-WPS config source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_CONFIG_H
+#define WPS_CONFIG_H
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+/* Wi-Fi Protected Setup Version */
+#define WPS_VERSION		0x10
+#define WPS_VERSION_EX	0x11
+
+/* Data Element Definitions */
+#define WPS_TYPE_AP_CHANNEL				0x1001
+#define WPS_TYPE_ASSOC_STATE			0x1002
+#define WPS_TYPE_AUTH_TYPE				0x1003
+#define WPS_TYPE_AUTH_TYPE_FLAGS		0x1004
+#define WPS_TYPE_AUTHENTICATOR			0x1005
+#define WPS_TYPE_CONFIG_METHODS			0x1008
+#define WPS_TYPE_CONFIG_ERROR			0x1009
+#define WPS_TYPE_CONF_URL4				0x100A
+#define WPS_TYPE_CONF_URL6				0x100B
+#define WPS_TYPE_CONN_TYPE				0x100C
+#define WPS_TYPE_CONN_TYPE_FLAGS		0x100D
+#define WPS_TYPE_CREDENTIAL				0x100E
+#define WPS_TYPE_DEVICE_NAME			0x1011
+#define WPS_TYPE_DEVICE_PWD_ID			0x1012
+#define WPS_TYPE_E_HASH1				0x1014
+#define WPS_TYPE_E_HASH2				0x1015
+#define WPS_TYPE_E_SNONCE1				0x1016
+#define WPS_TYPE_E_SNONCE2				0x1017
+#define WPS_TYPE_ENCR_SETTINGS			0x1018
+#define WPS_TYPE_ENCR_TYPE				0x100F
+#define WPS_TYPE_ENCR_TYPE_FLAGS		0x1010
+#define WPS_TYPE_ENROLLEE_NONCE			0x101A
+#define WPS_TYPE_FEATURE_ID				0x101B
+#define WPS_TYPE_IDENTITY				0x101C
+#define WPS_TYPE_IDENTITY_PROOF			0x101D
+#define WPS_TYPE_KEY_WRAP_AUTH			0x101E
+#define WPS_TYPE_KEY_IDENTIFIER			0x101F
+#define WPS_TYPE_MAC_ADDR				0x1020
+#define WPS_TYPE_MANUFACTURER			0x1021
+#define WPS_TYPE_MSG_TYPE				0x1022
+#define WPS_TYPE_MODEL_NAME				0x1023
+#define WPS_TYPE_MODEL_NUMBER			0x1024
+#define WPS_TYPE_NW_INDEX				0x1026
+#define WPS_TYPE_NW_KEY					0x1027
+#define WPS_TYPE_NW_KEY_INDEX			0x1028
+#define WPS_TYPE_NEW_DEVICE_NAME		0x1029
+#define WPS_TYPE_NEW_PWD				0x102A
+#define WPS_TYPE_OOB_DEV_PWD			0x102C
+#define WPS_TYPE_OS_VERSION				0x102D
+#define WPS_TYPE_POWER_LEVEL			0x102F
+#define WPS_TYPE_PSK_CURRENT			0x1030
+#define WPS_TYPE_PSK_MAX				0x1031
+#define WPS_TYPE_PUBLIC_KEY				0x1032
+#define WPS_TYPE_RADIO_ENABLED			0x1033
+#define WPS_TYPE_REBOOT					0x1034
+#define WPS_TYPE_REGISTRAR_CURRENT		0x1035
+#define WPS_TYPE_REGISTRAR_ESTBLSHD		0x1036
+#define WPS_TYPE_REGISTRAR_LIST			0x1037
+#define WPS_TYPE_REGISTRAR_MAX			0x1038
+#define WPS_TYPE_REGISTRAR_NONCE		0x1039
+#define WPS_TYPE_REQ_TYPE				0x103A
+#define WPS_TYPE_RESP_TYPE				0x103B
+#define WPS_TYPE_RF_BANDS				0x103C
+#define WPS_TYPE_R_HASH1				0x103D
+#define WPS_TYPE_R_HASH2				0x103E
+#define WPS_TYPE_R_SNONCE1				0x103F
+#define WPS_TYPE_R_SNONCE2				0x1040
+#define WPS_TYPE_SEL_REGISTRAR			0x1041
+#define WPS_TYPE_SERIAL_NUM				0x1042
+#define WPS_TYPE_WPSSTATE				0x1044
+#define WPS_TYPE_SSID					0x1045
+#define WPS_TYPE_TOT_NETWORKS			0x1046
+#define WPS_TYPE_UUID_E					0x1047
+#define WPS_TYPE_UUID_R					0x1048
+#define WPS_TYPE_VENDOR_EXT				0x1049
+#define WPS_TYPE_VERSION				0x104A
+#define WPS_TYPE_X509_CERT_REQ			0x104B
+#define WPS_TYPE_X509_CERT				0x104C
+#define WPS_TYPE_EAP_IDENTITY			0x104D
+#define WPS_TYPE_MSG_COUNTER			0x104E
+#define WPS_TYPE_PUBKEY_HASH			0x104F
+#define WPS_TYPE_REKEY_KEY				0x1050
+#define WPS_TYPE_KEY_LIFETIME			0x1051
+#define WPS_TYPE_PERM_CFG_METHODS		0x1052
+#define WPS_TYPE_SEL_REG_CFG_METHODS	0x1053
+#define WPS_TYPE_PRIM_DEV_TYPE			0x1054
+#define WPS_TYPE_SEC_DEV_TYPE_LIST		0x1055
+#define WPS_TYPE_PORTABLE_DEVICE		0x1056
+#define WPS_TYPE_AP_SETUP_LOCKED		0x1057
+#define WPS_TYPE_APP_EXT				0x1058
+#define WPS_TYPE_EAP_TYPE				0x1059
+#define WPS_TYPE_INIT_VECTOR			0x1060
+#define WPS_TYPE_KEY_PROVIDED_AUTO		0x1061
+#define WPS_TYPE_8021X_ENABLED			0x1062
+#define WPS_TYPE_APP_SESS_KEY			0x1063
+#define WPS_TYPE_WEP_TX_KEY				0x1064
+
+/* Association states */
+#define WPS_ASSOC_NOT_ASSOCIATED	0
+#define WPS_ASSOC_CONN_SUCCESS		1
+#define WPS_ASSOC_CONFIG_FAIL		2
+#define WPS_ASSOC_ASSOC_FAIL		3
+#define WPS_ASSOC_IP_FAIL			4
+
+/* Authentication types */
+#define WPS_AUTHTYPE_OPEN		0x0001
+#define WPS_AUTHTYPE_WPAPSK		0x0002
+#define WPS_AUTHTYPE_SHARED		0x0004
+#define WPS_AUTHTYPE_WPA		0x0008
+#define WPS_AUTHTYPE_WPA2		0x0010
+#define WPS_AUTHTYPE_WPA2PSK	0x0020
+
+/* Config methods */
+#define WPS_CONFMET_USBA		0x0001
+#define WPS_CONFMET_ETHERNET	0x0002
+#define WPS_CONFMET_LABEL		0x0004
+#define WPS_CONFMET_DISPLAY		0x0008
+#define WPS_CONFMET_EXT_NFC_TOK	0x0010
+#define WPS_CONFMET_INT_NFC_TOK	0x0020
+#define WPS_CONFMET_NFC_INTF	0x0040
+#define WPS_CONFMET_PBC			0x0080
+#define WPS_CONFMET_KEYPAD		0x0100
+
+/* WPS error messages */
+#define WPS_ERROR_NO_ERROR				0
+#define WPS_ERROR_OOB_INT_READ_ERR		1
+#define WPS_ERROR_DECRYPT_CRC_FAIL		2
+#define WPS_ERROR_CHAN24_NOT_SUPP		3
+#define WPS_ERROR_CHAN50_NOT_SUPP		4
+#define WPS_ERROR_SIGNAL_WEAK			5
+#define WPS_ERROR_NW_AUTH_FAIL			6
+#define WPS_ERROR_NW_ASSOC_FAIL			7
+#define WPS_ERROR_NO_DHCP_RESP			8
+#define WPS_ERROR_FAILED_DHCP_CONF		9
+#define WPS_ERROR_IP_ADDR_CONFLICT		10
+#define WPS_ERROR_FAIL_CONN_REGISTRAR	11
+#define WPS_ERROR_MULTI_PBC_DETECTED	12
+#define WPS_ERROR_ROGUE_SUSPECTED		13
+#define WPS_ERROR_DEVICE_BUSY			14
+#define WPS_ERROR_SETUP_LOCKED			15
+#define WPS_ERROR_MSG_TIMEOUT			16
+#define WPS_ERROR_REG_SESSION_TIMEOUT	17
+#define WPS_ERROR_DEV_PWD_AUTH_FAIL		18
+
+/* Connection types */
+#define WPS_CONNTYPE_ESS	0x01
+#define WPS_CONNTYPE_IBSS	0x02
+
+/* Device password ID */
+#define WPS_DEVICEPWDID_DEFAULT			0x0000
+#define WPS_DEVICEPWDID_USER_SPEC		0x0001
+#define WPS_DEVICEPWDID_MACHINE_SPEC	0x0002
+#define WPS_DEVICEPWDID_REKEY			0x0003
+#define WPS_DEVICEPWDID_PUSH_BTN		0x0004
+#define WPS_DEVICEPWDID_REG_SPEC		0x0005
+
+/* Device type */
+/*
+#define WPS_DEVICETYPE_COMPUTER			"Computer"
+#define WPS_DEVICETYPE_AP				"Access_Point"
+#define WPS_DEVICETYPE_ROUTER_AP		"Router_AP"
+#define WPS_DEVICETYPE_PRINTER			"Printer"
+#define WPS_DEVICETYPE_PRINTER_BRIDGE	"Printer_Brigde"
+#define WPS_DEVICETYPE_ELECT_PIC_FRAME	"Electronic_Picture_Frame"
+#define WPS_DEVICETYPE_DIG_AUDIO_RECV	"Digital_Audio_Receiver"
+#define WPS_DEVICETYPE_WIN_MCE			"Windows_Media_Center_Extender"
+#define WPS_DEVICETYPE_WIN_MOBILE		"Windows_Mobile"
+#define WPS_DEVICETYPE_PVR				"Personal_Video_Recorder"
+#define WPS_DEVICETYPE_VIDEO_STB		"Video_STB"
+#define WPS_DEVICETYPE_PROJECTOR		"Projector"
+#define WPS_DEVICETYPE_IP_TV			"IP_TV"
+#define WPS_DEVICETYPE_DIG_STILL_CAM	"Digital_Still_Camera"
+#define WPS_DEVICETYPE_PHONE			"Phone"
+#define WPS_DEVICETYPE_VOID_PHONE		"VoIP_Phone"
+#define WPS_DEVICETYPE_GAME_CONSOLE		"Game_console"
+#define WPS_DEVICETYPE_OTHER			"Other"
+*/
+
+/* Encryption type */
+#define WPS_ENCRTYPE_NONE	0x0001
+#define WPS_ENCRTYPE_WEP	0x0002
+#define WPS_ENCRTYPE_TKIP	0x0004
+#define WPS_ENCRTYPE_AES	0x0008
+
+
+/* WPS Message Types */
+#define WPS_MSGTYPE_BEACON		0x01
+#define WPS_MSGTYPE_PROBE_REQ	0x02
+#define WPS_MSGTYPE_PROBE_RESP	0x03
+#define WPS_MSGTYPE_M1			0x04
+#define WPS_MSGTYPE_M2			0x05
+#define WPS_MSGTYPE_M2D			0x06
+#define WPS_MSGTYPE_M3			0x07
+#define WPS_MSGTYPE_M4			0x08
+#define WPS_MSGTYPE_M5			0x09
+#define WPS_MSGTYPE_M6			0x0A
+#define WPS_MSGTYPE_M7			0x0B
+#define WPS_MSGTYPE_M8			0x0C
+#define WPS_MSGTYPE_ACK			0x0D
+#define WPS_MSGTYPE_NACK		0x0E
+#define WPS_MSGTYPE_DONE		0x0F
+
+/*Device Type categories for primary and secondary device types */
+#define WPS_DEVICE_TYPE_CAT_COMPUTER		1
+#define WPS_DEVICE_TYPE_CAT_INPUT_DEVICE	2
+#define WPS_DEVICE_TYPE_CAT_PRINTER			3
+#define WPS_DEVICE_TYPE_CAT_CAMERA			4
+#define WPS_DEVICE_TYPE_CAT_STORAGE			5
+#define WPS_DEVICE_TYPE_CAT_NW_INFRA		6
+#define WPS_DEVICE_TYPE_CAT_DISPLAYS		7
+#define WPS_DEVICE_TYPE_CAT_MM_DEVICES		8
+#define WPS_DEVICE_TYPE_CAT_GAME_DEVICES	9
+#define WPS_DEVICE_TYPE_CAT_TELEPHONE		10
+
+/* Device Type sub categories for primary and secondary device types */
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_PC			1
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_SERVER		2
+#define WPS_DEVICE_TYPE_SUB_CAT_COMP_MEDIA_CTR	3
+#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_PRINTER	1
+#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_SCANNER	2
+#define WPS_DEVICE_TYPE_SUB_CAT_CAM_DGTL_STILL	1
+#define WPS_DEVICE_TYPE_SUB_CAT_STOR_NAS		1
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_AP			1
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_ROUTER		2
+#define WPS_DEVICE_TYPE_SUB_CAT_NW_SWITCH		3
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_TV			1
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PIC_FRAME	2
+#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PROJECTOR	3
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_DAR			1
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_PVR			2
+#define WPS_DEVICE_TYPE_SUB_CAT_MM_MCX			3
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX		1
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX_360	2
+#define WPS_DEVICE_TYPE_SUB_CAT_GAM_PS			3
+#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_WM		1
+
+/* Device request type */
+#define WPS_REQTYPE_ENROLLEE_INFO_ONLY	0x00
+#define WPS_REQTYPE_ENROLLEE_OPEN_8021X	0x01
+#define WPS_REQTYPE_REGISTRAR			0x02
+#define WPS_REQTYPE_AP_WLAN_MGR			0x03
+
+/* Device response type */
+#define WPS_RESTYPE_ENROLLEE_INFO_ONLY	0x00
+#define WPS_RESTYPE_ENROLLEE_OPEN_8021X	0x01
+#define WPS_RESTYPE_REGISTRAR			0x02
+#define WPS_RESTYPE_AP					0x03
+
+/* RF Band */
+#define WPS_RFBAND_24GHZ	0x01
+#define WPS_RFBAND_50GHZ	0x02
+
+/* Wi-Fi Protected Setup State */
+#define WPS_WPSSTATE_UNCONFIGURED	0x01
+#define WPS_WPSSTATE_CONFIGURED		0x02
+
+/* WPS OUI for primary and secondary device type sub-category */
+#define WPS_DEVTYPE_OUI	0x0050f204
+
+#define SIZE_1_BYTE		1
+#define SIZE_2_BYTES		2
+#define SIZE_4_BYTES		4
+#define SIZE_6_BYTES		6
+#define SIZE_8_BYTES		8
+#define SIZE_16_BYTES		16
+#define SIZE_20_BYTES		20
+#define SIZE_32_BYTES		32
+#define SIZE_64_BYTES		64
+#define SIZE_80_BYTES		80
+#define SIZE_128_BYTES		128
+#define SIZE_192_BYTES		192
+
+
+#define SIZE_64_BITS		SIZE_8_BYTES
+#define SIZE_128_BITS		SIZE_16_BYTES
+#define SIZE_160_BITS		SIZE_20_BYTES
+#define SIZE_256_BITS		SIZE_32_BYTES
+#define SIZE_512_BITS		SIZE_64_BYTES
+#define SIZE_1024_BITS		SIZE_128_BYTES
+#define SIZE_1536_BITS		SIZE_192_BYTES
+
+#define SIZE_ENCR_IV			SIZE_128_BITS
+#define ENCR_DATA_BLOCK_SIZE		SIZE_128_BITS
+#define SIZE_DATA_HASH			SIZE_160_BITS
+#define SIZE_PUB_KEY_HASH		SIZE_160_BITS
+#define SIZE_UUID				SIZE_16_BYTES
+#define SIZE_MAC_ADDR			SIZE_6_BYTES
+#define SIZE_PUB_KEY			SIZE_1536_BITS
+#define SIZE_NONCE				SIZE_128_BITS
+
+#define WPS_PERSONALIZATION_STRING "Wi-Fi Easy and Secure Key Derivation"
+#define PRF_DIGEST_SIZE         SIZE_256_BITS
+#define KDF_KEY_BITS            640
+
+#define WPS_IDENTITY_ENROLLEE	"WFA-SimpleConfig-Enrollee-1-0"
+#define WPS_IDENTITY_REGISTRAR	"WFA-SimpleConfig-Registrar-1-0"
+
+enum wps_reg_mode {
+	WPS_REGMODE_NONE_GET_CONF = 0,
+	WPS_REGMODE_NONE_ADDED,
+	WPS_REGMODE_REGISTER_STA
+};
+
+struct wps_config {
+	u8		version;
+
+	u8		uuid[SIZE_UUID];
+	int		uuid_set;
+
+	u8		mac[SIZE_MAC_ADDR];
+	int		mac_set;
+
+	u16		auth_type_flags;
+
+	u16		encr_type_flags;
+
+	u8		conn_type_flags;
+
+	u16		config_methods;
+
+	u8		wps_state;
+	u8		selreg;
+	u16		selreg_config_methods;
+
+	u8		ap_setup_locked;
+
+	u8		*manufacturer;
+	size_t	manufacturer_len;
+
+	u8		*model_name;
+	size_t	model_name_len;
+
+	u8		*model_number;
+	size_t	model_number_len;
+
+	u8		*serial_number;
+	size_t	serial_number_len;
+
+	u16		dev_category;
+	u16		dev_sub_category;
+	u8		dev_oui[SIZE_4_BYTES];
+	u8		prim_dev_type[SIZE_8_BYTES];
+
+	u8		*dev_name;
+	size_t	dev_name_len;
+
+	u8		rf_bands;
+
+	u32		os_version;
+
+	u16		dev_pwd_id;
+	u8		dev_pwd[SIZE_64_BYTES];
+	size_t	dev_pwd_len;
+
+	u8		pub_key[SIZE_PUB_KEY];
+	u8		set_pub_key;
+	void	*dh_secret;
+
+	enum wps_reg_mode reg_mode;
+	u8		*config;
+	size_t	config_len;
+
+	u8		enabled_pbc;
+	struct os_time end_pbc_time;
+
+#ifdef WPS_OPT_UPNP
+	char	*upnp_iface;
+	char	*upnp_root_dir;
+	char	*upnp_desc_url;
+	int		upnp_enabled;
+#endif /* WPS_OPT_UPNP */
+};
+
+
+struct wpa_supplicant;
+struct wpa_ssid;
+struct wpa_scan_result;
+
+int wps_config_free_dh(void **dh);
+
+int wps_get_ssid_configuration(void *ctx, u8 **buf, size_t *len, int inband);
+int wps_get_auto_configuration(void *ctx, u8 **buf, size_t *len);
+int wps_set_ssid_configuration(void *ctx, char *filename, u8 *buf, size_t len);
+
+int wps_config_create_beacon_ie(void *hapd, u8 **buf, size_t *len);
+int wps_config_create_probe_resp_ie(void *hapd, u8 **buf, size_t *len);
+int wps_config_create_assoc_resp_ie(void *hapd, u8 **buf, size_t *len);
+
+int wps_get_wps_ie_txt(void *hapd, u8 *ie, size_t ie_len, char *buf, size_t buf_len);
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+#endif /* WPS_CONFIG_H */
Index: Changes_WPS
===================================================================
--- Changes_WPS	(revision 0)
+++ Changes_WPS	(revision 2)
@@ -0,0 +1,43 @@
+1.Changed files
+ap.h
+config.c
+config.h
+ctrl_iface.c
+defconfig
+driver.h
+driver_madwifi.c
+eap.c
+eap.h
+eap_i.h
+eap_methods.c
+eapol_sm.c
+eapol_sm.h
+eloop.c
+hostapd.c
+hostapd.h
+ieee802_1x.c
+Makefile
+vlan_init.c
+vlan_init.h
+wpa.c
+wpa.h
+
+2. Added files
+base64.c
+base64.h
+Changes_WPS
+eap_wps.c
+eap_wps.h
+testbed_ap
+upnp_wps_common.c
+upnp_wps_common.h
+upnp_wps_device.c
+upnp_wps_device.h
+wps_config.c
+wps_config.h
+wps_opt_nfc.c
+wps_opt_nfc.h
+wps_opt_upnp.c
+wps_opt_upnp.h
+wps_parser.c
+wps_parser.h
Index: upnp_wps_common.c
===================================================================
--- upnp_wps_common.c	(revision 0)
+++ upnp_wps_common.c	(revision 2)
@@ -0,0 +1,281 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_common.c
+//  Description: EAP-WPS UPnP common source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+#include "os.h"
+
+#include <upnp/ithread.h>
+#include <upnp/upnp.h>
+#include <upnp/upnptools.h>
+#include <upnp/ixml.h>
+
+int
+upnp_get_element_value(IXML_Element *element, char **value)
+{
+	int ret = -1;
+	IXML_Node *child;
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!element)
+			break;
+
+		child = ixmlNode_getFirstChild((IXML_Node *)element);
+		if (!child)
+			break;
+
+		if (eTEXT_NODE != ixmlNode_getNodeType(child))
+			break;
+
+		*value = os_strdup(ixmlNode_getNodeValue(child));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+IXML_NodeList *
+upnp_get_first_service_list(IXML_Document *doc)
+{
+	IXML_NodeList *service_list = 0;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *node = 0;
+
+	do {
+		if (!doc)
+			break;
+
+		node_list = ixmlDocument_getElementsByTagName(doc, "serviceList");
+		if (!node_list)
+			break;
+
+		if (!ixmlNodeList_length(node_list))
+			break;
+		node = ixmlNodeList_item(node_list, 0);
+
+		service_list = ixmlElement_getElementsByTagName((IXML_Element *)node,
+													    "service");
+		if (!service_list)
+			break;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	return service_list;
+}
+
+
+int
+upnp_get_first_document_item(IXML_Document *doc,
+							 const char *item,
+							 char **value)
+{
+	int ret = -1;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *item_node;
+	IXML_Node *txt_node;
+
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!doc || !item)
+			break;
+
+		node_list = ixmlDocument_getElementsByTagName(doc, (char *)item);
+		if (!node_list)
+			break;
+
+		item_node = ixmlNodeList_item(node_list, 0);
+		if (!item_node)
+			break;
+
+		txt_node = ixmlNode_getFirstChild(item_node);
+		*value = os_strdup(ixmlNode_getNodeValue(txt_node));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+int
+upnp_get_first_element_item(IXML_Element *element,
+							const char *item,
+							char **value)
+{
+	int ret = -1;
+	IXML_NodeList *node_list = 0;
+	IXML_Node *item_node;
+	IXML_Node *txt_node;
+
+	do {
+		if (!value)
+			break;
+		*value = 0;
+
+		if (!element || !item)
+			break;
+
+		node_list = ixmlElement_getElementsByTagName(element, (char *)item);
+		if (!node_list)
+			break;
+
+		item_node = ixmlNodeList_item(node_list, 0);
+		if (!item_node)
+			break;
+
+		txt_node = ixmlNode_getFirstChild(item_node);
+		*value = os_strdup(ixmlNode_getNodeValue(txt_node));
+		if (!*value)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (node_list)
+		ixmlNodeList_free(node_list);
+
+	if (ret) {
+		if (value && *value) {
+			os_free(*value);
+			*value = 0;
+		}
+	}
+
+	return ret;
+}
+
+int
+upnp_find_service(IXML_Document *desc_doc,
+				  char *location,
+				  char *service_type,
+				  char **service_id,
+				  char **scpd_url,
+				  char **control_url,
+				  char **event_url)
+{
+	char *base_url = 0;
+	char *base;
+	char *type = 0;
+	char *scpd = NULL, *ctrl_url = NULL, *ev_url = NULL;
+	IXML_NodeList *service_list = NULL;
+	IXML_Element *service = NULL;
+	int i, length, found = 0;
+
+	(void)upnp_get_first_document_item(desc_doc, "URLBase", &base_url);
+	if(base_url)
+		base = base_url;
+	else
+		base = location;
+
+	service_list = upnp_get_first_service_list(desc_doc);
+	length = ixmlNodeList_length(service_list);
+	for( i = 0; i < length; i++ ) {
+		service = (IXML_Element *)ixmlNodeList_item(service_list, i);
+		(void)upnp_get_first_element_item(service, "serviceType", &type);
+		if(0 == os_strcmp(type, service_type)) {
+			(void)upnp_get_first_element_item(service, "serviceId", service_id);
+			(void)upnp_get_first_element_item(service, "SCPDURL", &scpd);
+			(void)upnp_get_first_element_item(service, "controlURL", &ctrl_url);
+			(void)upnp_get_first_element_item(service, "eventSubURL", &ev_url);
+			*scpd_url = os_malloc(os_strlen(base) + os_strlen(scpd) + 1);
+			if (*scpd_url) {
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, scpd, *scpd_url))
+					;
+			}
+
+			*control_url = os_malloc(os_strlen(base) + os_strlen(ctrl_url) + 1);
+			if(*control_url) {
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, ctrl_url, *control_url))
+					;
+			}
+
+			*event_url = os_malloc(os_strlen(base) + os_strlen(ev_url) + 1);
+			if(*event_url) {
+				
+				if(UPNP_E_SUCCESS  != UpnpResolveURL(base, ev_url, *event_url))
+					;
+			}
+
+			if (scpd)
+				os_free(scpd);
+			if (ctrl_url)
+				os_free(ctrl_url);
+			if (ev_url)
+				os_free(ev_url);
+			scpd = ctrl_url = ev_url = 0;
+
+			found = 1;
+			break;
+		}
+	}
+
+	if(type)
+		os_free(type);
+    if(service_list)
+        ixmlNodeList_free(service_list);
+    if(base_url)
+        os_free(base_url);
+
+    return found;
+}
+
Index: wpa.c
===================================================================
--- wpa.c	(revision 1)
+++ wpa.c	(revision 2)
@@ -125,6 +125,10 @@
 
 	u32 dot11RSNAStatsTKIPLocalMICFailures;
 	u32 dot11RSNAStatsTKIPRemoteMICFailures;
+
+#ifdef EAP_WPS
+	enum enm_wps_state wps_state;
+#endif /* EAP_WPS */
 };
 
 
@@ -3790,5 +3794,32 @@
 	sm->group = group;
 	return 0;
 }
+#endif /* CONFIG_NATIVE_WINDOWS */
 
-#endif /* CONFIG_NATIVE_WINDOWS */
+
+#ifdef EAP_WPS
+int wpa_wps_prepare(struct wpa_state_machine *sm)
+{
+	if (!sm)
+		return -1;
+
+	sm->wpa_key_mgmt = WPA_KEY_MGMT_IEEE8021X;
+	sm->pairwise = WPA_CIPHER_NONE|WPA_CIPHER_WEP40|WPA_CIPHER_WEP104|
+					WPA_CIPHER_TKIP|WPA_CIPHER_CCMP;
+	sm->wpa = HOSTAPD_WPA_VERSION_WPA|HOSTAPD_WPA_VERSION_WPA2;
+	if (sm->wpa_ie) {
+		free(sm->wpa_ie);
+		sm->wpa_ie = NULL;
+	}
+	sm->wpa_ie_len = 0;
+	sm->wps_state = WPS_STATE_PREPARED;
+	return 0;
+}
+
+int wpa_wps_get_state(struct wpa_state_machine *sm)
+{
+	if (!sm)
+		return WPS_STATE_NONE;
+	return sm->wps_state;
+}
+#endif /* EAP_WPS */
Index: upnp_wps_common.h
===================================================================
--- upnp_wps_common.h	(revision 0)
+++ upnp_wps_common.h	(revision 2)
@@ -0,0 +1,57 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_common.h
+//  Description: EAP-WPS UPnP common source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef UPNP_WPS_COMMON_H
+#define UPNP_WPS_COMMON_H
+int
+upnp_get_element_value(IXML_Element *element, char **value);
+IXML_NodeList *
+upnp_get_first_service_list(IXML_Document *doc);
+int
+upnp_get_first_document_item(IXML_Document *doc,
+							 const char *item,
+							 char **value);
+int
+upnp_get_first_element_item(IXML_Element *element,
+							const char *item,
+							char **value);
+int
+upnp_find_service(IXML_Document *desc_doc,
+				  char *location,
+				  char *service_type,
+				  char **service_id,
+				  char **scpd_url,
+				  char **control_url,
+				  char **event_url);
+#endif /* UPNP_WPS_COMMON_H */
Index: testbed_ap/wpamsg.h
===================================================================
--- testbed_ap/wpamsg.h	(revision 0)
+++ testbed_ap/wpamsg.h	(revision 2)
@@ -0,0 +1,42 @@
+/*
+ * wpa_gui - WpaMsg class for storing event messages
+ * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef WPAMSG_H
+#define WPAMSG_H
+
+#include <QDateTime>
+#include <QLinkedList>
+
+class WpaMsg {
+public:
+	WpaMsg() {}
+	WpaMsg(const QString &_msg, int _priority = 2)
+		: msg(_msg), priority(_priority)
+	{
+		timestamp = QDateTime::currentDateTime();
+	}
+
+	QString getMsg() const { return msg; }
+	int getPriority() const { return priority; }
+	QDateTime getTimestamp() const { return timestamp; }
+
+private:
+	QString msg;
+	int priority;
+	QDateTime timestamp;
+};
+
+typedef QLinkedList<WpaMsg> WpaMsgList;
+
+#endif /* WPAMSG_H */
Index: testbed_ap/wepkey.cpp
===================================================================
--- testbed_ap/wepkey.cpp	(revision 0)
+++ testbed_ap/wepkey.cpp	(revision 2)
@@ -0,0 +1,302 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wepkey.cpp
+//  Description: Setting WEP key source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "wepkey.h"
+#include "mainprocess.h"
+#include "testbedap.h"
+
+#include <QMessageBox>
+#include <QFile>
+
+
+WepKey::WepKey(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedAp *>(wizard);
+	setupUi(this);
+
+	connect(rbWepKey1, SIGNAL(clicked()), SLOT(selectKeyIndex1()));
+	connect(rbWepKey2, SIGNAL(clicked()), SLOT(selectKeyIndex2()));
+	connect(rbWepKey3, SIGNAL(clicked()), SLOT(selectKeyIndex3()));
+	connect(rbWepKey4, SIGNAL(clicked()), SLOT(selectKeyIndex4()));
+	connect(pbGenWepKey1, SIGNAL(clicked()), SLOT(generateWepKey1()));
+	connect(pbGenWepKey2, SIGNAL(clicked()), SLOT(generateWepKey2()));
+	connect(pbGenWepKey3, SIGNAL(clicked()), SLOT(generateWepKey3()));
+	connect(pbGenWepKey4, SIGNAL(clicked()), SLOT(generateWepKey4()));
+
+	srand(time(0));
+}
+
+WepKey::~WepKey()
+{
+}
+
+bool WepKey::pre_back()
+{
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	wiz->pbNext->setFocus();
+	return true;
+}
+
+bool WepKey::pre_next()
+{
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	switch (MainProcess::getWepKeyIndex()) {
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+		selectKeyIndex(MainProcess::getWepKeyIndex());
+		break;
+	default:
+		QMessageBox::critical(this, label->text(), "Invalid WEP key Index");
+		return false;
+	}
+
+	leWepKey1->setText(MainProcess::getWepKey(1));
+	leWepKey2->setText(MainProcess::getWepKey(2));
+	leWepKey3->setText(MainProcess::getWepKey(3));
+	leWepKey4->setText(MainProcess::getWepKey(4));
+
+	wiz->pbNext->setFocus();
+	return true;
+}
+
+bool WepKey::post_next()
+{
+	bool ret = false;
+	int keyIndex;
+
+	do {
+		if (!checkInputs()) {
+			QMessageBox::critical(this, label->text(), "Input error");
+			break;
+		}
+
+		if (rbWepKey1->isChecked())
+			keyIndex = 1;
+		else if (rbWepKey2->isChecked())
+			keyIndex = 2;
+		else if (rbWepKey3->isChecked())
+			keyIndex = 3;
+		else if (rbWepKey4->isChecked())
+			keyIndex = 4;
+		else {
+			QMessageBox::critical(this, label->text(), "Cannot set WEP key index");
+			break;
+		}
+		MainProcess::setWepKeyIndex(keyIndex);
+
+		MainProcess::setWepKey(1, leWepKey1->text().toAscii());
+		MainProcess::setWepKey(2, leWepKey2->text().toAscii());
+		MainProcess::setWepKey(3, leWepKey3->text().toAscii());
+		MainProcess::setWepKey(4, leWepKey4->text().toAscii());
+
+		if (!MainProcess::writeConfigFile()) {
+			QMessageBox::critical(this, label->text(), "Cannot write main process configuration file");
+			break;
+		}
+
+		if (!MainProcess::start()) {
+			QMessageBox::critical(this, label->text(), "Cannot start main process");
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void WepKey::cancel()
+{
+	MainProcess::terminate();
+	wiz->close();
+}
+
+void WepKey::selectKeyIndex1()
+{
+	selectKeyIndex(1);
+}
+
+void WepKey::selectKeyIndex2()
+{
+	selectKeyIndex(2);
+}
+
+void WepKey::selectKeyIndex3()
+{
+	selectKeyIndex(3);
+}
+
+void WepKey::selectKeyIndex4()
+{
+	selectKeyIndex(4);
+}
+
+void WepKey::selectKeyIndex(int index)
+{
+	QRadioButton *rb[] = {
+		rbWepKey1,
+		rbWepKey2,
+		rbWepKey3,
+		rbWepKey4
+	};
+
+	for (int i = 0; i < 4; i++) {
+		if (i == (index - 1))
+			rb[i]->setChecked(true);
+		else
+			rb[i]->setChecked(false);
+	}
+}
+
+void WepKey::generateWepKey1()
+{
+	char key[26 + 1];
+
+	generateWepKey(key);
+
+	leWepKey1->clear();
+	leWepKey1->setText(key);
+}
+
+void WepKey::generateWepKey2()
+{
+	char key[26 + 1];
+
+	generateWepKey(key);
+
+	leWepKey2->clear();
+	leWepKey2->setText(key);
+}
+
+void WepKey::generateWepKey3()
+{
+	char key[26 + 1];
+
+	generateWepKey(key);
+
+	leWepKey3->clear();
+	leWepKey3->setText(key);
+}
+
+void WepKey::generateWepKey4()
+{
+	char key[26 + 1];
+
+	generateWepKey(key);
+
+	leWepKey4->clear();
+	leWepKey4->setText(key);
+}
+
+void WepKey::generateWepKey(char *key)
+{
+	for (int i = 0; i < 26; i++) {
+		key[i] = btoa(rand() % 16);
+	}
+	key[26] = 0;
+}
+
+char WepKey::btoa(int b, bool capital /* = true */ )
+{
+	if ((0 <= b) && (9 >= b)) {
+		return b + '0';
+	} else if ((0xA <= b) && (0xF >= b)) {
+		return (b - 0xA) + (capital?'A':'a');
+	} else {
+		return '0';
+	}
+}
+
+bool WepKey::checkInputs()
+{
+	bool ret = true;
+	QLineEdit *le [] = {
+		leWepKey1,
+		leWepKey2,
+		leWepKey3,
+		leWepKey4
+	};
+	QRadioButton *rb [] = {
+		rbWepKey1,
+		rbWepKey2,
+		rbWepKey3,
+		rbWepKey4
+	};
+	int index, i;
+
+	do {
+		/* WEP KEY */
+		for (index = 0; index < 4; index++) {
+			if ((10 == le[index]->text().length()) ||
+				(26 == le[index]->text().length())) {
+				for (i = 0; i < le[index]->text().length(); i++) {
+					if (!isxdigit(*(const char *)(le[index]->text().data() + i)))
+						break;
+				}
+				if (le[index]->text().length() != i) {
+					le[index]->setFocus();
+					ret = false;
+					break;
+				}
+			} else if ((0 != le[index]->text().length()) &&
+					   (5 != le[index]->text().length()) &&
+					   (13 != le[index]->text().length())) {
+				le[index]->setFocus();
+				ret = false;
+				break;
+			} else if (0 == le[index]->text().length()) {
+				if (rb[index]->isChecked()) {
+					le[index]->setFocus();
+					ret = false;
+					break;
+				}
+			}
+		}
+		if (!ret)
+			break;
+	} while (0);
+
+	return ret;
+}
+
Index: testbed_ap/about.ui
===================================================================
--- testbed_ap/about.ui	(revision 0)
+++ testbed_ap/about.ui	(revision 2)
@@ -0,0 +1,103 @@
+<ui version="4.0" >
+ <class>About</class>
+ <widget class="QDialog" name="About" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>580</width>
+    <height>460</height>
+   </rect>
+  </property>
+  <property name="sizePolicy" >
+   <sizepolicy>
+    <hsizetype>0</hsizetype>
+    <vsizetype>0</vsizetype>
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>580</width>
+    <height>460</height>
+   </size>
+  </property>
+  <property name="maximumSize" >
+   <size>
+    <width>580</width>
+    <height>460</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string>Wi-Fi Protected Setup Station Application</string>
+  </property>
+  <widget class="QDialogButtonBox" name="buttonBox" >
+   <property name="geometry" >
+    <rect>
+     <x>20</x>
+     <y>412</y>
+     <width>541</width>
+     <height>38</height>
+    </rect>
+   </property>
+   <property name="orientation" >
+    <enum>Qt::Horizontal</enum>
+   </property>
+   <property name="standardButtons" >
+    <set>QDialogButtonBox::Ok</set>
+   </property>
+   <property name="centerButtons" >
+    <bool>true</bool>
+   </property>
+  </widget>
+  <widget class="QTextEdit" name="textEdit" >
+   <property name="geometry" >
+    <rect>
+     <x>20</x>
+     <y>20</y>
+     <width>541</width>
+     <height>381</height>
+    </rect>
+   </property>
+   <property name="readOnly" >
+    <bool>true</bool>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>About</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>About</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
Index: testbed_ap/testbedap.ui
===================================================================
--- testbed_ap/testbedap.ui	(revision 0)
+++ testbed_ap/testbedap.ui	(revision 2)
@@ -0,0 +1,514 @@
+<ui version="4.0" >
+ <class>TestbedAp</class>
+ <widget class="QMainWindow" name="TestbedAp" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>841</width>
+    <height>450</height>
+   </rect>
+  </property>
+  <property name="sizePolicy" >
+   <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>841</width>
+    <height>450</height>
+   </size>
+  </property>
+  <property name="maximumSize" >
+   <size>
+    <width>841</width>
+    <height>450</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string>WiFi - Protected Setup Access Point Application</string>
+  </property>
+  <property name="autoFillBackground" >
+   <bool>true</bool>
+  </property>
+  <property name="animated" >
+   <bool>true</bool>
+  </property>
+  <widget class="QWidget" name="centralwidget" >
+   <widget class="QTabWidget" name="tabWidget" >
+    <property name="geometry" >
+     <rect>
+      <x>10</x>
+      <y>20</y>
+      <width>291</width>
+      <height>371</height>
+     </rect>
+    </property>
+    <property name="font" >
+     <font>
+      <pointsize>11</pointsize>
+     </font>
+    </property>
+    <property name="currentIndex" >
+     <number>0</number>
+    </property>
+    <widget class="QWidget" name="tabRegSta" >
+     <attribute name="title" >
+      <string>Register Station</string>
+     </attribute>
+     <widget class="QLabel" name="label_2" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>50</y>
+        <width>51</width>
+        <height>21</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Pin :</string>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbRegStaPbc" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>80</y>
+        <width>261</width>
+        <height>31</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Use &amp;PBC method</string>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbRegStaAuth" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>300</y>
+        <width>261</width>
+        <height>28</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Start &amp;Authentication</string>
+      </property>
+     </widget>
+     <widget class="QLabel" name="lblRegStaCmt" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>120</y>
+        <width>251</width>
+        <height>151</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Comment</string>
+      </property>
+      <property name="alignment" >
+       <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+      </property>
+     </widget>
+     <widget class="QLineEdit" name="lePin" >
+      <property name="geometry" >
+       <rect>
+        <x>70</x>
+        <y>48</y>
+        <width>191</width>
+        <height>29</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string/>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbWriteConfig" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>10</y>
+        <width>261</width>
+        <height>31</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>&amp;Write NFC Config Token</string>
+      </property>
+     </widget>
+     <widget class="QProgressBar" name="prgRegSta" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>265</y>
+        <width>261</width>
+        <height>23</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="maximum" >
+       <number>1200</number>
+      </property>
+      <property name="value" >
+       <number>0</number>
+      </property>
+      <property name="orientation" >
+       <enum>Qt::Horizontal</enum>
+      </property>
+      <property name="format" >
+       <string>Process</string>
+      </property>
+     </widget>
+    </widget>
+    <widget class="QWidget" name="tabGetConfig" >
+     <attribute name="title" >
+      <string>Get configuration</string>
+     </attribute>
+     <widget class="QLabel" name="label" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>50</y>
+        <width>51</width>
+        <height>21</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Pin :</string>
+      </property>
+     </widget>
+     <widget class="QLabel" name="lblPin" >
+      <property name="geometry" >
+       <rect>
+        <x>70</x>
+        <y>50</y>
+        <width>191</width>
+        <height>21</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>12345670</string>
+      </property>
+     </widget>
+     <widget class="QLabel" name="lblGetConfigCmt" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>120</y>
+        <width>251</width>
+        <height>151</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>12</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Comment</string>
+      </property>
+      <property name="alignment" >
+       <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbGetConfigAuth" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>300</y>
+        <width>261</width>
+        <height>28</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Start &amp;Authentication</string>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbGetConfigPbc" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>80</y>
+        <width>261</width>
+        <height>31</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>Use &amp;PBC method</string>
+      </property>
+     </widget>
+     <widget class="QPushButton" name="pbReadConfig" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>10</y>
+        <width>261</width>
+        <height>31</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="text" >
+       <string>&amp;Read NFC Config Token</string>
+      </property>
+     </widget>
+     <widget class="QProgressBar" name="prgGetConfig" >
+      <property name="geometry" >
+       <rect>
+        <x>10</x>
+        <y>265</y>
+        <width>261</width>
+        <height>23</height>
+       </rect>
+      </property>
+      <property name="font" >
+       <font>
+        <pointsize>9</pointsize>
+       </font>
+      </property>
+      <property name="maximum" >
+       <number>1200</number>
+      </property>
+      <property name="value" >
+       <number>0</number>
+      </property>
+      <property name="orientation" >
+       <enum>Qt::Horizontal</enum>
+      </property>
+      <property name="format" >
+       <string>Process</string>
+      </property>
+     </widget>
+    </widget>
+   </widget>
+   <widget class="QWidget" name="horizontalLayout" >
+    <property name="geometry" >
+     <rect>
+      <x>310</x>
+      <y>360</y>
+      <width>521</width>
+      <height>31</height>
+     </rect>
+    </property>
+    <layout class="QHBoxLayout" >
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <property name="leftMargin" >
+      <number>0</number>
+     </property>
+     <property name="topMargin" >
+      <number>0</number>
+     </property>
+     <property name="rightMargin" >
+      <number>0</number>
+     </property>
+     <property name="bottomMargin" >
+      <number>0</number>
+     </property>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbBack" >
+       <property name="sizePolicy" >
+        <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Back</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbNext" >
+       <property name="sizePolicy" >
+        <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Next</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pbCancel" >
+       <property name="sizePolicy" >
+        <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>&amp;Cancel</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </widget>
+   <widget class="QFrame" name="frame" >
+    <property name="geometry" >
+     <rect>
+      <x>310</x>
+      <y>20</y>
+      <width>521</width>
+      <height>331</height>
+     </rect>
+    </property>
+    <property name="frameShadow" >
+     <enum>QFrame::Raised</enum>
+    </property>
+   </widget>
+  </widget>
+  <widget class="QMenuBar" name="menubar" >
+   <property name="geometry" >
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>841</width>
+     <height>29</height>
+    </rect>
+   </property>
+   <widget class="QMenu" name="menu_Application" >
+    <property name="title" >
+     <string>&amp;Application</string>
+    </property>
+    <addaction name="actQuit" />
+   </widget>
+   <widget class="QMenu" name="menu_Help" >
+    <property name="title" >
+     <string>&amp;Help</string>
+    </property>
+    <addaction name="actAbout" />
+   </widget>
+   <addaction name="menu_Application" />
+   <addaction name="menu_Help" />
+  </widget>
+  <widget class="QStatusBar" name="statusbar" />
+  <action name="actQuit" >
+   <property name="text" >
+    <string>&amp;Quit</string>
+   </property>
+  </action>
+  <action name="actAbout" >
+   <property name="text" >
+    <string>A&amp;bout</string>
+   </property>
+  </action>
+ </widget>
+ <tabstops>
+  <tabstop>pbNext</tabstop>
+  <tabstop>pbCancel</tabstop>
+  <tabstop>pbBack</tabstop>
+  <tabstop>tabWidget</tabstop>
+  <tabstop>pbWriteConfig</tabstop>
+  <tabstop>lePin</tabstop>
+  <tabstop>pbRegStaPbc</tabstop>
+  <tabstop>pbRegStaAuth</tabstop>
+  <tabstop>pbReadConfig</tabstop>
+  <tabstop>pbGetConfigPbc</tabstop>
+  <tabstop>pbGetConfigAuth</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/testbedap.cpp
===================================================================
--- testbed_ap/testbedap.cpp	(revision 0)
+++ testbed_ap/testbedap.cpp	(revision 2)
@@ -0,0 +1,1009 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: testbedap.cpp
+//  Description: WiFi - Protected Setup Access Point graphical user interface source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "testbedap.h"
+#include "mainprocess.h"
+#include "pagetemplate.h"
+#include "setupinterface.h"
+#include "netconfig.h"
+#include "wepkey.h"
+#include "status.h"
+#include "debugwindow.h"
+#include "about.h"
+#include "os.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+QProcess *MainProcess::mainProcess = new QProcess();
+struct wpa_ctrl *MainProcess::monitor = 0;
+struct wpa_ctrl *MainProcess::ctrl = 0;
+char *MainProcess::iface = 0;
+QMutex *MainProcess::mtx = new QMutex();
+QSocketNotifier *MainProcess::msgNotifier = 0;
+MainProcess::MODE MainProcess::mode = MODE_REG_REGSTA;
+MainProcess::METHOD MainProcess::method = METHOD_NONE;
+
+char *MainProcess::wirelessInterface = 0;
+char *MainProcess::wirelessDriver = 0;
+char *MainProcess::wiredInterface = 0;
+char *MainProcess::bridgeInterface = 0;
+char *MainProcess::nfcInterface = 0;
+
+char *MainProcess::ipAddress = 0;
+char *MainProcess::netMask = 0;
+
+char MainProcess::ssid[32 + 1] = {0};
+ushort MainProcess::authType = 0;
+ushort MainProcess::encrType = 0;
+char MainProcess::netKey[64 + 1] = {0};
+ushort MainProcess::wepKeyIndex = 1;
+char MainProcess::wepKey[4][26 + 1] = {{0}, {0}, {0}, {0}};
+uchar MainProcess::wpsState = 0;
+
+MainProcess::WIRELESS_MODE MainProcess::wirelessMode = MainProcess::WIRELESS_MODE_11AGB;
+int MainProcess::channel = 0;
+int MainProcess::channelIndex = 0;
+char *MainProcess::channelList = 0;
+
+
+TestbedAp::TestbedAp(QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0*/)
+: QMainWindow(parent, f)
+{
+	setupUi(this);
+
+	connect(actQuit, SIGNAL(activated()), SLOT(close()));
+	connect(actAbout, SIGNAL(activated()), SLOT(about()));
+	connect(pbBack, SIGNAL(clicked()), SLOT(back()));
+	connect(pbNext, SIGNAL(clicked()), SLOT(next()));
+	connect(pbCancel, SIGNAL(clicked()), SLOT(cancel()));
+
+	setupInterface = new SetupInterface(this, frame);
+	setupInterface->close();
+	netConfig = new NetConfig(this, frame);
+	netConfig->close();
+	wepKey = new WepKey(this, frame);
+	wepKey->close();
+	status = new Status(this, frame);
+	status->close();
+
+	listPage.push_front(reinterpret_cast<PageTemplate *>(setupInterface));
+	listPage.front()->pre_next();
+	listPage.front()->show();
+
+	connect(tabWidget, SIGNAL(currentChanged(int)), SLOT(changeMode(int)));
+	tabWidget->setEnabled(false);
+	changeMode(0);
+
+	connect(pbWriteConfig, SIGNAL(clicked()), SLOT(writeConfigToken()));
+	connect(pbRegStaPbc, SIGNAL(clicked()), SLOT(startRegStaPbc()));
+	connect(pbRegStaAuth, SIGNAL(clicked()), SLOT(authRegSta()));
+	connect(pbReadConfig, SIGNAL(clicked()), SLOT(readConfigToken()));
+	connect(pbGetConfigPbc, SIGNAL(clicked()), SLOT(startGetConfigPbc()));
+	connect(pbGetConfigAuth, SIGNAL(clicked()), SLOT(authGetConfig()));
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), SLOT(increment()));
+
+	debugWindow = 0;
+	if (MainProcess::setDebugOut(this, SLOT(debugging()))) {
+		if (MainProcess::readConfigFile()) {
+			debugWindow = new DebugWindow();
+			QHBoxLayout *hl = new QHBoxLayout(debugWindow);
+			debugWindow->textEdit = new QTextEdit(debugWindow);
+			debugWindow->textEdit->setReadOnly(true);
+			hl->addWidget(debugWindow->textEdit);
+			debugWindow->setLayout(hl);
+			debugWindow->setGeometry(x(), y() + height() + 80,
+									 debugWindow->width(),
+									 debugWindow->height());
+			debugWindow->show();
+		}
+	}
+}
+
+TestbedAp::~TestbedAp()
+{
+	disconnect(actQuit);
+	disconnect(pbBack);
+	disconnect(pbNext);
+	disconnect(pbCancel);
+
+	delete setupInterface;
+	delete netConfig;
+	delete status;
+
+	delete timer;
+}
+
+void TestbedAp::back()
+{
+	PageTemplate *p;
+
+	do {
+		if(!listPage.front()->post_back())
+			break;
+		p = listPage.front();
+		p->close();
+		listPage.pop_front();
+
+		if (!listPage.front()->pre_back()) {
+			if (!p->pre_next()) {
+				QMessageBox::critical(this, windowTitle(), "Critical Error");
+				break;
+			}
+			listPage.push_front(p);
+			break;
+		}
+		listPage.front()->show();
+	} while (0);
+}
+
+void TestbedAp::next()
+{
+	PageTemplate *n = 0;
+
+	do {
+		if(!listPage.front()->post_next())
+			break;
+		listPage.front()->close();
+
+		if (setupInterface == listPage.front())
+			n = reinterpret_cast<PageTemplate *>(netConfig);
+		else if (netConfig == listPage.front()) {
+			if ((MainProcess::AUTH_OPEN == MainProcess::getAuthType()) &&
+				(MainProcess::ENCR_WEP == MainProcess::getEncrType()))
+				n = reinterpret_cast<PageTemplate *>(wepKey);
+			else
+				n = reinterpret_cast<PageTemplate *>(status);
+		} else if (wepKey == listPage.front()) {
+			n = reinterpret_cast<PageTemplate *>(status);
+		}
+
+		if (n) {
+			if (!n->pre_next())
+				break;
+			listPage.push_front(n);
+		} else if (!listPage.front()->pre_next()) {
+			QMessageBox::critical(this, windowTitle(), "Critical Error");
+			break;
+		}
+		listPage.front()->show();
+	} while (0);
+}
+
+void TestbedAp::cancel()
+{
+	listPage.front()->cancel();
+}
+
+void TestbedAp::close()
+{
+	MainProcess::terminate();
+
+	if (debugWindow) {
+		debugWindow->close();
+		delete debugWindow;
+		debugWindow = 0;
+	}
+
+	QMainWindow::close();
+}
+
+void TestbedAp::closeEvent(QCloseEvent *)
+{
+	close();
+}
+
+void TestbedAp::about()
+{
+	About license;
+	license.exec();
+}
+
+void TestbedAp::debugging()
+{
+	QString out;
+	do {
+		while (1) {
+			out = MainProcess::readDebugMsg();
+			if (!out.length())
+				break;
+			if (debugWindow) {
+				out.remove(QChar('\n'));
+				debugWindow->textEdit->append(out);
+			}
+		}
+	} while (0);
+}
+
+void TestbedAp::changeMode(int mode)
+{
+	switch (mode) {
+	case 0: // Register Station
+		lblRegStaCmt->setText("Register Station Mode\n");
+		lePin->setText("");
+		prgRegSta->setVisible(false);
+		MainProcess::setMode(MainProcess::MODE_REG_REGSTA);
+		(void)MainProcess::setRegMode(2);
+		break;
+	case 1: // Get configuration
+		lblGetConfigCmt->setText("Get configuration Mode\n");
+		lblPin->setText("");
+		prgGetConfig->setVisible(false);
+		MainProcess::setMode(MainProcess::MODE_ENR_GETCONF);
+		(void)MainProcess::setRegMode(0);
+		break;
+	}
+}
+
+void TestbedAp::writeConfigToken()
+{
+	bool ret = false;
+
+	do {
+		MainProcess::setMethod(MainProcess::METHOD_NFC);
+
+		if (!startAuthentication()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not start WPS authentication\n");
+			break;
+		}
+
+		if (!MainProcess::setRegMode(2)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set WPS registrar mode\n");
+			break;
+		}
+
+		if (!MainProcess::writeNfcConfig()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not write configuration on NFC token\n");
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret) {
+		(void)stopAuthentication();
+	}
+}
+
+void TestbedAp::startRegStaPbc()
+{
+	bool ret = false;
+
+	do {
+		MainProcess::setMethod(MainProcess::METHOD_PBC);
+
+		if (!pbRegStaAuth->text().compare("Start &Authentication")) {
+			if (!startAuthentication()) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not start WPS authentication\n");
+				break;
+			}
+
+			if (!MainProcess::setRegMode(2)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set WPS registrar mode\n");
+				break;
+			}
+		} else
+			prgRegSta->setValue(0);
+
+		if (!MainProcess::startPbc()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not start WPS authentication with PBC method\n");
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret) {
+		(void)stopAuthentication();
+	}
+}
+
+void TestbedAp::authRegSta()
+{
+	bool ret = false;
+
+	do {
+		if (!pbRegStaAuth->text().compare("Start &Authentication")) {
+			do {
+				MainProcess::setMethod(MainProcess::METHOD_PIN);
+
+				if (!MainProcess::setRegMode(2)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set WPS registrar mode\n");
+					break;
+				}
+
+				if (lePin->text().length()) {
+					if ((8 == lePin->text().length()) &&
+						!MainProcess::validatePIN(lePin->text().toAscii())) {
+						if (QMessageBox::No ==
+							QMessageBox::question(this, label->text(),
+									 "PIN has invalidate checksum.\n"
+									 "Do you really use this PIN?\n",
+									 QMessageBox::Yes|QMessageBox::No)) {
+							lePin->setFocus();
+							break;
+						}
+					}
+
+					if (!MainProcess::setWpsPassword(lePin->text().toAscii())) {
+						QMessageBox::warning(this, label->text(),
+											 "Could not set Password\n");
+						break;
+					}
+				} else {
+					if (!MainProcess::readNfcPassword()) {
+						QMessageBox::warning(this, label->text(),
+											 "Could not read Password on NFC token\n");
+						break;
+					}
+				}
+
+				if (!startAuthentication()) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not start WPS authentication\n");
+					break;
+				}
+
+				ret = true;
+			} while (0);
+
+			if (!ret)
+				stopAuthentication();
+		} else {
+			(void)MainProcess::clearWpsPassword();
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+			case MainProcess::METHOD_PIN:
+				(void)MainProcess::cancelScanNfcToken();
+				break;
+			case MainProcess::METHOD_PBC:
+				(void)MainProcess::stopPbc();
+				break;
+			default:
+				break;
+			}
+
+			stopAuthentication();
+		}
+	} while (0);
+}
+
+void TestbedAp::readConfigToken()
+{
+	bool ret = false;
+
+	do {
+		MainProcess::setMethod(MainProcess::METHOD_NFC);
+
+		if (!startAuthentication()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not start WPS authentication\n");
+			break;
+		}
+
+		if (!MainProcess::setRegMode(0)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set WPS registrar mode\n");
+			break;
+		}
+
+		if (!MainProcess::readNfcConfig()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not read configuration on NFC token\n");
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret) {
+		(void)stopAuthentication();
+	}
+}
+
+void TestbedAp::startGetConfigPbc()
+{
+	bool ret = false;
+
+	do {
+		MainProcess::setMethod(MainProcess::METHOD_PBC);
+
+		if (!pbRegStaAuth->text().compare("Start &Authentication")) {
+			if (!startAuthentication()) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not start WPS authentication\n");
+				break;
+			}
+
+			if (!MainProcess::setRegMode(0)) {
+				QMessageBox::warning(this, label->text(),
+									 "Could not set WPS registrar mode\n");
+				break;
+			}
+		} else
+			prgRegSta->setValue(0);
+
+		if (!MainProcess::startPbc()) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not start WPS authentication with PBC method\n");
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	if (!ret) {
+		(void)stopAuthentication();
+	}
+}
+
+void TestbedAp::authGetConfig()
+{
+	bool ret = false;
+	char pin[9];
+	do {
+		if (!pbGetConfigAuth->text().compare("Start &Authentication")) {
+			do {
+				MainProcess::setMethod(MainProcess::METHOD_PIN);
+
+				if (!MainProcess::setRegMode(0)) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set WPS registrar mode\n");
+					break;
+				}
+
+				MainProcess::generatePIN(pin);
+				lblPin->setText(pin);
+
+				if (!MainProcess::writeNfcPassword()) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not write Password on NFC token\n");
+					break;
+				}
+
+				if (!startAuthentication()) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not start WPS authentication\n");
+					break;
+				}
+				ret = true;
+			} while (0);
+
+			if (!ret)
+				stopAuthentication();
+		} else if (!pbGetConfigAuth->text().compare("use &Default PIN")) {
+			do {
+				(void)MainProcess::cancelScanNfcToken();
+
+				if (!MainProcess::setWpsPassword(lblPin->text().toAscii())) {
+					QMessageBox::warning(this, label->text(),
+										 "Could not set PIN\n");
+					break;
+				}
+				ret = true;
+			} while (0);
+
+			if (ret) {
+				lblGetConfigCmt->setText("Get configuration Mode\n"
+										 "Now authenticating with PIN\n");
+				pbGetConfigAuth->setText("Stop &Authentication");
+				prgGetConfig->setValue(0);
+			} else
+				stopAuthentication();
+		} else {
+			(void)MainProcess::clearWpsPassword();
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+			case MainProcess::METHOD_PIN:
+				(void)MainProcess::cancelScanNfcToken();
+				break;
+			case MainProcess::METHOD_PBC:
+				(void)MainProcess::stopPbc();
+				break;
+			default:
+				break;
+			}
+
+			stopAuthentication();
+		}
+	} while (0);
+}
+
+
+void TestbedAp::processCtrlRequest(char *buf, size_t len)
+{
+	QProgressBar *progressBar = 0;
+	QLabel *lblResult = 0;
+	QPushButton *pbStop = 0, *pbPbc = 0;
+	int priority;
+	char req[BUFSIZ];
+	char msg[BUFSIZ];
+	char *filename;
+
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_REG_REGSTA:
+		progressBar = prgRegSta;
+		lblResult = lblRegStaCmt;
+		pbStop = pbRegStaAuth;
+		pbPbc = pbRegStaPbc;
+		break;
+	case MainProcess::MODE_ENR_GETCONF:
+		progressBar = prgGetConfig;
+		lblResult = lblGetConfigCmt;
+		pbStop = pbGetConfigAuth;
+		pbPbc = pbGetConfigPbc;
+		break;
+	default:
+		timer->stop();
+		return;
+	}
+
+	if (MainProcess::getCtrlRequelst(buf, len, &priority, req, msg)) {
+		if (!os_strcmp(req, CTRL_REQ_EAP_WPS_FAIL) ||
+			(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_EAP_WPS_FAIL, os_strlen(CTRL_REQ_EAP_WPS_FAIL)))) {
+			timer->stop();
+			progressBar->setVisible(false);
+			lblPin->setText("");
+
+			(void)MainProcess::clearWpsPassword();
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+			case MainProcess::METHOD_PIN:
+				(void)MainProcess::cancelScanNfcToken();
+				break;
+			case MainProcess::METHOD_PBC:
+				(void)MainProcess::stopPbc();
+				break;
+			default:
+				break;
+			}
+
+			lblResult->setText(lblResult->text() + "\nFail\n");
+			pbStop->setEnabled(false);
+			pbPbc->setEnabled(false);
+			QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+		} else if (((!os_strcmp(req, CTRL_REQ_EAP_WPS_COMP) ||
+					(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_EAP_WPS_COMP, os_strlen(CTRL_REQ_EAP_WPS_COMP))))) ||
+				   (((!os_strcmp(req, CTRL_REQ_UPNP_COMP) ||
+				    (!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_UPNP_COMP, os_strlen(CTRL_REQ_UPNP_COMP))))))) {
+			timer->stop();
+			progressBar->setVisible(false);
+
+			lblPin->setText("");
+			pbStop->setEnabled(false);
+			pbPbc->setEnabled(false);
+
+			filename = os_strstr(msg, "[");
+			if (filename) {
+				filename = msg + os_strlen("[");
+				if (os_strchr(filename, ']'))
+					*(os_strchr(filename, ']')) = 0;
+
+				do {
+					if (!MainProcess::readConfigFile(filename)) {
+						lblResult->setText(lblResult->text() +
+										   "Could not load new configuration\n");
+						QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+						break;
+					}
+
+					if (!MainProcess::writeConfigFile()) {
+						lblResult->setText(lblResult->text() +
+										   "Could not save new configuration\n");
+						QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+						break;
+					}
+
+					pbStop->setEnabled(false);
+					lblResult->setText("Get configuration Mode\n\nComplete\n");
+					QTimer::singleShot(5000, this, SLOT(reset()));
+				} while (0);
+			} else {
+				lblResult->setText(lblResult->text() + "\nComplete\n");
+				QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+			}
+		} else if (!os_strcmp(req, CTRL_REQ_NFC_WRITE_TIMEOUT) ||
+			(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_NFC_WRITE_TIMEOUT, os_strlen(CTRL_REQ_NFC_WRITE_TIMEOUT)))) {
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_REGSTA:
+				MainProcess::writeNfcConfig();
+				break;
+			case MainProcess::MODE_ENR_GETCONF:
+				MainProcess::writeNfcPassword();
+				break;
+			}
+		} else if (!os_strcmp(req, CTRL_REQ_NFC_COMP_WRITE) ||
+			(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_NFC_COMP_WRITE, os_strlen(CTRL_REQ_NFC_COMP_WRITE)))) {
+
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_REGSTA:
+				timer->stop();
+				progressBar->setVisible(false);
+				pbStop->setEnabled(false);
+
+				filename = os_strstr(msg, "[Config Token:");
+				if (filename) {
+					filename = msg + os_strlen("[Config Token:");
+					if (os_strchr(filename, ']'))
+						*(os_strchr(filename, ']')) = 0;
+
+					do {
+						if (!MainProcess::readConfigFile(filename)) {
+							lblResult->setText(lblResult->text() +
+											   "Could not load new configuration\n");
+							QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+							break;
+						}
+
+						if (!MainProcess::writeConfigFile()) {
+							lblResult->setText(lblResult->text() +
+											   "Could not save new configuration\n");
+							QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+							break;
+						}
+
+						lblResult->setText("Register Station Mode\n\nComplete\nConfiguration generated\n");
+						QTimer::singleShot(5000, this, SLOT(reset()));
+					} while (0);
+				} else {
+					lblResult->setText(lblResult->text() + "\nComplete\n");
+					QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+				}
+				break;
+			case MainProcess::MODE_ENR_GETCONF:
+				lblResult->setText("Get configuration Mode\n"
+								   "Written PIN on NFC token\n"
+								   "Now authenticating with PIN.\n");
+				lblPin->setText("Written on token");
+				pbGetConfigAuth->setText("Stop &Authentication");
+				progressBar->setValue(0);
+				break;
+			}
+		} else if (!os_strcmp(req, CTRL_REQ_NFC_READ_TIMEOUT) ||
+			(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_NFC_READ_TIMEOUT, os_strlen(CTRL_REQ_NFC_READ_TIMEOUT)))) {
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_REGSTA:
+				MainProcess::readNfcPassword();
+				break;
+			case MainProcess::MODE_ENR_GETCONF:
+				MainProcess::readNfcConfig();
+				break;
+			}
+		} else if (!os_strcmp(req, CTRL_REQ_NFC_FAIL_READ) ||
+			(!os_strlen(req) && !os_strncmp(msg, CTRL_REQ_NFC_FAIL_READ, os_strlen(CTRL_REQ_NFC_FAIL_READ)))) {
+			timer->stop();
+			progressBar->setVisible(false);
+
+			(void)MainProcess::cancelScanNfcToken();
+
+			lblResult->setText(lblResult->text() + "\nFail\n"
+							   "Probably the token is invalid format.");
+			pbStop->setEnabled(false);
+			QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+		} else if (!os_strcmp(req, CTRL_REQ_NFC_COMP_READ) ||
+			(!os_strlen(req) && !strncmp(msg, CTRL_REQ_NFC_COMP_READ, os_strlen(CTRL_REQ_NFC_COMP_READ)))) {
+
+			switch (MainProcess::getMode()) {
+			case MainProcess::MODE_REG_REGSTA:
+				lblResult->setText("Register Station Mode\n"
+								   "Read PIN on NFC token\n"
+								   "Now authenticating with PIN.\n");
+				progressBar->setValue(0);
+				break;
+			case MainProcess::MODE_ENR_GETCONF:
+				timer->stop();
+				progressBar->setVisible(false);
+				filename = os_strstr(msg, "[Config Token:");
+				if (filename) {
+					filename = msg + os_strlen("[Config Token:");
+					if (strchr(filename, ']'))
+						*(strchr(filename, ']')) = 0;
+
+					do {
+						if (!MainProcess::readConfigFile(filename)) {
+							lblResult->setText(lblResult->text() +
+											   "Could not load new configuration\n");
+							QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+							break;
+						}
+
+						if (!MainProcess::writeConfigFile()) {
+							lblResult->setText(lblResult->text() +
+											   "Could not save new configuration\n");
+							QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+							break;
+						}
+
+						pbStop->setEnabled(false);
+						lblResult->setText("Get configuration Mode\n\nComplete\n");
+						QTimer::singleShot(5000, this, SLOT(reset()));
+					} while (0);
+				} else {
+					lblResult->setText(lblResult->text() +
+									   "Could not get new configuration\n");
+					QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+				}
+				break;
+			}
+		}
+	}
+}
+
+void TestbedAp::receiveMsgs()
+{
+	char msg[BUFSIZ];
+	size_t len;
+
+	while (MainProcess::ctrlPending()) {
+		len = sizeof(msg)  - 1;
+		if (MainProcess::receive(msg, &len))
+			processCtrlRequest(msg, len);
+	}
+}
+
+bool TestbedAp::startAuthentication()
+{
+	bool ret = false;
+
+	do {
+		pbBack->setEnabled(false);
+
+		if (!MainProcess::connectMonitor(this, SLOT(receiveMsgs()))) {
+			break;
+		}
+
+		switch (MainProcess::getMode()) {
+		case MainProcess::MODE_REG_REGSTA:
+			tabWidget->setTabEnabled(1, false);
+			pbWriteConfig->setEnabled(false);
+			lePin->setEnabled(false);
+
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+				pbRegStaPbc->setEnabled(false);
+				lblRegStaCmt->setText(lblRegStaCmt->text() +
+									  "Touch NFC token to write \n"
+									  "current configuration\n");
+				break;
+			case MainProcess::METHOD_PIN:
+				pbRegStaPbc->setEnabled(false);
+				if (lePin->text().length()) {
+					lblRegStaCmt->setText(lblRegStaCmt->text() +
+										  "Now authenticating with PIN\n");
+				} else {
+					lblRegStaCmt->setText(lblRegStaCmt->text() +
+										  "Touch NFC token to read \n"
+										  "PIN of target station\n");
+				}
+				break;
+			case MainProcess::METHOD_PBC:
+				pbRegStaPbc->setText("Restart using &PBC method");
+				lblRegStaCmt->setText(lblRegStaCmt->text() +
+									  "Now authenticating with PBC\n");
+				break;
+			default:
+				break;
+			}
+
+			pbRegStaAuth->setText("Stop &Authentication");
+
+			prgRegSta->setFormat("Processing");
+			prgRegSta->setValue(0);
+			prgRegSta->setVisible(true);
+			timer->start(100);
+			break;
+		case MainProcess::MODE_ENR_GETCONF:
+			tabWidget->setTabEnabled(0, false);
+			pbReadConfig->setEnabled(false);
+
+			switch (MainProcess::getMethod()) {
+			case MainProcess::METHOD_NFC:
+				pbGetConfigPbc->setEnabled(false);
+				lblGetConfigCmt->setText(lblGetConfigCmt->text() +
+										 "Touch NFC token to read \n"
+										 "new configuration\n");
+				pbGetConfigAuth->setText("Stop &Authentication");
+				break;
+			case MainProcess::METHOD_PIN:
+				pbGetConfigPbc->setEnabled(false);
+				lblGetConfigCmt->setText(lblGetConfigCmt->text() +
+										 "Touch NFC token to write PIN,\n"
+										 "or push [use Default PIN]\n"
+										 "to use Default PIN\n");
+				pbGetConfigAuth->setText("use &Default PIN");
+				break;
+			case MainProcess::METHOD_PBC:
+				pbGetConfigPbc->setText("Restart using &PBC method");
+				lblGetConfigCmt->setText(lblRegStaCmt->text() +
+										 "Now authenticating with PBC\n");
+				pbGetConfigAuth->setText("Stop &Authentication");
+				break;
+			default:
+				break;
+			}
+
+			prgGetConfig->setFormat("Processing");
+			prgGetConfig->setValue(0);
+			prgGetConfig->setVisible(true);
+			timer->start(100);
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+bool TestbedAp::stopAuthentication()
+{
+	bool ret = false;
+
+	do {
+		pbBack->setEnabled(true);
+
+		(void)MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		switch (MainProcess::getMode()) {
+		case MainProcess::MODE_REG_REGSTA:
+			tabWidget->setTabEnabled(1, true);
+			pbWriteConfig->setEnabled(true);
+			lePin->setEnabled(true);
+			prgRegSta->setVisible(false);
+			pbRegStaPbc->setText("using &PBC method");
+			pbRegStaPbc->setEnabled(true);
+			lePin->setText("");
+
+			lblRegStaCmt->setText("Register Station Mode\n");
+			pbRegStaAuth->setText("Start &Authentication");
+			pbRegStaAuth->setEnabled(true);
+			break;
+		case MainProcess::MODE_ENR_GETCONF:
+			tabWidget->setTabEnabled(0, true);
+			pbReadConfig->setEnabled(true);
+			prgGetConfig->setVisible(false);
+			pbGetConfigPbc->setText("using &PBC method");
+			pbGetConfigPbc->setEnabled(true);
+			lblPin->setText("");
+
+			lblGetConfigCmt->setText("Get configuration Mode\n");
+			pbGetConfigAuth->setText("Start &Authentication");
+			pbGetConfigAuth->setEnabled(true);
+			break;
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void TestbedAp::increment()
+{
+	QProgressBar *progressBar = 0;
+	QLabel *lblResult = 0;
+	QPushButton *pbStop = 0, *pbPbc = 0;
+
+	switch (MainProcess::getMode()) {
+	case MainProcess::MODE_REG_REGSTA:
+		progressBar = prgRegSta;
+		lblResult = lblRegStaCmt;
+		pbStop = pbRegStaAuth;
+		pbPbc = pbRegStaPbc;
+		break;
+	case MainProcess::MODE_ENR_GETCONF:
+		progressBar = prgGetConfig;
+		lblResult = lblGetConfigCmt;
+		pbStop = pbGetConfigAuth;
+		pbPbc = pbGetConfigPbc;
+		break;
+	default:
+		timer->stop();
+		return;
+	}
+
+	if (progressBar->value() < progressBar->maximum())
+		progressBar->setValue(progressBar->value() + 1);
+	else {
+		timer->stop();
+
+		(void)MainProcess::clearWpsPassword();
+		switch (MainProcess::getMethod()) {
+		case MainProcess::METHOD_NFC:
+		case MainProcess::METHOD_PIN:
+			(void)MainProcess::cancelScanNfcToken();
+			break;
+		case MainProcess::METHOD_PBC:
+			(void)MainProcess::stopPbc();
+			break;
+		default:
+			break;
+		}
+
+		progressBar->setFormat("Timeout");
+		progressBar->update();
+
+		pbPbc->setEnabled(false);
+		pbStop->setEnabled(false);
+		lblResult->setText(lblResult->text() + "\nTimeout\n");
+		QTimer::singleShot(5000, this, SLOT(stopAuthentication()));
+	}
+}
+
+void TestbedAp::reset()
+{
+	bool ret = false;
+
+	do {
+		status->post_next();
+
+		(void)MainProcess::disconnectMonitor(this, SLOT(receiveMsgs()));
+
+		if (!MainProcess::reload()) {
+			QMessageBox::critical(this, windowTitle(),
+								  "Could not restart Access Point");
+			break;
+		}
+
+		MainProcess::closeCtrl();
+
+		lblRegStaCmt->setText("Restarting ...");
+		lblGetConfigCmt->setText("Restarting ...");
+
+		ret = true;
+	} while (0);
+
+	if (ret)
+		QTimer::singleShot(5000, this, SLOT(restart()));
+	else
+		close();
+}
+
+void TestbedAp::restart()
+{
+	stopAuthentication();
+	tabWidget->setCurrentIndex(0);
+	status->pre_next();
+}
+
Index: testbed_ap/netconfig.cpp
===================================================================
--- testbed_ap/netconfig.cpp	(revision 0)
+++ testbed_ap/netconfig.cpp	(revision 2)
@@ -0,0 +1,454 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: netconfig.cpp
+//  Description: Network configuration source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "netconfig.h"
+#include "mainprocess.h"
+#include "testbedap.h"
+#include "os.h"
+
+#include <QMessageBox>
+#include <QFile>
+
+
+NetConfig::NetConfig(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedAp *>(wizard);
+	setupUi(this);
+
+	cmbAuth->addItem("Open");
+	cmbAuth->addItem("WPA-PSK");
+	cmbAuth->addItem("WPA2-PSK");
+
+	connect(cmbAuth, SIGNAL(currentIndexChanged(int)), SLOT(selectAuth(int)));
+	connect(pbGenSsid, SIGNAL(clicked()), SLOT(generateSsid()));
+	connect(pbGenNetKey, SIGNAL(clicked()), SLOT(generateNetKey()));
+
+	connect(cb11a, SIGNAL(clicked()), SLOT(changeWirelessMode()));
+	connect(cb11gb, SIGNAL(clicked()), SLOT(changeWirelessMode()));
+
+	cmbAuth->setCurrentIndex(1);
+
+	cmbConfFlag->addItem("Not configured");
+	cmbConfFlag->addItem("Configured");
+	cmbConfFlag->setCurrentIndex(0);
+
+	srand(time(0));
+}
+
+NetConfig::~NetConfig()
+{
+}
+
+bool NetConfig::pre_back()
+{
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	wiz->pbNext->setFocus();
+	return true;
+}
+
+bool NetConfig::pre_next()
+{
+	wiz->pbBack->setEnabled(true);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+
+	leSsid->setText(MainProcess::getSsid());
+	switch (MainProcess::getAuthType()) {
+	case MainProcess::AUTH_OPEN:
+		cmbAuth->setCurrentIndex(0);
+		break;
+	case MainProcess::AUTH_WPA:
+		cmbAuth->setCurrentIndex(1);
+		break;
+	case MainProcess::AUTH_WPA2:
+		cmbAuth->setCurrentIndex(2);
+		break;
+	}
+
+	if (MainProcess::AUTH_OPEN == MainProcess::getAuthType()) {
+		switch (MainProcess::getEncrType()) {
+		case MainProcess::ENCR_NONE:
+			cmbEncr->setCurrentIndex(0);
+			break;
+		case MainProcess::ENCR_WEP:
+			cmbEncr->setCurrentIndex(1);
+			break;
+		}
+	} else {
+		switch (MainProcess::getEncrType()) {
+		case MainProcess::ENCR_TKIP:
+			cmbEncr->setCurrentIndex(0);
+			break;
+		case MainProcess::ENCR_CCMP:
+			cmbEncr->setCurrentIndex(1);
+			break;
+		}
+	}
+
+	leNetKey->setText(MainProcess::getNetKey());
+
+	switch (MainProcess::getWpsState()) {
+	case MainProcess::WPS_STATE_NOTCONFIGURED:
+		cmbConfFlag->setCurrentIndex(0);
+		break;
+	case MainProcess::WPS_STATE_CONFIGURED:
+		cmbConfFlag->setCurrentIndex(1);
+		break;
+	}
+
+	switch (MainProcess::getWirelessMode()) {
+	case MainProcess::WIRELESS_MODE_11AGB:
+		cb11a->setChecked(true);
+		cb11gb->setChecked(true);
+		break;
+	case MainProcess::WIRELESS_MODE_11A:
+		cb11a->setChecked(true);
+		cb11gb->setChecked(false);
+		break;
+	case MainProcess::WIRELESS_MODE_11GB:
+		cb11a->setChecked(false);
+		cb11gb->setChecked(true);
+		break;
+	}
+
+	changeWirelessMode();
+	cmbChannelList->setCurrentIndex(MainProcess::getChannelIndex());
+
+	wiz->pbNext->setFocus();
+	return true;
+}
+
+bool NetConfig::post_next()
+{
+	bool ret = false;
+
+	do {
+		if (!checkInputs()) {
+			QMessageBox::critical(this, label->text(), "Input error");
+			break;
+		}
+
+		MainProcess::setSsid(leSsid->text().toAscii());
+		switch (cmbAuth->currentIndex()) {
+		case 0:
+			MainProcess::setAuthType(MainProcess::AUTH_OPEN);
+			break;
+		case 1:
+			MainProcess::setAuthType(MainProcess::AUTH_WPA);
+			break;
+		case 2:
+			MainProcess::setAuthType(MainProcess::AUTH_WPA2);
+			break;
+		default:
+			QMessageBox::critical(this, label->text(), "Unknown Authentication Type");
+			cmbAuth->setFocus();
+			return false;
+		}
+
+		if (0 == cmbAuth->currentIndex()) {
+			MainProcess::setEncrType(MainProcess::ENCR_NONE);
+			switch (cmbEncr->currentIndex()) {
+			case 0:
+				MainProcess::setEncrType(MainProcess::ENCR_NONE);
+				break;
+			case 1:
+				MainProcess::setEncrType(MainProcess::ENCR_WEP);
+				break;
+			default:
+				QMessageBox::critical(this, label->text(), "Unknown Encryption Type");
+				cmbEncr->setFocus();
+				return false;
+			}
+			MainProcess::setNetKey(0);
+		} else {
+			switch (cmbEncr->currentIndex()) {
+			case 0:
+				MainProcess::setEncrType(MainProcess::ENCR_TKIP);
+				break;
+			case 1:
+				MainProcess::setEncrType(MainProcess::ENCR_CCMP);
+				break;
+			default:
+				QMessageBox::critical(this, label->text(), "Unknown Encryption Type");
+				cmbEncr->setFocus();
+				return false;
+			}
+			MainProcess::setNetKey(leNetKey->text().toAscii());
+		}
+
+		switch (cmbConfFlag->currentIndex()) {
+		case 0:
+			MainProcess::setWpsState(MainProcess::WPS_STATE_NOTCONFIGURED);
+			break;
+		case 1:
+			MainProcess::setWpsState(MainProcess::WPS_STATE_CONFIGURED);
+			break;
+		default:
+			QMessageBox::critical(this, label->text(), "Unknown Configuration Flag");
+			cmbConfFlag->setFocus();
+			return false;
+		}
+
+		if (!setChannel()) {
+			QMessageBox::critical(this, label->text(), "Could not set channel");
+			cmbChannelList->setFocus();
+			return false;
+		}
+
+		if (MainProcess::ENCR_WEP != MainProcess::getEncrType()) {
+			if (!MainProcess::writeConfigFile()) {
+				QMessageBox::critical(this, label->text(), "Cannot write main process configuration file");
+				break;
+			}
+
+			if (!MainProcess::start()) {
+				QMessageBox::critical(this, label->text(), "Cannot start main process");
+				break;
+			}
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void NetConfig::cancel()
+{
+	MainProcess::terminate();
+	wiz->close();
+}
+
+void NetConfig::selectAuth(int selected)
+{
+	cmbEncr->clear();
+	switch (selected) {
+	case 0:
+		cmbEncr->addItem("None");
+		cmbEncr->addItem("WEP");
+		leNetKey->setEnabled(false);
+		pbGenNetKey->setEnabled(false);
+		break;
+	case 1:
+	case 2:
+		cmbEncr->addItem("TKIP");
+		cmbEncr->addItem("CCMP");
+		leNetKey->setEnabled(true);
+		cmbEncr->setCurrentIndex(selected - 1);
+		pbGenNetKey->setEnabled(true);
+		break;
+	default:
+		break;
+	}
+}
+
+void NetConfig::generateSsid()
+{
+	char ssid[32 + 1];
+
+	for (int i = 0; i < 32; i++) {
+		ssid[i] = btoa(rand() % 16);
+	}
+	ssid[32] = 0;
+	leSsid->clear();
+	leSsid->setText(ssid);
+}
+
+void NetConfig::generateNetKey()
+{
+	char netKey[64 + 1];
+
+	for (int i = 0; i < 64; i++) {
+		netKey[i] = btoa(rand() % 16);
+	}
+	netKey[64] = 0;
+	leNetKey->clear();
+	leNetKey->setText(netKey);
+}
+
+char NetConfig::btoa(int b, bool capital /* = true */ )
+{
+	if ((0 <= b) && (9 >= b)) {
+		return b + '0';
+	} else if ((0xA <= b) && (0xF >= b)) {
+		return (b - 0xA) + (capital?'A':'a');
+	} else {
+		return '0';
+	}
+}
+
+bool NetConfig::checkInputs()
+{
+	bool ret = false;
+	int i;
+
+	do {
+		if (!leSsid->text().length() || (32 < leSsid->text().length())) {
+			leSsid->setFocus();
+			break;
+		}
+
+		if (0 != cmbAuth->currentIndex()) {
+			/* WPA-PSK / WPA2-PSK */
+			if (64 == leNetKey->text().length()) {
+				for (i = 0; i < 64; i++) {
+					if (!isxdigit(*(const char *)(leNetKey->text().data() + i)))
+						break;
+				}
+				if (64 != i) {
+					leNetKey->setFocus();
+					break;
+				}
+			} else if (8 > leNetKey->text().length()) {
+				leNetKey->setFocus();
+				break;
+			}
+		}
+
+		if (!cb11a->isChecked() && !cb11gb->isChecked()) {
+			cb11a->setFocus();
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void NetConfig::changeWirelessMode()
+{
+	MainProcess::WIRELESS_MODE mode;
+	if (cb11a->isChecked() && cb11gb->isChecked()) {
+		mode = MainProcess::WIRELESS_MODE_11AGB;
+		cb11a->setEnabled(true);
+		cb11gb->setEnabled(true);
+	} else if (cb11a->isChecked()) {
+		mode = MainProcess::WIRELESS_MODE_11A;
+		cb11a->setEnabled(false);
+		cb11gb->setEnabled(true);
+	} else if (cb11gb->isChecked()) {
+		mode = MainProcess::WIRELESS_MODE_11GB;
+		cb11a->setEnabled(true);
+		cb11gb->setEnabled(false);
+	} else
+		return;
+
+	if (setChannelList(MainProcess::getChannelList(mode))) {
+		cmbChannelList->setCurrentIndex(0);
+	}
+}
+
+bool NetConfig::setChannelList(const char *list)
+{
+	bool ret = false;
+	QStringList channelList;
+
+	do {
+		cmbChannelList->clear();
+
+		if (!list) {
+			QMessageBox::warning(this, label->text(), "Could not get channel list");
+			break;
+		}
+
+		channelList = QString(list).split(QChar('\n'));
+		cmbChannelList->addItems(channelList);
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+bool NetConfig::setChannel()
+{
+#define CONFIG_FILE "./testbed_ap.conf"
+	bool ret = false;
+	MainProcess::WIRELESS_MODE mode;
+	QStringList cols;
+	int channel;
+	QFile *conf = new QFile(CONFIG_FILE);
+	char line[BUFSIZ];
+	int i;
+
+	do {
+		if (cb11a->isChecked() && cb11gb->isChecked())
+			mode = MainProcess::WIRELESS_MODE_11AGB;
+		else if (cb11a->isChecked())
+			mode = MainProcess::WIRELESS_MODE_11A;
+		else if (cb11gb->isChecked())
+			mode = MainProcess::WIRELESS_MODE_11GB;
+		else
+			break;
+
+		cols = cmbChannelList->currentText().split(QRegExp("\\s+"));
+		channel = cols[1].toInt();
+		if (!channel)
+			break;
+
+		if (!MainProcess::setChannel(mode, channel))
+			break;
+
+		if (!conf || !conf->open(QIODevice::ReadWrite))
+			break;
+
+		for (i = 0; i <= 5; i++)
+			conf->readLine(line, sizeof(line));
+		os_snprintf(line, sizeof(line), "%d,%d\n",
+					mode, cmbChannelList->currentIndex());
+		conf->write(line);
+		conf->close();
+
+		MainProcess::setWirelessMode(mode);
+		MainProcess::setChannelIndex(cmbChannelList->currentIndex());
+
+		ret = true;
+	} while (0);
+
+	if (conf) {
+		if (conf->isOpen())
+			conf->close();
+		delete conf;
+		conf = 0;
+	}
+
+	return ret;
+#undef CONFIG_FILE
+}
+
Index: testbed_ap/pagetemplate.h
===================================================================
--- testbed_ap/pagetemplate.h	(revision 0)
+++ testbed_ap/pagetemplate.h	(revision 2)
@@ -0,0 +1,60 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: pagetemplate.h
+//  Description: template of pages header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef PAGETEMPLATE_H
+#define PAGETEMPLATE_H
+
+#include <QWidget>
+
+
+class PageTemplate: public QWidget
+{
+Q_OBJECT
+public:
+	PageTemplate(QWidget *parent = 0, Qt::WindowFlags f = 0) : QWidget(parent, f) {};
+	~PageTemplate() {};
+
+public:
+	virtual bool pre_back() { return true; };
+	virtual bool pre_next() { return true; };
+	virtual bool pre_cancel() { return true; };
+
+	virtual bool post_back() { return true; };
+	virtual bool post_next() { return true; };
+	virtual bool post_cancel() { return true; };
+
+	virtual void cancel() { return; };
+};
+
+#endif /* PAGETEMPLATE_H */
Index: testbed_ap/about.h
===================================================================
--- testbed_ap/about.h	(revision 0)
+++ testbed_ap/about.h	(revision 2)
@@ -0,0 +1,87 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: about.h
+//  Description: Display license header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef ABOUT_H
+#define ABOUT_H
+
+#include "ui_about.h"
+
+#include <QDialog>
+
+#define LICENSE \
+" Copyright(c) 2007, Sony Corporation. All rights reserved.\n" \
+"\n" \
+" Description: WiFi - Protected Setup Access Point Reference Application\n" \
+"\n" \
+"   Redistribution and use in source and binary forms, with or without\n" \
+"   modification, are permitted provided that the following conditions\n" \
+"   are met:\n" \
+"\n" \
+"     * Redistributions of source code must retain the above copyright\n" \
+"       notice, this list of conditions and the following disclaimer.\n" \
+"     * Redistributions in binary form must reproduce the above copyright\n" \
+"       notice, this list of conditions and the following disclaimer in\n" \
+"       the documentation and/or other materials provided with the\n" \
+"       distribution.\n" \
+"     * Neither the name of Sony Corporation nor the names of its\n" \
+"       contributors may be used to endorse or promote products derived\n" \
+"       from this software without specific prior written permission.\n" \
+"\n" \
+"   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n" \
+"   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n" \
+"   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n" \
+"   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n" \
+"   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n" \
+"   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n" \
+"   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n" \
+"   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n" \
+"   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n" \
+"   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n" \
+"   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n" \
+"\n"
+
+
+class About:
+public QDialog, public Ui::About
+{
+Q_OBJECT
+public:
+	About(QWidget *parent = 0, Qt::WindowFlags f = 0):QDialog(parent, f) {
+		setupUi(this);
+		textEdit->setText(LICENSE);
+	};
+	~About() {};
+};
+
+#endif // ABOUT_H
Index: testbed_ap/hostapd.eap_user
===================================================================
--- testbed_ap/hostapd.eap_user	(revision 0)
+++ testbed_ap/hostapd.eap_user	(revision 2)
@@ -0,0 +1,47 @@
+# hostapd user database for integrated EAP authenticator
+
+# Each line must contain an identity, EAP method(s), and an optional password
+# separated with whitespace (space or tab). The identity and password must be
+# double quoted ("user"). Password can alternatively be stored as
+# NtPasswordHash (16-byte MD4 hash of the unicode presentation of the password
+# in unicode) if it is used for MSCHAP or MSCHAPv2 authentication. This means
+# that the plaintext password does not need to be included in the user file.
+# Password hash is stored as hash:<16-octets of hex data> without quotation
+# marks.
+
+# [2] flag in the end of the line can be used to mark users for tunneled phase
+# 2 authentication (e.g., within EAP-PEAP). In these cases, an anonymous
+# identity can be used in the unencrypted phase 1 and the real user identity
+# is transmitted only within the encrypted tunnel in phase 2. If non-anonymous
+# access is needed, two user entries is needed, one for phase 1 and another
+# with the same username for phase 2.
+#
+# EAP-TLS, EAP-PEAP, EAP-TTLS, EAP-SIM, and EAP-AKA do not use password option.
+# EAP-MD5, EAP-MSCHAPV2, EAP-GTC, EAP-PAX, EAP-PSK, and EAP-SAKE require a
+# password.
+# EAP-PEAP and EAP-TTLS require Phase 2 configuration.
+#
+# * can be used as a wildcard to match any user identity. The main purposes for
+# this are to set anonymous phase 1 identity for EAP-PEAP and EAP-TTLS and to
+# avoid having to configure every certificate for EAP-TLS authentication. The
+# first matching entry is selected, so * should be used as the last phase 1
+# user entry.
+#
+# "prefix"* can be used to match the given prefix and anything after this. The
+# main purpose for this is to be able to avoid EAP method negotiation when the
+# method is using known prefix in identities (e.g., EAP-SIM and EAP-AKA). This
+# is only allowed for phase 1 identities.
+#
+# Multiple methods can be configured to make the authenticator try them one by
+# one until the peer accepts one. The method names are separated with a
+# comma (,).
+#
+# [ver=0] and [ver=1] flags after EAP type PEAP can be used to force PEAP
+# version based on the Phase 1 identity. Without this flag, the EAP
+# authenticator advertises the highest supported version and select the version
+# based on the first PEAP packet from the supplicant.
+
+# Phase 1 users
+"WFA-SimpleConfig-Registrar-1-0"	WPS
+"WFA-SimpleConfig-Enrollee-1-0"		WPS
+
Index: testbed_ap/main.cpp
===================================================================
--- testbed_ap/main.cpp	(revision 0)
+++ testbed_ap/main.cpp	(revision 2)
@@ -0,0 +1,74 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: main.cpp
+//  Description: WiFi - Protected Setup Access Point main source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifdef CONFIG_NATIVE_WINDOWS
+#include <winsock.h>
+#endif /* CONFIG_NATIVE_WINDOWS */
+#include <QApplication>
+#include "testbedap.h"
+
+int main(int argc, char *argv[])
+{
+	QApplication app(argc, argv);
+	TestbedAp *w;
+	int ret;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	WSADATA wsaData;
+	if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
+		printf("Could not find a usable WinSock.dll\n");
+		return -1;
+	}
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+	w = new TestbedAp;
+	if (NULL == w) {
+#ifdef CONFIG_NATIVE_WINDOWS
+		WSACleanup();
+#endif /* CONFIG_NATIVE_WINDOWS */
+		return -1;
+	}
+	w->show();
+	app.connect(&app, SIGNAL(lastWindowClosed()), &app, SLOT(quit()));
+	ret = app.exec();
+
+	delete w;
+	w = 0;
+
+#ifdef CONFIG_NATIVE_WINDOWS
+	WSACleanup();
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+	return ret;
+}
Index: testbed_ap/setupinterface.h
===================================================================
--- testbed_ap/setupinterface.h	(revision 0)
+++ testbed_ap/setupinterface.h	(revision 2)
@@ -0,0 +1,77 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: setupinterface.h
+//  Description: setup interface header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef SETUPINTERFACE_H
+#define SETUPINTERFACE_H
+
+#include "ui_setupinterface.h"
+#include "pagetemplate.h"
+
+#include <QRegExpValidator>
+
+class TestbedAp;
+
+
+class SetupInterface:
+public PageTemplate, public Ui::SetupInterface
+{
+Q_OBJECT
+public:
+	SetupInterface(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~SetupInterface();
+
+	const char *getWirelessInterface();
+	const char *getWiredInterface();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	bool post_next();
+	void cancel();
+
+private:
+	TestbedAp *wiz;
+
+	QValidator *validator1;
+	QValidator *validator2;
+	bool checkInputs();
+
+	bool end();
+
+private slots:
+	void enabledDhcp();
+
+};
+
+#endif // SETUPINTERFACE_H
Index: testbed_ap/testbed_ap.pro
===================================================================
--- testbed_ap/testbed_ap.pro	(revision 0)
+++ testbed_ap/testbed_ap.pro	(revision 2)
@@ -0,0 +1,60 @@
+TEMPLATE	= app
+LANGUAGE	= C++
+
+CONFIG	+= qt warn_on release
+
+DEFINES += CONFIG_CTRL_IFACE WPS_OPT_UPNP WPS_OPT_NFC
+
+win32 {
+  LIBS += -lws2_32
+  DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE USE_WINIFLIST
+  SOURCES += ../win_if_list.c
+} else:win32-g++ {
+  # cross compilation to win32
+  LIBS += -lws2_32
+  DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE USE_WINIFLIST
+  SOURCES += ../win_if_list.c
+} else {
+  DEFINES += CONFIG_CTRL_IFACE_UNIX
+}
+
+INCLUDEPATH	+= . .. ../../hostapd
+
+HEADERS	+= \
+	testbedap.h \
+	about.h \
+	mainprocess.h \
+	pagetemplate.h \
+	setupinterface.h \
+	netconfig.h \
+	wepkey.h \
+	status.h \
+	debugwindow.h \
+	wpamsg.h \
+
+SOURCES	+= \
+	main.cpp \
+	testbedap.cpp \
+	mainprocess.cpp \
+	setupinterface.cpp \
+	netconfig.cpp \
+	wepkey.cpp \
+	status.cpp \
+	../wpa_ctrl.c \
+
+FORMS	= \
+	testbedap.ui \
+	about.ui \
+	setupinterface.ui \
+	netconfig.ui \
+	wepkey.ui \
+	status.ui \
+	debugwindow.ui \
+
+
+unix {
+  UI_DIR = .ui
+  MOC_DIR = .moc
+  OBJECTS_DIR = .obj
+}
+
Index: testbed_ap/status.h
===================================================================
--- testbed_ap/status.h	(revision 0)
+++ testbed_ap/status.h	(revision 2)
@@ -0,0 +1,70 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: status.h
+//  Description: Display status header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef STATUS_H
+#define STATUS_H
+
+#include "ui_status.h"
+#include "pagetemplate.h"
+
+class TestbedAp;
+class QTimer;
+
+
+class Status:
+public PageTemplate, public Ui::Status
+{
+Q_OBJECT
+public:
+	Status(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~Status();
+
+public:
+	bool pre_next();
+	void cancel();
+
+	bool post_back();
+	bool post_next();
+
+private:
+
+private slots:
+	void update();
+
+private:
+	TestbedAp *wiz;
+	QTimer *timer;
+};
+
+#endif // STATUS_H
Index: testbed_ap/mainprocess.h
===================================================================
--- testbed_ap/mainprocess.h	(revision 0)
+++ testbed_ap/mainprocess.h	(revision 2)
@@ -0,0 +1,232 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: mainprocess.h
+//  Description: main process control header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef MAINPROCESS_H
+#define MAINPROCESS_H
+
+#include <QProcess>
+#include <QMutex>
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+#include <QSocketNotifier>
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+
+struct wpa_ctrl;
+
+#define CTRL_REQ_EAP_WPS_COMP		"EAP_WPS_COMP"
+#define CTRL_REQ_EAP_WPS_FAIL		"EAP_WPS_FAIL"
+#define CTRL_REQ_EAP_WPS_PASSWORD	"EAP_WPS_PASSWORD"
+
+#define CTRL_REQ_UPNP_COMP			"UPNP_COMP"
+#define CTRL_REQ_UPNP_FAIL			"UPNP_FAIL"
+#define CTRL_REQ_UPNP_PASSWORD		"UPNP_PASSWORD"
+
+#define CTRL_REQ_NFC_READ_TIMEOUT	"NFC_READ_TIMEOUT"
+#define CTRL_REQ_NFC_WRITE_TIMEOUT	"NFC_WRITE_TIMEOUT"
+#define CTRL_REQ_NFC_FAIL_READ		"NFC_FAIL_READ"
+#define CTRL_REQ_NFC_COMP_READ		"NFC_COMP_READ"
+#define CTRL_REQ_NFC_COMP_WRITE		"NFC_COMP_WRITE"
+#define CTRL_REQ_NFC_ADD_NEW_AP		"NFC_ADD_NEW_AP"
+
+
+class MainProcess
+{
+public:
+	MainProcess();
+	~MainProcess();
+
+	enum MODE {
+		MODE_ENR_GETCONF = 0,
+		MODE_REG_REGSTA
+	};
+
+	enum METHOD {
+		METHOD_NONE = 0,
+		METHOD_NFC,
+		METHOD_PIN,
+		METHOD_PBC
+	};
+
+	enum AUTHENTICATION {
+		AUTH_OPEN = 0,
+		AUTH_WPA,
+		AUTH_WPA2,
+	};
+
+	enum ENCRIPTION {
+		ENCR_NONE = 0,
+		ENCR_WEP,
+		ENCR_TKIP,
+		ENCR_CCMP
+	};
+
+	enum WPS_STATE {
+		WPS_STATE_NOTCONFIGURED = 1,
+		WPS_STATE_CONFIGURED
+	};
+
+	enum WIRELESS_MODE {
+		WIRELESS_MODE_11AGB = 0,
+		WIRELESS_MODE_11A,
+		WIRELESS_MODE_11GB
+	};
+
+	static bool start();
+	static void terminate();
+
+private:
+	static int ctrlRequest(char *cmd, char *res, size_t *len);
+
+public:
+	static bool readConfigFile(char *filename = 0);
+	static bool writeConfigFile();
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	static bool connectMonitor(QObject *receiver, const char *method);
+	static bool disconnectMonitor(QObject *receiver, const char *method);
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	static bool ctrlPending();
+	static bool receive(char *msg, size_t *len);
+	static bool getCtrlRequelst(char *buf, size_t len, int *priority, char *req, char *msg);
+	static void closeCtrl();
+
+	static bool reload();
+	static bool getStatus(char *result, size_t *len);
+
+	static bool setRegMode(int regmode);
+	static bool setWpsPassword(const char *pwd);
+	static bool clearWpsPassword();
+	static bool ctrlWpsState(uchar state);
+
+	static bool writeNfcConfig();
+	static bool readNfcConfig();
+	static bool writeNfcPassword();
+	static bool readNfcPassword();
+	static bool cancelScanNfcToken();
+
+	static void generatePIN(char pwd[9]);
+	static bool validatePIN(const char pwd[9]);
+
+	static bool startPbc();
+	static bool stopPbc();
+
+	static bool setDebugOut(QObject *receiver, const char *method);
+	static QString readDebugMsg();
+
+	static void setMode(MODE _mode) { mode = _mode; };
+	static MODE getMode() { return mode; };
+
+	static void setMethod(METHOD  _method) { method = _method; };
+	static METHOD getMethod() { return method; };
+
+	static void setWirelessInterface(const char *ifname);
+	static char *getWirelessInterface();
+	static void setWirelessDriver(const char *driver);
+	static char *setWirelessDriver();
+	static void setNfcInterface(const char *ifname);
+	static char *getNfcInterface();
+	static void setWiredInterface(const char *ifname);
+	static char *getWiredInterface();
+	static void setBridgeInterface(const char *ifname);
+	static char *getBridgeInterface();
+	static void setIpAddress(const char *ipAddr);
+	static char *getIpAddress();
+	static void setNetMask(const char *netMask);
+	static char *getNetMask();
+	static void setSsid(const char *_ssid);
+	static const char *getSsid();
+	static void setAuthType(ushort auth);
+	static ushort getAuthType();
+	static void setEncrType(ushort encr);
+	static ushort getEncrType();
+	static void setNetKey(const char *key);
+	static const char *getNetKey();
+	static void setWepKeyIndex(ushort index);
+	static ushort getWepKeyIndex();
+	static void setWepKey(ushort key, const char *key);
+	static const char *getWepKey(ushort index);
+	static void setWpsState(uchar state);
+	static uchar getWpsState();
+
+	static void setWirelessMode(WIRELESS_MODE _mode) { wirelessMode = _mode; };
+	static WIRELESS_MODE getWirelessMode() { return wirelessMode; };
+	static void setChannelIndex(int index) { channelIndex = index; };
+	static int getChannelIndex() { return channelIndex; };
+	static const char *getChannelList(WIRELESS_MODE _mode);
+
+	static bool setChannel(WIRELESS_MODE _mode, int channel);
+
+private slots:
+	void receiveMsgs();
+
+private:
+	static QProcess	*mainProcess;
+
+	static struct wpa_ctrl *monitor;
+	static struct wpa_ctrl *ctrl;
+
+	static char *iface;
+
+	static QMutex *mtx;
+
+	static MODE mode;
+	static METHOD method;
+
+	static char *wirelessInterface;
+	static char *wirelessDriver;
+	static char *wiredInterface;
+	static char *bridgeInterface;
+	static char *nfcInterface;
+
+	static char *ipAddress;
+	static char *netMask;
+
+	static char ssid[32 + 1];
+	static ushort authType;
+	static ushort encrType;
+	static char netKey[64 + 1];
+	static uchar wpsState;
+	static ushort wepKeyIndex;
+	static char wepKey[4][27];
+
+	static WIRELESS_MODE wirelessMode;
+	static int channel;
+	static int channelIndex;
+	static char *channelList;
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+	static QSocketNotifier *msgNotifier;
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+};
+
+#endif // MAINPROCESS_H
Index: testbed_ap/web/wps_scpd.xml
===================================================================
--- testbed_ap/web/wps_scpd.xml	(revision 0)
+++ testbed_ap/web/wps_scpd.xml	(revision 2)
@@ -0,0 +1,225 @@
+<?xml version="1.0"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+  <specVersion>
+    <major>1</major>
+    <minor>0</minor>
+  </specVersion>
+  <actionList>
+    <action>
+      <name>GetDeviceInfo</name>
+      <argumentList>
+        <argument>
+          <name>NewDeviceInfo</name>
+          <direction>out</direction>
+          <relatedStateVariable>DeviceInfo</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>PutMessage</name>
+      <argumentList>
+        <argument>
+          <name>NewInMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>InMessage</relatedStateVariable>
+        </argument>
+        <argument>
+          <name>NewOutMessage</name>
+          <direction>out</direction>
+          <relatedStateVariable>OutMessage</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>GetAPSettings</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+        <argument>
+          <name>NewAPSettings</name>
+          <direction>out</direction>
+          <relatedStateVariable>APSettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>SetAPSettings</name>
+      <argumentList>
+        <argument>
+          <name>APSettings</name>
+          <direction>in</direction>
+          <relatedStateVariable>APSettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>DelAPSettings</name>
+      <argumentList>
+        <argument>
+          <name>NewAPSettings</name>
+          <direction>in</direction>
+          <relatedStateVariable>APSettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>GetSTASettings</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+        <argument>
+          <name>NewSTASettings</name>
+          <direction>out</direction>
+          <relatedStateVariable>STASettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>SetSTASettings</name>
+      <argumentList>
+        <argument>
+          <name>NewSTASettings</name>
+          <direction>out</direction>
+          <relatedStateVariable>STASettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>DelSTASettings</name>
+      <argumentList>
+        <argument>
+          <name>NewSTASettings</name>
+          <direction>in</direction>
+          <relatedStateVariable>STASettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>PutWLANResponse</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+        <argument>
+          <name>NewWLANEventType</name>
+          <direction>in</direction>
+          <relatedStateVariable>WLANEventType</relatedStateVariable>
+        </argument>
+        <argument>
+          <name>NewWLANEventMAC</name>
+          <direction>in</direction>
+          <relatedStateVariable>WLANEventMAC</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>SetSelectedRegistrar</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>RebootAP</name>
+      <argumentList>
+        <argument>
+        <name>NewAPSettings</name>
+          <direction>in</direction>
+          <relatedStateVariable>APSettings</relatedStateVariable>
+          </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>ResetAP</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>RebootSTA</name>
+      <argumentList>
+        <argument>
+          <name>NewSTASettings</name>
+          <direction>in</direction>
+          <relatedStateVariable>APSettings</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+    <action>
+      <name>ResetSTA</name>
+      <argumentList>
+        <argument>
+          <name>NewMessage</name>
+          <direction>in</direction>
+          <relatedStateVariable>Message</relatedStateVariable>
+        </argument>
+      </argumentList>
+    </action>
+  </actionList>
+  <serviceStateTable>
+    <stateVariable sendEvents="no">
+      <name>Message</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>InMessage</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>OutMessage</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>DeviceInfo</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>APSettings</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="yes">
+      <name>APStatus</name>
+      <dataType>ui1</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>STASettings</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="yes">
+      <name>STAStatus</name>
+      <dataType>ui1</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="yes">
+      <name>WLANEvent</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>WLANEventType</name>
+      <dataType>ui1</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>WLANEventMAC</name>
+      <dataType>string</dataType>
+    </stateVariable>
+    <stateVariable sendEvents="no">
+      <name>WLANResponse</name>
+      <dataType>bin.base64</dataType>
+    </stateVariable>
+  </serviceStateTable>
+</scpd>
+
Index: testbed_ap/web/wps_device.xml
===================================================================
--- testbed_ap/web/wps_device.xml	(revision 0)
+++ testbed_ap/web/wps_device.xml	(revision 2)
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+<root xmlns="urn:schemas-upnp-org:device-1-0">
+  <specVersion>
+    <major>1</major>
+    <minor>0</minor>
+  </specVersion>
+  <device>
+    <deviceType>urn:schemas-wifialliance-org:device:WFADevice:1</deviceType>
+    <friendlyName>WPS Access Point</friendlyName>
+    <manufacturer>Sony</manufacturer>
+    <manufacturerURL>https://www.wifisc.sony.biz</manufacturerURL>
+    <modelDescription>Wi-Fi Protected Setup Access Point</modelDescription>
+    <modelName>WPS_HOSTAPD_AP</modelName>
+    <modelNumber>01234567</modelNumber>
+    <modelURL>https://www.wifisc.sony.biz</modelURL>
+    <serialNumber>01234567</serialNumber>
+    <UDN>uuid:000102030405060708090a0b0c0d0e0f</UDN>
+    <UPC>01234567</UPC>
+    <serviceList>
+      <service>
+        <serviceType>urn:schemas-wifialliance-org:service:WFAWLANConfig:1</serviceType>
+        <serviceId>urn:wifialliance-org:serviceId:WFAWLANConfig1</serviceId>
+        <SCPDURL>/wps_scpd.xml</SCPDURL>
+        <controlURL>/upnp/control/wps_device</controlURL>
+        <eventSubURL>/upnp/event/wps_device</eventSubURL>
+      </service>
+    </serviceList>
+</device>
+</root>
Index: testbed_ap/ap_start
===================================================================
--- testbed_ap/ap_start	(revision 0)
+++ testbed_ap/ap_start	(revision 2)
@@ -0,0 +1,96 @@
+#!/bin/bash
+
+# check parameters
+if [ -z "$1" -o -z "$2" -o -z "$3" -o -z "$4" -o -z "$5" ]; then
+	echo "$0 [bridge-interface] [madwifi-interface] [wired-interface] [ipaddress] [netmask]";
+	exit -1;
+fi
+
+# kill process if it is running
+kill_process()
+{
+	running_process=$(ps -A|grep ${1})
+	if [ -n "$running_process" ]; then
+		killall -s SIGTERM $running_process 2>/dev/null;
+		sleep 1;
+		return 0;
+	fi
+	return -1;
+}
+
+# set local loopback
+lo=$(ifconfig|grep -i loopback|sed 's/[[:blank:]].*$//g')
+if [ -z $lo ]; then
+	ifup lo;
+fi
+
+# kill "hostapd" deamon if it is running
+main_daemon=hostapd
+kill_process $main_daemon
+
+# remove interface directory if it exists
+if [ -d /var/run/$main_daemon ]; then
+	rm -rf /var/run/$main_daemon
+fi
+
+# get index & current mode(0:sta, 1:ap, 53:monitor)
+index=$(echo $2|sed -ne "s:.*[^0-9*]::p")
+mode=$(iwpriv $2 get_uapsd 2>/dev/null|sed -ne "s:$2.*get_uapsd\:::p")
+
+# destroy madwifi-interface first
+if [ -z "$mode" ]; then
+	mode=-1
+elif [ $mode -ne 1 ]; then
+	wlanconfig $2 destroy >/dev/null;
+	sleep 1;
+fi
+
+# create madwifi-interface
+if [ $mode -ne 1 ]; then
+	res=$(wlanconfig $2 create wlandev wifi$index wlanmode ap)
+	if [ "$res" != "$2" ]; then
+		exit -1;
+	fi
+	sleep 1;
+fi
+iwpriv $2 wds 1
+
+# reset bridge interface
+br=$(ifconfig|grep -i $1|sed 's/[[:blank:]].*$//g')
+if [ ! -z "$br" ]; then
+	ifconfig $1 down
+	brctl delbr $1
+fi
+
+# setup all interfaces
+ifconfig $2 0.0.0.0 up
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+ifconfig $3 0.0.0.0 up
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+
+# create bridge interface
+brctl addbr $1
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+brctl addif $1 $3
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+brctl addif $1 $2
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+brctl setfd $1 1
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+ifconfig $1 $4 netmask $5 up
+if [ $? -ne 0 ]; then
+	exit -1;
+fi
+
Index: testbed_ap/wepkey.ui
===================================================================
--- testbed_ap/wepkey.ui	(revision 0)
+++ testbed_ap/wepkey.ui	(revision 2)
@@ -0,0 +1,124 @@
+<ui version="4.0" >
+ <class>WepKey</class>
+ <widget class="QWidget" name="WepKey" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>532</width>
+    <height>271</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>60</y>
+     <width>511</width>
+     <height>161</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>6</number>
+    </property>
+    <item row="0" column="0" >
+     <widget class="QRadioButton" name="rbWepKey1" >
+      <property name="text" >
+       <string>WEP key 1</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QRadioButton" name="rbWepKey2" >
+      <property name="text" >
+       <string>WEP key 2</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QRadioButton" name="rbWepKey3" >
+      <property name="text" >
+       <string>WEP Key 3</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QRadioButton" name="rbWepKey4" >
+      <property name="text" >
+       <string>WEP key 4</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLineEdit" name="leWepKey1" />
+    </item>
+    <item row="0" column="2" >
+     <widget class="QPushButton" name="pbGenWepKey1" >
+      <property name="text" >
+       <string>GEN</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QLineEdit" name="leWepKey2" />
+    </item>
+    <item row="2" column="1" >
+     <widget class="QLineEdit" name="leWepKey3" />
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLineEdit" name="leWepKey4" />
+    </item>
+    <item row="1" column="2" >
+     <widget class="QPushButton" name="pbGenWepKey2" >
+      <property name="text" >
+       <string>GEN</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="2" >
+     <widget class="QPushButton" name="pbGenWepKey3" >
+      <property name="text" >
+       <string>GEN</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="2" >
+     <widget class="QPushButton" name="pbGenWepKey4" >
+      <property name="text" >
+       <string>GEN</string>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>20</x>
+     <y>20</y>
+     <width>521</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Set WEP key(s)</string>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/setup-mingw-cross-compiling
===================================================================
--- testbed_ap/setup-mingw-cross-compiling	(revision 0)
+++ testbed_ap/setup-mingw-cross-compiling	(revision 2)
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+# qmake seems to be forcing include and lib paths from the original build
+# and I have no idea how to change these. For now, just override the
+# directories in the Makefile.Release file after qmake run.
+
+qmake -spec /q/jm/qt4-win/4.0.0/mkspecs/win32-g++ wpa_gui.pro -o Makefile
+cat Makefile.Release |
+    sed s%qt4/lib%qt4-win/4.0.0/lib%g |
+    sed s%qt4/include%qt4-win/4.0.0/include%g > tmp.Makefile.Release &&
+mv -f tmp.Makefile.Release Makefile.Release
Index: testbed_ap/ap_end
===================================================================
--- testbed_ap/ap_end	(revision 0)
+++ testbed_ap/ap_end	(revision 2)
@@ -0,0 +1,38 @@
+#!/bin/bash
+
+# kill process if it is running
+kill_process()
+{
+	running_process=$(ps -A|grep ${1})
+	if [ -n "$running_process" ]; then
+		killall -s SIGTERM $running_process 2>/dev/null;
+		sleep 1;
+		return 0;
+	fi
+	return -1;
+}
+
+down_interface()
+{
+	ifconfig ${1} down 2>/dev/null
+}
+
+# kill "hostapd" deamon if it is running
+main_daemon=hostapd
+kill_process $main_daemon
+
+# remove interface directory if it exists
+if [ -d /var/run/$main_daemon ]; then
+	rm -rf /var/run/$main_daemon
+fi
+
+
+if [ -n "$1" -a -n "$2" -a -n "$3" ]; then
+	down_interface $2;
+	down_interface $3;
+	brctl delif $1 $2
+	brctl delif $1 $3
+	down_interface $1;
+	brctl delbr $1
+fi
+
Index: testbed_ap/hostapd.conf
===================================================================
--- testbed_ap/hostapd.conf	(revision 0)
+++ testbed_ap/hostapd.conf	(revision 2)
@@ -0,0 +1,844 @@
+##### hostapd configuration file ##############################################
+# Empty lines and lines starting with # are ignored
+
+# AP netdevice name (without 'ap' postfix, i.e., wlan0 uses wlan0ap for
+# management frames); ath0 for madwifi
+#interface=wlan0
+interface=ath0
+
+# In case of madwifi driver, an additional configuration parameter, bridge,
+# must be used to notify hostapd if the interface is included in a bridge. This
+# parameter is not used with Host AP driver.
+bridge=br0
+
+# Driver interface type (hostap/wired/madwifi/prism54; default: hostap)
+# driver=hostap
+driver=madwifi
+
+# NFC interface
+nfc=/dev/ttyUSB0
+
+# hostapd event logger configuration
+#
+# Two output method: syslog and stdout (only usable if not forking to
+# background).
+#
+# Module bitfield (ORed bitfield of modules that will be logged; -1 = all
+# modules):
+# bit 0 (1) = IEEE 802.11
+# bit 1 (2) = IEEE 802.1X
+# bit 2 (4) = RADIUS
+# bit 3 (8) = WPA
+# bit 4 (16) = driver interface # bit 5 (32) = IAPP
+# bit 6 (64) = MLME
+#
+# Levels (minimum value for logged events):
+#  0 = verbose debugging
+#  1 = debugging
+#  2 = informational messages
+#  3 = notification
+#  4 = warning
+#
+logger_syslog=-1
+logger_syslog_level=2
+logger_stdout=-1
+logger_stdout_level=2
+
+# Debugging: 0 = no, 1 = minimal, 2 = verbose, 3 = msg dumps, 4 = excessive
+debug=0
+
+# Dump file for state information (on SIGUSR1)
+dump_file=/tmp/hostapd.dump
+
+# Interface for separate control program. If this is specified, hostapd
+# will create this directory and a UNIX domain socket for listening to requests
+# from external programs (CLI/GUI, etc.) for status information and
+# configuration. The socket file will be named based on the interface name, so
+# multiple hostapd processes/interfaces can be run at the same time if more
+# than one interface is used.
+# /var/run/hostapd is the recommended directory for sockets and by default,
+# hostapd_cli will use it when trying to connect with hostapd.
+ctrl_interface=/var/run/hostapd
+
+# Access control for the control interface can be configured by setting the
+# directory to allow only members of a group to use sockets. This way, it is
+# possible to run hostapd as root (since it needs to change network
+# configuration and open raw sockets) and still allow GUI/CLI components to be
+# run as non-root users. However, since the control interface can be used to
+# change the network configuration, this access needs to be protected in many
+# cases. By default, hostapd is configured to use gid 0 (root). If you
+# want to allow non-root users to use the contron interface, add a new group
+# and change this value to match with that group. Add users that should have
+# control interface access to this group.
+#
+# This variable can be a group name or gid.
+#ctrl_interface_group=wheel
+ctrl_interface_group=0
+
+
+##### IEEE 802.11 related configuration #######################################
+
+# SSID to be used in IEEE 802.11 management frames
+ssid=SonyAP
+
+# Country code (ISO/IEC 3166-1).  Used to set regulatory domain.
+# Modify as needed to indicate country in which device is operating.
+# This can limit available channels and transmit power.
+# (default: US)
+#country_code=US
+
+# Enable IEEE 802.11d. This advertises the country_code and the set of allowed
+# channels and transmit power levels based on the regulatory limits. The
+# country_code setting must be configured with the correct country for
+# IEEE 802.11d functions.
+# (default: 0 = disabled)
+#ieee80211d=1
+
+# Enable IEEE 802.11h. This enables the TPC and DFS services when operating
+# in a regulatory domain which requires them.  Once enabled it will be 
+# operational only when working in hw_mode a and in countries where it is
+# required. The end user should not be allowed to disable this.
+# The country_code setting must be configured with the correct country for
+# IEEE 802.11h to function. 
+# When IEEE 802.11h is operational, the channel_policy and configured channel 
+# settings will be ignored but will behave as though the channel_policy is
+# set to "3" (automatic channel selection). When IEEE 802.11h is enabled but
+# not operational (for example, if the radio mode is changed from "a" to "b")
+# the channel_policy and channel settings take effect again. 
+# (default: 1 = enabled)
+#ieee80211h=1
+
+# Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,
+# Default: IEEE 802.11b
+hw_mode=a
+
+# Channel number (IEEE 802.11)
+# (default: 0, i.e., not set, used with channel_policy=2)
+channel=60
+
+# Beacon interval in kus (1.024 ms) (default: 100; range 15..65535)
+beacon_int=100
+
+# DTIM (delivery trafic information message) period (range 1..255):
+# number of beacons between DTIMs (1 = every beacon includes DTIM element)
+# (default: 2)
+dtim_period=2
+
+# Maximum number of stations allowed in station table. New stations will be
+# rejected after the station table is full. IEEE 802.11 has a limit of 2007
+# different association IDs, so this number should not be larger than that.
+# (default: 2007)
+max_num_sta=255
+
+# RTS/CTS threshold; 2347 = disabled (default); range 0..2347
+# If this field is not included in hostapd.conf, hostapd will not control
+# RTS threshold and 'iwconfig wlan# rts <val>' can be used to set it.
+rts_threshold=2347
+
+# Fragmentation threshold; 2346 = disabled (default); range 256..2346
+# If this field is not included in hostapd.conf, hostapd will not control
+# fragmentation threshold and 'iwconfig wlan# frag <val>' can be used to set
+# it.
+fragm_threshold=2346
+
+# Rate configuration
+# Default is to enable all rates supported by the hardware. This configuration
+# item allows this list be filtered so that only the listed rates will be left
+# in the list. If the list is empty, all rates are used. This list can have
+# entries that are not in the list of rates the hardware supports (such entries
+# are ignored). The entries in this list are in 100 kbps, i.e., 11 Mbps = 110.
+# If this item is present, at least one rate have to be matching with the rates
+# hardware supports.
+# default: use the most common supported rate setting for the selected
+# hw_mode (i.e., this line can be removed from configuration file in most
+# cases)
+#supported_rates=10 20 55 110 60 90 120 180 240 360 480 540
+
+# Basic rate set configuration
+# List of rates (in 100 kbps) that are included in the basic rate set.
+# If this item is not included, usually reasonable default set is used.
+#basic_rates=10 20
+#basic_rates=10 20 55 110
+#basic_rates=60 120 240
+
+# Station MAC address -based authentication
+# Please note that this kind of access control requires a driver that uses
+# hostapd to take care of management frame processing and as such, this can be
+# used with driver=hostap or driver=devicescape, but not with driver=madwifi.
+# 0 = accept unless in deny list
+# 1 = deny unless in accept list
+# 2 = use external RADIUS server (accept/deny lists are searched first)
+macaddr_acl=0
+
+# Accept/deny lists are read from separate files (containing list of
+# MAC addresses, one per line). Use absolute path name to make sure that the
+# files can be read on SIGHUP configuration reloads.
+#accept_mac_file=/etc/hostapd.accept
+#deny_mac_file=/etc/hostapd.deny
+
+# IEEE 802.11 specifies two authentication algorithms. hostapd can be
+# configured to allow both of these or only one. Open system authentication
+# should be used with IEEE 802.1X.
+# Bit fields of allowed authentication algorithms:
+# bit 0 = Open System Authentication
+# bit 1 = Shared Key Authentication (requires WEP)
+auth_algs=1
+
+# Send empty SSID in beacons and ignore probe request frames that do not
+# specify full SSID, i.e., require stations to know SSID.
+# default: disabled (0)
+# 1 = send empty (length=0) SSID in beacon and ignore probe request for
+#     broadcast SSID
+# 2 = clear SSID (ASCII 0), but keep the original length (this may be required
+#     with some clients that do not support empty SSID) and ignore probe
+#     requests for broadcast SSID
+ignore_broadcast_ssid=0
+
+# TX queue parameters (EDCF / bursting)
+# default for all these fields: not set, use hardware defaults
+# tx_queue_<queue name>_<param>
+# queues: data0, data1, data2, data3, after_beacon, beacon
+#		(data0 is the highest priority queue)
+# parameters:
+#   aifs: AIFS (default 2)
+#   cwmin: cwMin (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023)
+#   cwmax: cwMax (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023); cwMax >= cwMin
+#   burst: maximum length (in milliseconds with precision of up to 0.1 ms) for
+#          bursting
+#
+# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
+# These parameters are used by the access point when transmitting frames
+# to the clients.
+#
+# Low priority / AC_BK = background
+#tx_queue_data3_aifs=7
+#tx_queue_data3_cwmin=15
+#tx_queue_data3_cwmax=1023
+#tx_queue_data3_burst=0
+# Note: for IEEE 802.11b mode: cWmin=31 cWmax=1023 burst=0
+#
+# Normal priority / AC_BE = best effort
+#tx_queue_data2_aifs=3
+#tx_queue_data2_cwmin=15
+#tx_queue_data2_cwmax=63
+#tx_queue_data2_burst=0
+# Note: for IEEE 802.11b mode: cWmin=31 cWmax=127 burst=0
+#
+# High priority / AC_VI = video
+#tx_queue_data1_aifs=1
+#tx_queue_data1_cwmin=7
+#tx_queue_data1_cwmax=15
+#tx_queue_data1_burst=3.0
+# Note: for IEEE 802.11b mode: cWmin=15 cWmax=31 burst=6.0
+#
+# Highest priority / AC_VO = voice
+#tx_queue_data0_aifs=1
+#tx_queue_data0_cwmin=3
+#tx_queue_data0_cwmax=7
+#tx_queue_data0_burst=1.5
+# Note: for IEEE 802.11b mode: cWmin=7 cWmax=15 burst=3.3
+#
+# Special queues; normally not user configurable
+#
+#tx_queue_after_beacon_aifs=2
+#tx_queue_after_beacon_cwmin=15
+#tx_queue_after_beacon_cwmax=1023
+#tx_queue_after_beacon_burst=0
+#
+#tx_queue_beacon_aifs=2
+#tx_queue_beacon_cwmin=3
+#tx_queue_beacon_cwmax=7
+#tx_queue_beacon_burst=1.5
+
+# 802.1D Tag to AC mappings
+# WMM specifies following mapping of data frames to different ACs. This mapping
+# can be configured using Linux QoS/tc and sch_pktpri.o module.
+# 802.1D Tag	802.1D Designation	Access Category	WMM Designation
+# 1		BK			AC_BK		Background
+# 2		-			AC_BK		Background
+# 0		BE			AC_BE		Best Effort
+# 3		EE			AC_VI		Video
+# 4		CL			AC_VI		Video
+# 5		VI			AC_VI		Video
+# 6		VO			AC_VO		Voice
+# 7		NC			AC_VO		Voice
+# Data frames with no priority information: AC_BE
+# Management frames: AC_VO
+# PS-Poll frames: AC_BE
+
+# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
+# for 802.11a or 802.11g networks
+# These parameters are sent to WMM clients when they associate.
+# The parameters will be used by WMM clients for frames transmitted to the
+# access point.
+#
+# note - txop_limit is in units of 32microseconds
+# note - acm is admission control mandatory flag. 0 = admission control not
+# required, 1 = mandatory
+# note - here cwMin and cmMax are in exponent form. the actual cw value used
+# will be (2^n)-1 where n is the value given here
+#
+wme_enabled=0
+#
+# Low priority / AC_BK = background
+wme_ac_bk_cwmin=4
+wme_ac_bk_cwmax=10
+wme_ac_bk_aifs=7
+wme_ac_bk_txop_limit=0
+wme_ac_bk_acm=0
+# Note: for IEEE 802.11b mode: cWmin=5 cWmax=10
+#
+# Normal priority / AC_BE = best effort
+wme_ac_be_aifs=3
+wme_ac_be_cwmin=4
+wme_ac_be_cwmax=10
+wme_ac_be_txop_limit=0
+wme_ac_be_acm=0
+# Note: for IEEE 802.11b mode: cWmin=5 cWmax=7
+#
+# High priority / AC_VI = video
+wme_ac_vi_aifs=2
+wme_ac_vi_cwmin=3
+wme_ac_vi_cwmax=4
+wme_ac_vi_txop_limit=94
+wme_ac_vi_acm=0
+# Note: for IEEE 802.11b mode: cWmin=4 cWmax=5 txop_limit=188
+#
+# Highest priority / AC_VO = voice
+wme_ac_vo_aifs=2
+wme_ac_vo_cwmin=2
+wme_ac_vo_cwmax=3
+wme_ac_vo_txop_limit=47
+wme_ac_vo_acm=0
+# Note: for IEEE 802.11b mode: cWmin=3 cWmax=4 burst=102
+
+# Associate as a station to another AP while still acting as an AP on the same
+# channel.
+#assoc_ap_addr=00:12:34:56:78:9a
+
+# Static WEP key configuration
+#
+# The key number to use when transmitting.
+# It must be between 0 and 3, and the corresponding key must be set.
+# default: not set
+#wep_default_key=0
+# The WEP keys to use.
+# A key may be a quoted string or unquoted hexadecimal digits.
+# The key length should be 5, 13, or 16 characters, or 10, 26, or 32
+# digits, depending on whether 40-bit (64-bit), 104-bit (128-bit), or
+# 128-bit (152-bit) WEP is used.
+# Only the default key must be supplied; the others are optional.
+# default: not set
+#wep_key0=123456789a
+#wep_key1="vwxyz"
+#wep_key2=0102030405060708090a0b0c0d
+#wep_key3=".2.4.6.8.0.23"
+
+# Station inactivity limit
+#
+# If a station does not send anything in ap_max_inactivity seconds, an
+# empty data frame is sent to it in order to verify whether it is
+# still in range. If this frame is not ACKed, the station will be
+# disassociated and then deauthenticated. This feature is used to
+# clear station table of old entries when the STAs move out of the
+# range.
+#
+# The station can associate again with the AP if it is still in range;
+# this inactivity poll is just used as a nicer way of verifying
+# inactivity; i.e., client will not report broken connection because
+# disassociation frame is not sent immediately without first polling
+# the STA with a data frame.
+# default: 300 (i.e., 5 minutes)
+#ap_max_inactivity=300
+
+# Enable/disable internal bridge for packets between associated stations.
+#
+# When IEEE 802.11 is used in managed mode, packets are usually send through
+# the AP even if they are from a wireless station to another wireless station.
+# This functionality requires that the AP has a bridge functionality that sends
+# frames back to the same interface if their destination is another associated
+# station. In addition, broadcast/multicast frames from wireless stations will
+# be sent both to the host system net stack (e.g., to eventually wired network)
+# and back to the wireless interface.
+#
+# The internal bridge is implemented within the wireless kernel module and it
+# bypasses kernel filtering (netfilter/iptables/ebtables). If direct
+# communication between the stations needs to be prevented, the internal
+# bridge can be disabled by setting bridge_packets=0.
+#
+# Note: If this variable is not included in hostapd.conf, hostapd does not
+# change the configuration and iwpriv can be used to set the value with
+# 'iwpriv wlan# param 10 0' command. If the variable is in hostapd.conf,
+# hostapd will override possible iwpriv configuration whenever configuration
+# file is reloaded.
+#
+# default: do not control from hostapd (80211.o defaults to 1=enabled)
+#bridge_packets=1
+
+
+##### IEEE 802.1X-2004 related configuration ##################################
+
+# Require IEEE 802.1X authorization
+#ieee8021x=1
+ieee8021x=0
+
+# IEEE 802.1X/EAPOL version
+# hostapd is implemented based on IEEE Std 802.1X-2004 which defines EAPOL
+# version 2. However, there are many client implementations that do not handle
+# the new version number correctly (they seem to drop the frames completely).
+# In order to make hostapd interoperate with these clients, the version number
+# can be set to the older version (1) with this configuration value.
+#eapol_version=2
+eapol_version=2
+
+# Optional displayable message sent with EAP Request-Identity. The first \0
+# in this string will be converted to ASCII-0 (nul). This can be used to
+# separate network info (comma separated list of attribute=value pairs); see,
+# e.g., draft-adrangi-eap-network-discovery-07.txt.
+#eap_message=hello
+#eap_message=hello\0networkid=netw,nasid=foo,portid=0,NAIRealms=example.com
+
+# WEP rekeying (disabled if key lengths are not set or are set to 0)
+# Key lengths for default/broadcast and individual/unicast keys:
+# 5 = 40-bit WEP (also known as 64-bit WEP with 40 secret bits)
+# 13 = 104-bit WEP (also known as 128-bit WEP with 104 secret bits)
+#wep_key_len_broadcast=5
+#wep_key_len_unicast=5
+# Rekeying period in seconds. 0 = do not rekey (i.e., set keys only once)
+#wep_rekey_period=300
+
+# EAPOL-Key index workaround (set bit7) for WinXP Supplicant (needed only if
+# only broadcast keys are used)
+eapol_key_index_workaround=0
+
+# EAP reauthentication period in seconds (default: 3600 seconds; 0 = disable
+# reauthentication).
+#eap_reauth_period=3600
+
+# Use PAE group address (01:80:c2:00:00:03) instead of individual target
+# address when sending EAPOL frames with driver=wired. This is the most common
+# mechanism used in wired authentication, but it also requires that the port
+# is only used by one station.
+#use_pae_group_addr=1
+
+##### Integrated EAP server ###################################################
+
+# Optionally, hostapd can be configured to use an integrated EAP server
+# to process EAP authentication locally without need for an external RADIUS
+# server. This functionality can be used both as a local authentication server
+# for IEEE 802.1X/EAPOL and as a RADIUS server for other devices.
+
+# Use integrated EAP server instead of external RADIUS authentication
+# server. This is also needed if hostapd is configured to act as a RADIUS
+# authentication server.
+#eap_server=0
+eap_server=1
+
+# Path for EAP server user database
+#eap_user_file=/etc/hostapd.eap_user
+eap_user_file=./hostapd.eap_user
+
+# CA certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
+#ca_cert=/etc/hostapd.ca.pem
+
+# Server certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
+#server_cert=/etc/hostapd.server.pem
+
+# Private key matching with the server certificate for EAP-TLS/PEAP/TTLS
+# This may point to the same file as server_cert if both certificate and key
+# are included in a single file. PKCS#12 (PFX) file (.p12/.pfx) can also be
+# used by commenting out server_cert and specifying the PFX file as the
+# private_key.
+#private_key=/etc/hostapd.server.prv
+
+# Passphrase for private key
+#private_key_passwd=secret passphrase
+
+# Enable CRL verification.
+# Note: hostapd does not yet support CRL downloading based on CDP. Thus, a
+# valid CRL signed by the CA is required to be included in the ca_cert file.
+# This can be done by using PEM format for CA certificate and CRL and
+# concatenating these into one file. Whenever CRL changes, hostapd needs to be
+# restarted to take the new CRL into use.
+# 0 = do not verify CRLs (default)
+# 1 = check the CRL of the user certificate
+# 2 = check all CRLs in the certificate path
+#check_crl=1
+
+# Configuration data for EAP-SIM database/authentication gateway interface.
+# This is a text string in implementation specific format. The example
+# implementation in eap_sim_db.c uses this as the UNIX domain socket name for
+# the HLR/AuC gateway (e.g., hlr_auc_gw). In this case, the path uses "unix:"
+# prefix.
+#eap_sim_db=unix:/tmp/hlr_auc_gw.sock
+
+
+##### IEEE 802.11f - Inter-Access Point Protocol (IAPP) #######################
+
+# Interface to be used for IAPP broadcast packets
+#iapp_interface=eth0
+
+
+##### RADIUS client configuration #############################################
+# for IEEE 802.1X with external Authentication Server, IEEE 802.11
+# authentication with external ACL for MAC addresses, and accounting
+
+# The own IP address of the access point (used as NAS-IP-Address)
+own_ip_addr=192.168.0.1
+
+# Optional NAS-Identifier string for RADIUS messages. When used, this should be
+# a unique to the NAS within the scope of the RADIUS server. For example, a
+# fully qualified domain name can be used here.
+#nas_identifier=ap.example.com
+
+# RADIUS authentication server
+#auth_server_addr=127.0.0.1
+#auth_server_port=1812
+#auth_server_shared_secret=secret
+
+# RADIUS accounting server
+#acct_server_addr=127.0.0.1
+#acct_server_port=1813
+#acct_server_shared_secret=secret
+
+# Secondary RADIUS servers; to be used if primary one does not reply to
+# RADIUS packets. These are optional and there can be more than one secondary
+# server listed.
+#auth_server_addr=127.0.0.2
+#auth_server_port=1812
+#auth_server_shared_secret=secret2
+#
+#acct_server_addr=127.0.0.2
+#acct_server_port=1813
+#acct_server_shared_secret=secret2
+
+# Retry interval for trying to return to the primary RADIUS server (in
+# seconds). RADIUS client code will automatically try to use the next server
+# when the current server is not replying to requests. If this interval is set,
+# primary server will be retried after configured amount of time even if the
+# currently used secondary server is still working.
+#radius_retry_primary_interval=600
+
+
+# Interim accounting update interval
+# If this is set (larger than 0) and acct_server is configured, hostapd will
+# send interim accounting updates every N seconds. Note: if set, this overrides
+# possible Acct-Interim-Interval attribute in Access-Accept message. Thus, this
+# value should not be configured in hostapd.conf, if RADIUS server is used to
+# control the interim interval.
+# This value should not be less 600 (10 minutes) and must not be less than
+# 60 (1 minute).
+#radius_acct_interim_interval=600
+
+# Dynamic VLAN mode; allow RADIUS authentication server to decide which VLAN
+# is used for the stations. This information is parsed from following RADIUS
+# attributes based on RFC 3580 and RFC 2868: Tunnel-Type (value 13 = VLAN),
+# Tunnel-Medium-Type (value 6 = IEEE 802), Tunnel-Private-Group-ID (value
+# VLANID as a string). vlan_file option below must be configured if dynamic
+# VLANs are used.
+# 0 = disabled (default)
+# 1 = option; use default interface if RADIUS server does not include VLAN ID
+# 2 = required; reject authentication if RADIUS server does not include VLAN ID
+#dynamic_vlan=0
+
+# VLAN interface list for dynamic VLAN mode is read from a separate text file.
+# This list is used to map VLAN ID from the RADIUS server to a network
+# interface. Each station is bound to one interface in the same way as with
+# multiple BSSIDs or SSIDs. Each line in this text file is defining a new
+# interface and the line must include VLAN ID and interface name separated by
+# white space (space or tab).
+#vlan_file=/etc/hostapd.vlan
+
+# Interface where 802.1q tagged packets should appear when a RADIUS server is
+# used to determine which VLAN a station is on.  hostapd creates a bridge for
+# each VLAN.  Then hostapd adds a VLAN interface (associated with the interface
+# indicated by 'vlan_tagged_interface') and the appropriate wireless interface
+# to the bridge.
+#vlan_tagged_interface=eth0
+
+
+##### RADIUS authentication server configuration ##############################
+
+# hostapd can be used as a RADIUS authentication server for other hosts. This
+# requires that the integrated EAP authenticator is also enabled and both
+# authentication services are sharing the same configuration.
+
+# File name of the RADIUS clients configuration for the RADIUS server. If this
+# commented out, RADIUS server is disabled.
+#radius_server_clients=/etc/hostapd.radius_clients
+
+# The UDP port number for the RADIUS authentication server
+#radius_server_auth_port=1812
+
+# Use IPv6 with RADIUS server (IPv4 will also be supported using IPv6 API)
+#radius_server_ipv6=1
+
+
+##### WPA/IEEE 802.11i configuration ##########################################
+
+# Enable WPA. Setting this variable configures the AP to require WPA (either
+# WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either
+# wpa_psk or wpa_passphrase must be set and wpa_key_mgmt must include WPA-PSK.
+# For WPA-RADIUS/EAP, ieee8021x must be set (but without dynamic WEP keys),
+# RADIUS authentication server must be configured, and WPA-EAP must be included
+# in wpa_key_mgmt.
+# This field is a bit field that can be used to enable WPA (IEEE 802.11i/D3.0)
+# and/or WPA2 (full IEEE 802.11i/RSN):
+# bit0 = WPA
+# bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
+#wpa=1
+wpa=1
+
+# WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
+# secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
+# (8..63 characters) that will be converted to PSK. This conversion uses SSID
+# so the PSK changes when ASCII passphrase is used and the SSID is changed.
+# wpa_psk (dot11RSNAConfigPSKValue)
+# wpa_passphrase (dot11RSNAConfigPSKPassPhrase)
+#wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
+#wpa_passphrase=secret passphrase
+wpa_passphrase=sonysony
+
+# Optionally, WPA PSKs can be read from a separate text file (containing list
+# of (PSK,MAC address) pairs. This allows more than one PSK to be configured.
+# Use absolute path name to make sure that the files can be read on SIGHUP
+# configuration reloads.
+#wpa_psk_file=/etc/hostapd.wpa_psk
+
+# Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The
+# entries are separated with a space.
+# (dot11RSNAConfigAuthenticationSuitesTable)
+#wpa_key_mgmt=WPA-PSK WPA-EAP
+wpa_key_mgmt=WPA-PSK
+
+# Set of accepted cipher suites (encryption algorithms) for pairwise keys
+# (unicast packets). This is a space separated list of algorithms:
+# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
+# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
+# Group cipher suite (encryption algorithm for broadcast and multicast frames)
+# is automatically selected based on this configuration. If only CCMP is
+# allowed as the pairwise cipher, group cipher will also be CCMP. Otherwise,
+# TKIP will be used as the group cipher.
+# (dot11RSNAConfigPairwiseCiphersTable)
+#wpa_pairwise=TKIP CCMP
+wpa_pairwise=TKIP
+
+# Time interval for rekeying GTK (broadcast/multicast encryption keys) in
+# seconds. (dot11RSNAConfigGroupRekeyTime)
+#wpa_group_rekey=600
+
+# Rekey GTK when any STA that possesses the current GTK is leaving the BSS.
+# (dot11RSNAConfigGroupRekeyStrict)
+#wpa_strict_rekey=1
+
+# Time interval for rekeying GMK (master key used internally to generate GTKs
+# (in seconds).
+#wpa_gmk_rekey=86400
+
+# Enable IEEE 802.11i/RSN/WPA2 pre-authentication. This is used to speed up
+# roaming be pre-authenticating IEEE 802.1X/EAP part of the full RSN
+# authentication and key handshake before actually associating with a new AP.
+# (dot11RSNAPreauthenticationEnabled)
+#rsn_preauth=1
+#
+# Space separated list of interfaces from which pre-authentication frames are
+# accepted (e.g., 'eth0' or 'eth0 wlan0wds0'. This list should include all
+# interface that are used for connections to other APs. This could include
+# wired interfaces and WDS links. The normal wireless data interface towards
+# associated stations (e.g., wlan0) should not be added, since
+# pre-authentication is only used with APs other than the currently associated
+# one.
+#rsn_preauth_interfaces=eth0
+
+# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e) is
+# allowed. This is only used with RSN/WPA2.
+# 0 = disabled (default)
+# 1 = enabled
+#peerkey=1
+
+# ieee80211w: Whether management frame protection is enabled
+# 0 = disabled (default)
+# 1 = optional
+# 2 = required
+#ieee80211w=0
+
+##### Passive scanning ########################################################
+# Scan different channels every N seconds. 0 = disable passive scanning.
+#passive_scan_interval=60
+
+# Listen N usecs on each channel when doing passive scanning.
+# This value plus the time needed for changing channels should be less than
+# 32 milliseconds (i.e. 32000 usec) to avoid interruptions to normal
+# operations. Time needed for channel changing varies based on the used wlan
+# hardware.
+# default: disabled (0)
+#passive_scan_listen=10000
+
+# Passive scanning mode:
+# 0 = scan all supported modes (802.11a/b/g/Turbo) (default)
+# 1 = scan only the mode that is currently used for normal operations
+#passive_scan_mode=1
+
+# Maximum number of entries kept in AP table (either for passive scanning or
+# for detecting Overlapping Legacy BSS Condition). The oldest entry will be
+# removed when adding a new entry that would make the list grow over this
+# limit. Note! Wi-Fi certification for IEEE 802.11g requires that OLBC is
+# enabled, so this field should not be set to 0 when using IEEE 802.11g.
+# default: 255
+#ap_table_max_size=255
+
+# Number of seconds of no frames received after which entries may be deleted
+# from the AP table. Since passive scanning is not usually performed frequently
+# this should not be set to very small value. In addition, there is no
+# guarantee that every scan cycle will receive beacon frames from the
+# neighboring APs.
+# default: 60
+#ap_table_expiration_time=3600
+
+# Multiple BSSID support
+#
+# Above configuration is using the default interface (wlan#, or multi-SSID VLAN
+# interfaces). Other BSSIDs can be added by using separator 'bss' with
+# default interface name to be allocated for the data packets of the new BSS.
+#
+# hostapd will generate BSSID mask based on the BSSIDs that are
+# configured. hostapd will verify that dev_addr & MASK == dev_addr. If this is
+# not the case, the MAC address of the radio must be changed before starting
+# hostapd (ifconfig wlan0 hw ether <MAC addr>).
+#
+# BSSIDs are assigned in order to each BSS, unless an explicit BSSID is
+# specified using the 'bssid' parameter.
+# If an explicit BSSID is specified, it must be chosen such that it:
+# - results in a valid MASK that covers it and the dev_addr
+# - is not the same as the MAC address of the radio
+# - is not the same as any other explicitly specified BSSID
+#
+# Please note that hostapd uses some of the values configured for the first BSS
+# as the defaults for the following BSSes. However, it is recommended that all
+# BSSes include explicit configuration of all relevant configuration items.
+#
+#bss=wlan0_0
+#ssid=test2
+# most of the above items can be used here (apart from radio interface specific
+# items, like channel)
+
+#bss=wlan0_1
+#bssid=00:13:10:95:fe:0b
+# ...
+
+# wps_property : WPS property
+wps_property={
+	# verion : version of WPS
+	# 1.0 : 0x10
+	# 1.1 : 0x11
+	version=0x10
+
+	# uuid : this interface's UUID
+	# the length of uuid must be 16 bytes (hex)
+	uuid=000102030405060708090a0b0c0d0e0f
+
+	# auth_type_flags : capabilities of network authentication
+	# Open    : 0x0001
+	# WPAPSK  : 0x0002
+	# Shared  : 0x0004
+	# WPA     : 0x0008
+	# WPA2    : 0x0010
+	# WPA2PSK : 0x0020
+	auth_type_flags=0x0023
+
+	# encr_type_flags : capabilities of network encryption
+	# None : 0x0001
+	# WEP  : 0x0002
+	# TKIP : 0x0004
+	# AES  : 0x0008
+	encr_type_flags=0x000f
+
+	# conn_type_flags : capabilities of connection
+	# ESS  : 0x01
+	# IBSS : 0x02
+	conn_type_flags=0x01
+
+	# config_methods : supported configuration methods
+	# USBA                 : 0x0001
+	# Ethernet             : 0x0002
+	# Label                : 0x0004
+	# Display              : 0x0008
+	# External NFC Token   : 0x0010
+	# Integrated NFC Token : 0x0020
+	# NFC Interface        : 0x0040
+	# Push Button          : 0x0080
+	# Keypad               : 0x0100
+	config_methods=0x01ca
+
+	# wps_state : Wi-Fi Protected Setup State
+	# Not congigurad : 0x01
+	# Configured     : 0x02
+	# Reserved       : 0x00, 0x03 - 0xFF
+	wps_state=2
+
+	# rf_bands : supported RF bands
+	# 2.4GHz : 0x01
+	# 5.0GHz : 0x02
+	rf_bands=0x03
+
+	# manufacturer : the name of manufacturer
+	# the length of manufacturer must be less than 64 bytes
+	manufacturer="Sony"
+
+	# model_name : the name of model
+	# the length of model_name must be less than 32 bytes
+	model_name="WPS_HOSTAPD_AP"
+
+	# model_number : model number
+	# the length of model_number must be less than 32 bytes
+	model_number="01234567"
+
+	# serial_number : serial number
+	# the length of serial_number must be less than 32 bytes
+	serial_number="01234567"
+
+	# dev_category : device category
+	# dev_sub_category : device sub category
+	# category                    / sub category
+	# Computer               : 1  / PC                      : 1
+	#                             / Server                  : 2
+	#                             / Mddia Center            : 3
+	# Input Device           : 2  / do not set
+	# Printers, Scanners,
+	# Faxes and Copiers      : 3  / Printer                 : 1
+	#                             / Scanner                 : 2
+	# Camera                 : 4  / Digital Still Camera    : 1
+	# Storage                : 5  / NAS                     : 1
+	# Network Infrastructure : 6  / AP                      : 1
+	#                             / Router                  : 2
+	#                             / Switch                  : 3
+	# Displays               : 7  / Television              : 1
+	#                             / Electronc Picture Frame : 2
+	# Multimedia Devices     : 8  / DAR                     : 1
+	#                             / PVR                     : 2
+	#                             / MCX                     : 3
+	# Gaming Devices         : 9  / Xbox                    : 1
+	#                             / Xbox360                 : 2
+	#                             / Playstation             : 3
+	# Telephone              : 10 / Windows Moble           : 1
+	dev_category=6
+	dev_sub_category=1
+
+	# dev_oui : device OUI
+	# the length of dev_oui must be 4 bytes (hex)
+	dev_oui=0050f204
+
+	# dev_name : device name
+	# the length of dev_name must be less than 32 bytes (hex)
+	dev_name="SonyAP"
+
+	# os_name : OS version
+	# for futures
+	os_version=0x00000001
+
+	# upnp_root_dir : root directory for UPnP's XML files
+	upnp_root_dir="./web"
+
+	# upnp_desc_url : descriptor URL for UPnP device
+	upnp_desc_url="wps_device.xml"
+}
Index: testbed_ap/netconfig.ui
===================================================================
--- testbed_ap/netconfig.ui	(revision 0)
+++ testbed_ap/netconfig.ui	(revision 2)
@@ -0,0 +1,183 @@
+<ui version="4.0" >
+ <class>NetConfig</class>
+ <widget class="QWidget" name="NetConfig" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>532</width>
+    <height>319</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>521</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Network Configuration</string>
+   </property>
+  </widget>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>511</width>
+     <height>261</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="margin" >
+     <number>0</number>
+    </property>
+    <property name="spacing" >
+     <number>12</number>
+    </property>
+    <item row="3" column="2" >
+     <widget class="QPushButton" name="pbGenNetKey" >
+      <property name="text" >
+       <string>Generate</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QLabel" name="label_5" >
+      <property name="text" >
+       <string>Network Key</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="0" >
+     <widget class="QLabel" name="label_2" >
+      <property name="text" >
+       <string>SSID</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="0" >
+     <widget class="QLabel" name="label_6" >
+      <property name="text" >
+       <string>State</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <widget class="QComboBox" name="cmbConfFlag" />
+    </item>
+    <item row="5" column="0" >
+     <widget class="QLabel" name="label_7" >
+      <property name="text" >
+       <string>Wireless Mode</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLineEdit" name="leSsid" >
+      <property name="maxLength" >
+       <number>32</number>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QLabel" name="label_3" >
+      <property name="text" >
+       <string>Authentication</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QLabel" name="label_4" >
+      <property name="text" >
+       <string>Encryption</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QComboBox" name="cmbEncr" />
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLineEdit" name="leNetKey" >
+      <property name="maxLength" >
+       <number>64</number>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QComboBox" name="cmbAuth" />
+    </item>
+    <item row="0" column="2" >
+     <widget class="QPushButton" name="pbGenSsid" >
+      <property name="text" >
+       <string>Generate</string>
+      </property>
+     </widget>
+    </item>
+    <item row="6" column="0" >
+     <widget class="QLabel" name="label_8" >
+      <property name="text" >
+       <string>Channel / Frequency</string>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="1" >
+     <layout class="QHBoxLayout" >
+      <property name="margin" >
+       <number>0</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QCheckBox" name="cb11a" >
+        <property name="text" >
+         <string>802.11 a</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QCheckBox" name="cb11gb" >
+        <property name="text" >
+         <string>802.11 g/b</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </item>
+    <item row="6" column="1" >
+     <widget class="QComboBox" name="cmbChannelList" />
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>leSsid</tabstop>
+  <tabstop>pbGenSsid</tabstop>
+  <tabstop>cmbAuth</tabstop>
+  <tabstop>cmbEncr</tabstop>
+  <tabstop>leNetKey</tabstop>
+  <tabstop>pbGenNetKey</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/wepkey.h
===================================================================
--- testbed_ap/wepkey.h	(revision 0)
+++ testbed_ap/wepkey.h	(revision 2)
@@ -0,0 +1,81 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wepkey.h
+//  Description: Setting WEP key header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WEPKEY_H
+#define WEPKEY_H
+
+#include "ui_wepkey.h"
+#include "pagetemplate.h"
+
+class TestbedAp;
+
+
+class WepKey:
+public PageTemplate, public Ui::WepKey
+{
+Q_OBJECT
+public:
+	WepKey(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~WepKey();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+private slots:
+	void selectKeyIndex(int index);
+	void selectKeyIndex1();
+	void selectKeyIndex2();
+	void selectKeyIndex3();
+	void selectKeyIndex4();
+	void generateWepKey(char *key);
+	void generateWepKey1();
+	void generateWepKey2();
+	void generateWepKey3();
+	void generateWepKey4();
+
+
+private:
+	char btoa(int b, bool capital = true);
+	bool checkInputs();
+
+private:
+	TestbedAp *wiz;
+};
+
+#endif // WEPKEY_H
+
Index: testbed_ap/debugwindow.ui
===================================================================
--- testbed_ap/debugwindow.ui	(revision 0)
+++ testbed_ap/debugwindow.ui	(revision 2)
@@ -0,0 +1,18 @@
+<ui version="4.0" >
+ <class>DebugWindow</class>
+ <widget class="QWidget" name="DebugWindow" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>568</width>
+    <height>207</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Debug Window</string>
+  </property>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/setupinterface.ui
===================================================================
--- testbed_ap/setupinterface.ui	(revision 0)
+++ testbed_ap/setupinterface.ui	(revision 2)
@@ -0,0 +1,208 @@
+<ui version="4.0" >
+ <class>SetupInterface</class>
+ <widget class="QWidget" name="SetupInterface" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>533</width>
+    <height>312</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QLabel" name="label" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>551</width>
+     <height>31</height>
+    </rect>
+   </property>
+   <property name="font" >
+    <font>
+     <pointsize>14</pointsize>
+     <weight>75</weight>
+     <bold>true</bold>
+    </font>
+   </property>
+   <property name="text" >
+    <string>Setup Interface</string>
+   </property>
+  </widget>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>50</y>
+     <width>511</width>
+     <height>202</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="leftMargin" >
+     <number>0</number>
+    </property>
+    <property name="topMargin" >
+     <number>0</number>
+    </property>
+    <property name="rightMargin" >
+     <number>0</number>
+    </property>
+    <property name="bottomMargin" >
+     <number>0</number>
+    </property>
+    <property name="horizontalSpacing" >
+     <number>12</number>
+    </property>
+    <property name="verticalSpacing" >
+     <number>12</number>
+    </property>
+    <item row="0" column="0" >
+     <widget class="QLabel" name="label_2" >
+      <property name="text" >
+       <string>wireless interface</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLineEdit" name="leWInterface" >
+      <property name="text" >
+       <string>ath0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QLabel" name="label_3" >
+      <property name="text" >
+       <string>wireless driver</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QLineEdit" name="leWDriver" >
+      <property name="enabled" >
+       <bool>false</bool>
+      </property>
+      <property name="text" >
+       <string>madwifi</string>
+      </property>
+      <property name="readOnly" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="0" >
+     <widget class="QLabel" name="label_4" >
+      <property name="text" >
+       <string>wired interface</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QLineEdit" name="leInterface2" >
+      <property name="text" >
+       <string>eth0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="0" >
+     <widget class="QCheckBox" name="cbNFCInterface" >
+      <property name="text" >
+       <string>NFC interface</string>
+      </property>
+      <property name="checked" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="1" >
+     <widget class="QLineEdit" name="leNFCInterface" >
+      <property name="text" >
+       <string>/dev/ttyUSB0</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="0" >
+     <widget class="QCheckBox" name="cbIPAddress" >
+      <property name="text" >
+       <string>IP address</string>
+      </property>
+      <property name="checked" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <layout class="QHBoxLayout" >
+      <property name="spacing" >
+       <number>12</number>
+      </property>
+      <property name="leftMargin" >
+       <number>0</number>
+      </property>
+      <property name="topMargin" >
+       <number>0</number>
+      </property>
+      <property name="rightMargin" >
+       <number>0</number>
+      </property>
+      <property name="bottomMargin" >
+       <number>0</number>
+      </property>
+      <item>
+       <widget class="QLineEdit" name="leIPAddress" >
+        <property name="text" >
+         <string>192.168.0.1</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLabel" name="label_6" >
+        <property name="text" >
+         <string>net mask</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLineEdit" name="leNetMask" >
+        <property name="text" >
+         <string>255.255.255.0</string>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QLabel" name="label_5" >
+      <property name="text" >
+       <string>bridge interface</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLineEdit" name="leInterface3" >
+      <property name="text" >
+       <string>br0</string>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <tabstops>
+  <tabstop>leWInterface</tabstop>
+  <tabstop>leWDriver</tabstop>
+  <tabstop>leInterface2</tabstop>
+  <tabstop>leInterface3</tabstop>
+  <tabstop>cbIPAddress</tabstop>
+  <tabstop>leIPAddress</tabstop>
+  <tabstop>leNetMask</tabstop>
+  <tabstop>cbNFCInterface</tabstop>
+  <tabstop>leNFCInterface</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/testbed_ap.conf
===================================================================
--- testbed_ap/testbed_ap.conf	(revision 0)
+++ testbed_ap/testbed_ap.conf	(revision 2)
@@ -0,0 +1,7 @@
+ath0
+madwifi
+eth1
+br0
+1,192.168.0.1,255.255.255.0
+1,/dev/ttyUSB0
+0,0
Index: testbed_ap/status.ui
===================================================================
--- testbed_ap/status.ui	(revision 0)
+++ testbed_ap/status.ui	(revision 2)
@@ -0,0 +1,190 @@
+<ui version="4.0" >
+ <class>Status</class>
+ <widget class="QWidget" name="Status" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>509</width>
+    <height>321</height>
+   </rect>
+  </property>
+  <property name="font" >
+   <font>
+    <pointsize>10</pointsize>
+   </font>
+  </property>
+  <property name="windowTitle" >
+   <string/>
+  </property>
+  <widget class="QWidget" name="gridLayout" >
+   <property name="geometry" >
+    <rect>
+     <x>10</x>
+     <y>10</y>
+     <width>491</width>
+     <height>183</height>
+    </rect>
+   </property>
+   <layout class="QGridLayout" >
+    <property name="leftMargin" >
+     <number>0</number>
+    </property>
+    <property name="topMargin" >
+     <number>0</number>
+    </property>
+    <property name="rightMargin" >
+     <number>0</number>
+    </property>
+    <property name="bottomMargin" >
+     <number>0</number>
+    </property>
+    <property name="horizontalSpacing" >
+     <number>6</number>
+    </property>
+    <property name="verticalSpacing" >
+     <number>6</number>
+    </property>
+    <item row="2" column="0" >
+     <widget class="QLabel" name="label_3" >
+      <property name="text" >
+       <string>Authentication</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="1" >
+     <widget class="QLabel" name="lblBssid" >
+      <property name="cursor" >
+       <cursorShape>ArrowCursor</cursorShape>
+      </property>
+      <property name="focusPolicy" >
+       <enum>Qt::NoFocus</enum>
+      </property>
+      <property name="text" >
+       <string>00:00:00:00:00:00</string>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="1" >
+     <widget class="QLabel" name="lblConfState" >
+      <property name="text" >
+       <string>TextLabel</string>
+      </property>
+     </widget>
+    </item>
+    <item row="0" column="0" >
+     <widget class="QLabel" name="label" >
+      <property name="text" >
+       <string>BSSID</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="1" >
+     <widget class="QLabel" name="lblEncr" >
+      <property name="text" >
+       <string>TextLabel</string>
+      </property>
+     </widget>
+    </item>
+    <item row="2" column="1" >
+     <widget class="QLabel" name="lblAuth" >
+      <property name="text" >
+       <string>TextLabel</string>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="0" >
+     <widget class="QLabel" name="label_2" >
+      <property name="text" >
+       <string>SSID</string>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="0" >
+     <widget class="QLabel" name="label_6" >
+      <property name="sizePolicy" >
+       <sizepolicy vsizetype="Preferred" hsizetype="Maximum" >
+        <horstretch>0</horstretch>
+        <verstretch>0</verstretch>
+       </sizepolicy>
+      </property>
+      <property name="text" >
+       <string>Configuration State</string>
+      </property>
+     </widget>
+    </item>
+    <item row="3" column="0" >
+     <widget class="QLabel" name="label_4" >
+      <property name="text" >
+       <string>Encryption</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="0" >
+     <widget class="QLabel" name="label_5" >
+      <property name="text" >
+       <string>Network Key</string>
+      </property>
+     </widget>
+    </item>
+    <item row="4" column="1" >
+     <widget class="QLineEdit" name="leNetKey" >
+      <property name="focusPolicy" >
+       <enum>Qt::ClickFocus</enum>
+      </property>
+      <property name="autoFillBackground" >
+       <bool>true</bool>
+      </property>
+      <property name="text" >
+       <string>LineEdit</string>
+      </property>
+      <property name="frame" >
+       <bool>true</bool>
+      </property>
+      <property name="cursorPosition" >
+       <number>0</number>
+      </property>
+      <property name="readOnly" >
+       <bool>true</bool>
+      </property>
+     </widget>
+    </item>
+    <item row="1" column="1" >
+     <widget class="QLabel" name="lblSsid" >
+      <property name="mouseTracking" >
+       <bool>false</bool>
+      </property>
+      <property name="contextMenuPolicy" >
+       <enum>Qt::DefaultContextMenu</enum>
+      </property>
+      <property name="text" >
+       <string>TextLabel</string>
+      </property>
+     </widget>
+    </item>
+    <item row="6" column="0" >
+     <widget class="QLabel" name="label_7" >
+      <property name="text" >
+       <string>IP Address</string>
+      </property>
+     </widget>
+    </item>
+    <item row="6" column="1" >
+     <widget class="QLabel" name="lblIpAddress" >
+      <property name="cursor" >
+       <cursorShape>ArrowCursor</cursorShape>
+      </property>
+      <property name="focusPolicy" >
+       <enum>Qt::NoFocus</enum>
+      </property>
+      <property name="text" >
+       <string>192.168.1.1</string>
+      </property>
+     </widget>
+    </item>
+   </layout>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
Index: testbed_ap/testbedap.h
===================================================================
--- testbed_ap/testbedap.h	(revision 0)
+++ testbed_ap/testbedap.h	(revision 2)
@@ -0,0 +1,101 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: testbedap.h
+//  Description: WiFi - Protected Setup external registar graphical user interface header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef TESTBEDAP_H
+#define TESTBEDAP_H
+
+#include "ui_testbedap.h"
+
+#include <QLinkedList>
+
+class PageTemplate;
+class SetupInterface;
+class NetConfig;
+class WepKey;
+class Status;
+class DebugWindow;
+
+
+class TestbedAp: public QMainWindow, public Ui::TestbedAp
+{
+Q_OBJECT
+public:
+	TestbedAp(QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~TestbedAp();
+
+public slots:
+	virtual void back();
+	virtual void next();
+	virtual void cancel();
+
+	virtual void close();
+	virtual void about();
+
+	void receiveMsgs();
+
+private slots:
+	void debugging();
+	void changeMode(int mode);
+
+	void writeConfigToken();
+	void startRegStaPbc();
+	void authRegSta();
+	void readConfigToken();
+	void startGetConfigPbc();
+	void authGetConfig();
+
+	bool startAuthentication();
+	bool stopAuthentication();
+	void increment();
+
+	void reset();
+	void restart();
+
+protected:
+	void closeEvent(QCloseEvent *);
+
+private:
+	QLinkedList<PageTemplate *> listPage;
+	SetupInterface *setupInterface;
+	NetConfig *netConfig;
+	WepKey *wepKey;
+	Status *status;
+	DebugWindow *debugWindow;
+
+	QTimer *timer;
+
+	void processCtrlRequest(char *buf, size_t len);
+};
+
+#endif // TESTBEDAP_H
Index: testbed_ap/setupinterface.cpp
===================================================================
--- testbed_ap/setupinterface.cpp	(revision 0)
+++ testbed_ap/setupinterface.cpp	(revision 2)
@@ -0,0 +1,386 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: setupinterface.cpp
+//  Description: setup interface source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "setupinterface.h"
+#include "mainprocess.h"
+#include "testbedap.h"
+#include "os.h"
+
+#include <QMessageBox>
+#include <QProcess>
+#include <QFile>
+
+
+SetupInterface::SetupInterface(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+#define CONFIG_FILE "./testbed_ap.conf"
+#define DEFAULT_WIRELESS_INTERFACE "ath0"
+#define DEFAULT_WIRELESS_DRIVER "madwifi"
+#define DEFAULT_WIRED_INTERFACE "eth0"
+#define DEFAULT_BRIDGE_INTERFACE "br0"
+#define DEFAULT_IPADDRESS "192.168.0.1"
+#define DEFAULT_NETMASK "255.255.255.0"
+#define DEFAULT_NFC_INTERFACE "/dev/ttyUSB0"
+	QFile *conf = new QFile(CONFIG_FILE);
+	bool read_file = false;
+	int index;
+
+	setupUi(this);
+
+	wiz = reinterpret_cast<TestbedAp *>(wizard);
+
+	QRegExp rx("[0-9]\\d{0,2}\\.[0-9]\\d{0,2}\\.[0-9]\\d{0,2}\\.[0-9]\\d{0,2}");
+	validator1 = new QRegExpValidator(rx, this);
+	leIPAddress->setValidator(validator1);
+	validator2 = new QRegExpValidator(rx, this);
+	leNetMask->setValidator(validator2);
+
+	if (conf && conf->exists() && conf->open(QIODevice::ReadOnly)) {
+		char line[BUFSIZ], *tmp, *tmp2;
+
+		MainProcess::setWirelessMode(MainProcess::WIRELESS_MODE_11AGB);
+		MainProcess::setChannelIndex(0);
+
+		index = 0;
+		while((6 >= index) && !conf->atEnd()) {
+			if (0 > conf->readLine(line, sizeof(line) - 1))
+				break;
+
+			if (0 != (tmp = os_strchr(line, '\n')))
+				*tmp = 0;
+
+			switch (index++) {
+			case 0: leWInterface->setText(line); break;
+			case 1: leWDriver->setText(line); break;
+			case 2: leInterface2->setText(line); break;
+			case 3: leInterface3->setText(line); break;
+			case 4:
+			{
+				if (0 != (tmp = os_strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					if (0 != (tmp2 = os_strchr(tmp, ','))) {
+						*tmp2 = 0;
+						tmp2++;
+					}
+					cbIPAddress->setChecked(atoi(line));
+					leIPAddress->setText(tmp);
+					if (tmp2)
+						leNetMask->setText(tmp2);
+					else
+						leNetMask->setText(DEFAULT_NETMASK);
+					leIPAddress->setEnabled(cbIPAddress->isChecked());
+					leNetMask->setEnabled(cbIPAddress->isChecked());
+				}
+				break;
+			}
+			case 5:
+			{
+				if (0 != (tmp = os_strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					cbNFCInterface->setChecked(atoi(line));
+					leNFCInterface->setText(tmp);
+				}
+				break;
+			}
+			case 6:
+			{
+				if (0 != (tmp = os_strchr(line, ','))) {
+					*tmp = 0;
+					tmp++;
+					MainProcess::setWirelessMode((MainProcess::WIRELESS_MODE)atoi(line));
+					MainProcess::setChannelIndex(atoi(tmp));
+				}
+			}
+			}
+		}
+		conf->close();
+
+		if (5 < index)
+			read_file = true;
+	}
+
+	if (conf)
+		delete conf;
+
+	if (!read_file) {
+		leWInterface->setText(DEFAULT_WIRELESS_INTERFACE);
+		leWDriver->setText(DEFAULT_WIRELESS_DRIVER);
+		leInterface2->setText(DEFAULT_WIRED_INTERFACE);
+		leInterface2->setText(DEFAULT_BRIDGE_INTERFACE);
+		cbIPAddress->setChecked(true);
+		leIPAddress->setText(DEFAULT_IPADDRESS);
+		leNetMask->setText(DEFAULT_NETMASK);
+		cbNFCInterface->setChecked(true);
+		leNFCInterface->setText(DEFAULT_NFC_INTERFACE);
+	}
+
+	connect(cbIPAddress, SIGNAL(clicked()), SLOT(enabledDhcp()));
+
+	cbIPAddress->setChecked(true);
+	cbIPAddress->setVisible(false);
+
+	QLabel *lblIPAddress = new QLabel("IP address");
+
+	gridLayout1->addWidget(lblIPAddress, 4, 0, 1, 1);
+
+	lblIPAddress->setText("IP address");
+
+#undef CONFIG_FILE
+#undef DEFAULT_WIRELESS_INTERFACE
+#undef DEFAULT_WIRELESS_DRIVER
+#undef DEFAULT_WIRED_INTERFACE
+#undef DEFAULT_BRIDGE_INTERFACE
+#undef DEFAULT_IPADDRESS
+#undef DEFAULT_NETMASK
+#undef DEFAULT_NFC_INTERFACE
+}
+
+SetupInterface::~SetupInterface()
+{
+	(void)end();
+
+	disconnect(cbIPAddress);
+
+	if (validator1)
+		delete validator1;
+	if (validator2)
+		delete validator2;
+}
+
+bool SetupInterface::pre_back()
+{
+	MainProcess::terminate();
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool SetupInterface::pre_next()
+{
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setEnabled(true);
+	wiz->pbCancel->setEnabled(true);
+	return true;
+}
+
+bool SetupInterface::post_next()
+{
+#define AP_START	"./ap_start"
+#define CONFIG_FILE "./testbed_ap.conf"
+	bool ret = false;
+	QProcess *prc = new QProcess(this);
+	char cmd[BUFSIZ];
+	QFile *conf = new QFile(CONFIG_FILE);
+	char line[BUFSIZ];
+
+	do {
+		if (!checkInputs()) {
+			QMessageBox::critical(this, label->text(), "Input error");
+			break;
+		}
+
+		os_snprintf(cmd, sizeof(cmd), "%s %s %s %s %s %s",
+					AP_START,
+					(const char *)leInterface3->text().toAscii(),
+					(const char *)leWInterface->text().toAscii(),
+					(const char *)leInterface2->text().toAscii(),
+					cbIPAddress->isChecked()?
+						(const char *)leIPAddress->text().toAscii():"dynamic",
+					cbIPAddress->isChecked()?
+						(const char *)leNetMask->text().toAscii():"255.255.255.0");
+		prc->start(cmd);
+		prc->waitForFinished(-1);
+		if(prc->exitCode()) {
+			QMessageBox::critical(this, label->text(), "Set interface error");
+			break;
+		}
+
+		if (conf && conf->open(QIODevice::WriteOnly)) {
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leWInterface->text().toAscii());
+			conf->write(line, os_strlen(line));
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leWDriver->text().toAscii());
+			conf->write(line, os_strlen(line));
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leInterface2->text().toAscii());
+			conf->write(line, os_strlen(line));
+			os_snprintf(line, sizeof(line), "%s\n",
+						(const char *)leInterface3->text().toAscii());
+			conf->write(line, os_strlen(line));
+			os_snprintf(line, sizeof(line), "%d,%s,%s\n",
+						cbIPAddress->isChecked()?1:0,
+						(const char *)leIPAddress->text().toAscii(),
+						(const char *)leNetMask->text().toAscii());
+			conf->write(line, os_strlen(line));
+			os_snprintf(line, sizeof(line), "%d,%s\n",
+						cbNFCInterface->isChecked()?1:0,
+						(const char *)leNFCInterface->text().toAscii());
+			conf->write(line, os_strlen(line));
+
+			os_snprintf(line, sizeof(line), "%d,%d\n",
+						MainProcess::getWirelessMode(),
+						MainProcess::getChannelIndex());
+			conf->write(line, os_strlen(line));
+		}
+		if (conf)
+			delete conf;
+
+		MainProcess::setWirelessInterface(leWInterface->text().toAscii());
+		MainProcess::setWirelessDriver(leWDriver->text().toAscii());
+		MainProcess::setWiredInterface(leInterface2->text().toAscii());
+		MainProcess::setBridgeInterface(leInterface3->text().toAscii());
+
+		MainProcess::setIpAddress(leIPAddress->text().toAscii());
+		MainProcess::setNetMask(leNetMask->text().toAscii());
+
+		MainProcess::setNfcInterface(leNFCInterface->text().toAscii());
+
+		ret = true;
+	} while (0);
+
+	if (prc) {
+		delete prc;
+		prc = 0;
+	}
+
+	return ret;
+#undef AP_START
+#undef CONFIG_FILE
+}
+
+bool SetupInterface::checkInputs()
+{
+	bool ret = false;
+	QString check1 = leIPAddress->text();
+	QString check2 = leNetMask->text();
+	int pos = 0;
+
+	do {
+		if (!leWInterface->text().length()) {
+			leWInterface->setFocus();
+			break;
+		}
+
+		if (!leInterface2->text().length()) {
+			leInterface2->setFocus();
+			break;
+		}
+
+		if (!leInterface3->text().length()) {
+			leInterface3->setFocus();
+			break;
+		}
+
+		if (cbIPAddress->isChecked() && 
+			(QValidator::Acceptable != validator1->validate(check1, pos))) {
+			leIPAddress->setFocus();
+			break;
+		}
+
+		if (cbIPAddress->isChecked() && 
+			(QValidator::Acceptable != validator2->validate(check2, pos))) {
+			leNetMask->setFocus();
+			break;
+		}
+
+		if (cbNFCInterface->isChecked() &&
+			!leNFCInterface->text().length()) {
+			leNFCInterface->setFocus();
+			break;
+		}
+
+		ret = true;
+	} while(0);
+	return ret;
+}
+
+void SetupInterface::cancel()
+{
+	wiz->close();
+}
+
+void SetupInterface::enabledDhcp()
+{
+	leIPAddress->setEnabled(cbIPAddress->isChecked());
+	leNetMask->setEnabled(cbIPAddress->isChecked());
+}
+
+const char *SetupInterface::getWirelessInterface()
+{
+	return (const char *)leWInterface->text().toAscii();
+}
+
+const char *SetupInterface::getWiredInterface()
+{
+	return (const char *)leInterface2->text().toAscii();
+}
+
+bool SetupInterface::end()
+{
+#define AP_END	"./ap_end"
+	bool ret = false;
+	QProcess *prc = new QProcess(this);
+	char cmd[BUFSIZ];
+
+	do {
+		if (!checkInputs()) {
+			break;
+		}
+
+		os_snprintf(cmd, sizeof(cmd), "%s %s %s %s",
+					AP_END,
+					(const char *)leInterface3->text().toAscii(),
+					(const char *)leWInterface->text().toAscii(),
+					(const char *)leInterface2->text().toAscii());
+		prc->start(cmd);
+		prc->waitForFinished(-1);
+
+		ret = true;
+	} while (0);
+
+	if (prc) {
+		delete prc;
+		prc = 0;
+	}
+
+	return ret;
+#undef AP_END
+}
+
Index: testbed_ap/netconfig.h
===================================================================
--- testbed_ap/netconfig.h	(revision 0)
+++ testbed_ap/netconfig.h	(revision 2)
@@ -0,0 +1,79 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: netconfig.h
+//  Description: Network configuration header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef NETCONFIG_H
+#define NETCONFIG_H
+
+#include "ui_netconfig.h"
+#include "pagetemplate.h"
+
+class TestbedAp;
+
+
+class NetConfig:
+public PageTemplate, public Ui::NetConfig
+{
+Q_OBJECT
+public:
+	NetConfig(QWidget *wizard, QWidget *parent = 0, Qt::WindowFlags f = 0);
+	~NetConfig();
+
+public:
+	bool pre_back();
+	bool pre_next();
+	void cancel();
+
+	bool post_next();
+
+	bool setChannelList(const char *list);
+
+	bool setChannel();
+
+private slots:
+	void selectAuth(int selected);
+	void generateSsid();
+	void generateNetKey();
+
+	void changeWirelessMode();
+
+private:
+	char btoa(int b, bool capital = true);
+	bool checkInputs();
+
+private:
+	TestbedAp *wiz;
+};
+
+#endif // NETCONFIG_H
+
Index: testbed_ap/status.cpp
===================================================================
--- testbed_ap/status.cpp	(revision 0)
+++ testbed_ap/status.cpp	(revision 2)
@@ -0,0 +1,219 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: status.cpp
+//  Description: Display status source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "pagetemplate.h"
+#include "status.h"
+#include "testbedap.h"
+#include "mainprocess.h"
+#include "os.h"
+
+#include <QMessageBox>
+#include <QTimer>
+
+
+Status::Status(QWidget *wizard, QWidget *parent /* = 0 */, Qt::WindowFlags f /* = 0 */)
+: PageTemplate(parent, f)
+{
+	wiz = reinterpret_cast<TestbedAp *>(wizard);
+	setupUi(this);
+
+	timer = new QTimer;
+	connect(timer, SIGNAL(timeout()), SLOT(update()));
+}
+
+Status::~Status()
+{
+	delete timer;
+}
+
+bool Status::pre_next()
+{
+	bool ret = false;
+
+	wiz->pbBack->setText("Set &Unconfigured State");
+	wiz->pbBack->setEnabled(false);
+	wiz->pbNext->setVisible(false);
+	wiz->pbCancel->setText("Exit");
+	wiz->pbCancel->setEnabled(true);
+
+	wiz->tabWidget->setEnabled(false);
+
+	do {
+		lblBssid->setText("");
+		lblSsid->setText("");
+		lblAuth->setText("");
+		lblEncr->setText("");
+		leNetKey->setText("");
+		lblConfState->setText("");
+		lblIpAddress->setText("");
+
+		QPalette p = leNetKey->palette();
+		p.setColor(QPalette::Normal, QPalette::Base,
+				   lblBssid->palette().color(QPalette::Normal, QPalette::Background));
+		p.setColor(QPalette::Inactive, QPalette::Base,
+				   lblBssid->palette().color(QPalette::Normal, QPalette::Background));
+		leNetKey->setPalette(p);
+		leNetKey->setAutoFillBackground(true);
+
+		timer->start(5000);
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void Status::cancel()
+{
+	timer->stop();
+	wiz->close();
+}
+
+bool Status::post_back()
+{
+	do {
+		if (!MainProcess::ctrlWpsState(MainProcess::WPS_STATE_NOTCONFIGURED)) {
+			QMessageBox::warning(this, label->text(),
+								 "Could not set configuration state\n");
+			break;
+		}
+
+		MainProcess::setWpsState(MainProcess::WPS_STATE_NOTCONFIGURED);
+	} while (0);
+
+	return false;
+}
+
+bool Status::post_next()
+{
+	timer->stop();
+
+	lblBssid->setText("");
+	lblSsid->setText("");
+	lblAuth->setText("");
+	lblEncr->setText("");
+	leNetKey->setText("");
+	lblConfState->setText("");
+	lblIpAddress->setText("");
+
+	return true;
+}
+
+void Status::update()
+{
+	bool ret = false;
+	char res[0x1000];
+	size_t len = sizeof(res) - 1;
+	char *start, *end, *pos;
+
+	do {
+		lblBssid->setText("");
+		lblSsid->setText("");
+		lblAuth->setText("");
+		lblEncr->setText("");
+		lblConfState->setText("");
+
+		if (!MainProcess::getStatus(res, &len)) {
+			break;
+		}
+
+		start = res;
+		while (*start) {
+			bool last = false;
+			end = os_strchr(start, '\n');
+			if (!end) {
+				last = true;
+				end = start;
+				while (end[0] && end[1])
+					end++;
+			}
+			*end = 0;
+
+			pos = os_strchr(start, '=');
+			if (pos) {
+				*pos++=0;
+				if (!os_strcmp(start, "bssid")) {
+					lblBssid->setText(pos);
+				} else if (!os_strcmp(start, "ssid")) {
+					lblSsid->setText(pos);
+				} else if (!os_strcmp(start, "key_mgmt")) {
+					lblAuth->setText(pos);
+				} else if (!os_strcmp(start, "encription")) {
+					lblEncr->setText(pos);
+				} else if (!os_strcmp(start, "wps_state")) {
+					lblConfState->setText(lblConfState->text() + pos);
+				} else if (!strcmp(start, "selected_registrar")) {
+					if (*pos && !os_strcmp(pos, "TRUE"))
+						lblConfState->setText(lblConfState->text() + " + SR");
+				} else if (!os_strcmp(start, "dev_pwd_id")) {
+					if (*pos)
+						lblConfState->setText(lblConfState->text() + " + " + pos);
+				} else if (!os_strcmp(start, "ip_address")) {
+					lblIpAddress->setText(pos);
+				}
+			}
+
+			if (last)
+				break;
+			start = end + 1;
+		}
+
+		if (!leNetKey->text().length()) {
+			if (MainProcess::AUTH_OPEN != MainProcess::getAuthType())
+				leNetKey->setText(MainProcess::getNetKey());
+			else if (MainProcess::ENCR_WEP == MainProcess::getEncrType())
+				leNetKey->setText(MainProcess::getWepKey(MainProcess::getWepKeyIndex()));
+			leNetKey->setCursorPosition(0);
+		}
+		if (!lblIpAddress->text().length()) {
+			lblIpAddress->setText(MainProcess::getIpAddress());
+		}
+
+		ret = true;
+	} while (0);
+
+	if (ret) {
+		wiz->tabWidget->setEnabled(true);
+		if (wiz->tabWidget->isTabEnabled(0) &&
+			wiz->tabWidget->isTabEnabled(1))
+			wiz->pbBack->setEnabled(true);
+	} else {
+		leNetKey->setText("");
+		lblIpAddress->setText("");
+
+		wiz->tabWidget->setEnabled(false);
+		wiz->pbBack->setEnabled(false);
+	}
+}
+
Index: testbed_ap/debugwindow.h
===================================================================
--- testbed_ap/debugwindow.h	(revision 0)
+++ testbed_ap/debugwindow.h	(revision 2)
@@ -0,0 +1,53 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: debugwindow.h
+//  Description: Debug window header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef DEBUGWINDOW_H
+#define DEBUGWINDOW_H
+
+#include "ui_debugwindow.h"
+
+#include <QTextEdit>
+
+class DebugWindow:
+public QWidget, public Ui::DebugWindow
+{
+Q_OBJECT
+public:
+	DebugWindow(QWidget *parent = 0, Qt::WindowFlags f = 0)
+		: QWidget(parent, f) {setupUi(this);};
+	~DebugWindow() {};
+	QTextEdit *textEdit;
+};
+
+#endif // DEBUGWINDOW_H
Index: testbed_ap/mainprocess.cpp
===================================================================
--- testbed_ap/mainprocess.cpp	(revision 0)
+++ testbed_ap/mainprocess.cpp	(revision 2)
@@ -0,0 +1,1596 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: mainprocess.cpp
+//  Description: main process control source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "mainprocess.h"
+#include "wpa_ctrl.h"
+#include "os.h"
+
+#include <QTemporaryFile>
+
+#define WAIT_FOR_PROCESS	3000 // [msec]
+
+#define HOSTAPD				"./hostapd"
+
+#define HOSTAPD_CTRL_DIR	"/var/run/hostapd"
+#define HOSTAPD_CONF		"./hostapd.conf"
+
+
+MainProcess::MainProcess()
+{
+}
+
+MainProcess::~MainProcess()
+{
+	terminate();
+
+	if (mtx) {
+		mtx->unlock();
+		delete mtx;
+		mtx = 0;
+	}
+
+	if (mainProcess) {
+		delete mainProcess;
+		mainProcess = 0;
+	}
+
+	if (iface) {
+		os_free(iface);
+		iface = 0;
+	}
+
+	if (wirelessInterface) {
+		os_free(wirelessInterface);
+		wirelessInterface = 0;
+	}
+
+	if (wirelessDriver) {
+		os_free(wirelessDriver);
+		wirelessDriver = 0;
+	}
+
+	if (wiredInterface) {
+		os_free(wiredInterface);
+		wiredInterface = 0;
+	}
+
+	if (bridgeInterface) {
+		os_free(bridgeInterface);
+		bridgeInterface = 0;
+	}
+
+	if (ipAddress) {
+		os_free(ipAddress);
+		ipAddress = 0;
+	}
+
+	if (netMask) {
+		os_free(netMask);
+		netMask = 0;
+	}
+
+	if (nfcInterface) {
+		os_free(nfcInterface);
+		nfcInterface = 0;
+	}
+}
+
+bool MainProcess::readConfigFile(char *filename /* = 0 */)
+{
+	bool ret = false;
+	QFile *conf = new QFile(!filename?HOSTAPD_CONF:filename);
+	char line[BUFSIZ];
+	char *pos, *var, *value;
+	qint64 end;
+
+	do {
+		if (!conf || !conf->exists())
+			break;
+
+		if (!conf->open(QIODevice::ReadOnly))
+			break;
+
+		os_memset(netKey, 0, sizeof(netKey));
+
+		while (!conf->atEnd()) {
+			if(-1 != (end = conf->readLine(line, sizeof(line)))) {
+				line[end] = 0;
+				pos = line;
+
+				while (*pos == ' ' || *pos == '\t' || *pos == '\r')
+					pos++;
+				if (*pos == '#' || *pos == '\n' || *pos == '\0' || *pos == '\r')
+					continue;
+
+				var = pos;
+				pos = os_strchr(var, '=');
+				if (pos) {
+					*pos++ = 0;
+					value = pos;
+					while (*pos != 0) {
+						if ((*pos == '\n') || (*pos == '\r')) {
+							*pos = 0;
+							break;
+						}
+						pos++;
+					}
+				} else
+					continue;
+
+				if (var && value) {
+					if (0 == os_strcmp(var, "interface")) {
+						if (wirelessInterface) {
+							os_free(wirelessInterface);
+							wirelessInterface = 0;
+						}
+						wirelessInterface = os_strdup(value);
+					} else if (0 == os_strcmp(var, "driver")) {
+						if (wirelessDriver) {
+							os_free(wirelessDriver);
+							wirelessDriver = 0;
+						}
+						wirelessDriver = os_strdup(value);
+					} else if (0 == os_strcmp(var, "bridge")) {
+						if (bridgeInterface) {
+							os_free(bridgeInterface);
+							bridgeInterface = 0;
+						}
+						bridgeInterface = os_strdup(value);
+					} else if (0 == os_strcmp(var, "own_ip_addr")) {
+						if (ipAddress) {
+							os_free(ipAddress);
+							ipAddress = 0;
+						}
+						ipAddress = os_strdup(value);
+					} else if (0 == os_strcmp(var, "nfc")) {
+						if (nfcInterface) {
+							os_free(nfcInterface);
+							nfcInterface = 0;
+						}
+						nfcInterface = os_strdup(value);
+					} else if (0 == os_strcmp(var, "ssid")) {
+						os_memset(ssid, 0, sizeof(ssid));
+						os_snprintf(ssid, sizeof(ssid), "%s", value);
+					} else if (0 == os_strcmp(var, "wpa")) {
+						authType = atoi(value);
+					} else if (0 == os_strcmp(var, "wpa_pairwise")) {
+						if (os_strstr(value, "CCMP"))
+							encrType = ENCR_CCMP;
+						else if (os_strstr(value, "TKIP"))
+							encrType = ENCR_TKIP;
+					} else if ((0 == os_strcmp(var, "wpa_psk")) ||
+							   (0 == os_strcmp(var, "wpa_passphrase"))) {
+						os_memset(netKey, 0, sizeof(netKey));
+						os_snprintf(netKey, sizeof(netKey), "%s", value);
+					} else if (0 == os_strcmp(var, "wep_default_key")) {
+						wepKeyIndex = atoi(value) + 1;
+						encrType = ENCR_WEP;
+					} else if (0 == os_strcmp(var, "wep_key0")) {
+						os_memset(&wepKey[0][0], 0, sizeof(wepKey[0]));
+						if (*value == '"') {
+							if (os_strrchr(value + 1, '"'))
+								*os_strrchr(value + 1, '"') = 0;
+							os_snprintf(&wepKey[0][0], sizeof(wepKey[0]), "%s", value + 1);
+						} else
+							os_snprintf(&wepKey[0][0], sizeof(wepKey[0]), "%s", value);
+					} else if (0 == os_strcmp(var, "wep_key1")) {
+						os_memset(&wepKey[1][0], 0, sizeof(wepKey[1]));
+						if (*value == '"') {
+							if (os_strrchr(value + 1, '"'))
+								*os_strrchr(value + 1, '"') = 0;
+							os_snprintf(&wepKey[1][0], sizeof(wepKey[1]), "%s", value + 1);
+						} else
+							os_snprintf(&wepKey[1][0], sizeof(wepKey[1]), "%s", value);
+					} else if (0 == os_strcmp(var, "wep_key2")) {
+						os_memset(&wepKey[2][0], 0, sizeof(wepKey[2]));
+						if (*value == '"') {
+							if (os_strrchr(value + 1, '"'))
+								*os_strrchr(value + 1, '"') = 0;
+							os_snprintf(&wepKey[2][0], sizeof(wepKey[2]), "%s", value + 1);
+						} else
+							os_snprintf(&wepKey[2][0], sizeof(wepKey[2]), "%s", value);
+					} else if (0 == os_strcmp(var, "wep_key3")) {
+						os_memset(&wepKey[3][0], 0, sizeof(wepKey[3]));
+						if (*value == '"') {
+							if (os_strrchr(value + 1, '"'))
+								*os_strrchr(value + 1, '"') = 0;
+							os_snprintf(&wepKey[3][0], sizeof(wepKey[3]), "%s", value + 1);
+						} else
+							os_snprintf(&wepKey[3][0], sizeof(wepKey[3]), "%s", value);
+					} else if (0 == os_strcmp(var, "wps_state")) {
+						wpsState = atoi(value);
+					}
+				}
+			}
+		}
+
+		ret = true;
+	} while (0);
+
+	if (conf) {
+		if (conf->isOpen())
+			conf->close();
+		delete conf;
+	}
+
+	return ret;
+}
+
+bool MainProcess::writeConfigFile()
+{
+	bool ret = false;
+	QFile *conf = new QFile(HOSTAPD_CONF);
+	QTemporaryFile *tmp = new QTemporaryFile();
+	char line[BUFSIZ], buf[BUFSIZ];
+	char *pos, *var, *value, *pos2;
+	qint64 end;
+	int remain;
+	bool setWirelessInterface = false, setWirelessDriver = false,
+		 setNfcInterface = false, setBridgeInterface = false, setIpAddress = false,
+		 setSsid = false, setAuth = false, setEncr = false,
+		 setKeyMgmt = false, setNetKey = false,
+		 setWepKeyIndex = false, setWepKey[4] = {false, false, false, false},
+		 setWpsState = false, setHwMode = false, setChan = false;
+
+	do {
+		if (!conf || !conf->exists())
+			break;
+
+		if (!conf->open(QIODevice::ReadOnly))
+			break;
+
+		if (!tmp->open())
+			break;
+
+		while (!conf->atEnd()) {
+			if(-1 != (end = conf->readLine(line, sizeof(line)))) {
+				do {
+					line[end] = 0;
+					os_snprintf(buf, sizeof(buf), "%s", line);
+					pos = buf;
+
+					while (*pos == ' ' || *pos == '\t' || *pos == '\r')
+						pos++;
+					if (*pos == '#' || *pos == '\n' || *pos == '\0' || *pos == '\r')
+						break;
+
+					var = pos;
+					pos = os_strchr(var, '=');
+					if (pos) {
+						*pos++ = 0;
+						value = pos;
+						while (*pos != 0) {
+							if ((*pos == '\n') || (*pos == '\r')) {
+								*pos = 0;
+								break;
+							}
+							pos++;
+						}
+					} else
+						break;
+
+					if (var && value) {
+						pos2 = line + (value - buf);
+						remain = sizeof(line) - (pos2 - line);
+						if (0 == os_strcmp(var, "interface")) {
+							if (wirelessInterface)
+								os_snprintf(pos2, remain, "%s\n", wirelessInterface);
+							setWirelessInterface = true;
+						} else if (0 == os_strcmp(var, "driver")) {
+							if (wirelessDriver)
+								os_snprintf(pos2, remain, "%s\n", wirelessDriver);
+							setWirelessDriver = true;
+						} else if (0 == os_strcmp(var, "bridge")) {
+							if (bridgeInterface)
+								os_snprintf(pos2, remain, "%s\n", bridgeInterface);
+							setBridgeInterface = true;
+						} else if (0 == os_strcmp(var, "own_ip_addr")) {
+							if (ipAddress)
+								os_snprintf(pos2, remain, "%s\n", ipAddress);
+							setIpAddress = true;
+						} else if (0 == os_strcmp(var, "nfc")) {
+							if (nfcInterface)
+								os_snprintf(pos2, remain, "%s\n", nfcInterface);
+							setNfcInterface = true;
+						} else if (0 == os_strcmp(var, "hw_mode")) {
+							if ((channel > 14) && (channel <= 64))
+								os_snprintf(pos2, remain, "a\n");
+							else
+								os_snprintf(pos2, remain, "g\n");
+							setHwMode = true;
+						} else if (0 == os_strcmp(var, "channel")) {
+							if ((channel <= 0) || (channel > 64))
+								channel = 1;
+							os_snprintf(pos2, remain, "%d\n", channel);
+							setChan = true;
+						} else if (0 == os_strcmp(var, "ssid")) {
+							os_snprintf(pos2, remain, "%s\n", ssid);
+							setSsid = true;
+						} else if (0 == os_strcmp(var, "wpa")) {
+							os_snprintf(pos2, remain, "%d\n", authType);
+							setAuth = true;
+						} else if (0 == os_strcmp(var, "wpa_key_mgmt")) {
+							switch (authType) {
+							case AUTH_OPEN:
+								line[0] = 0;
+								break;
+							case AUTH_WPA:
+							case AUTH_WPA2:
+								os_snprintf(pos2, remain, "WPA-PSK\n");
+								break;
+							}
+							setKeyMgmt = true;
+						} else if (0 == os_strcmp(var, "wpa_pairwise")) {
+							if (0 < authType) {
+								switch (encrType) {
+								case ENCR_TKIP:
+									os_snprintf(pos2, remain, "TKIP\n");
+									break;
+								case ENCR_CCMP:
+									os_snprintf(pos2, remain, "CCMP\n");
+									break;
+								default:
+									line[0] = 0;
+									break;
+								}
+							} else
+								line[0] = 0;
+							setEncr = true;
+						} else if (0 == os_strcmp(var, "wpa_psk")) {
+							if ((AUTH_OPEN != authType) && !setNetKey) {
+								if (64 == os_strlen(netKey))
+									os_snprintf(pos2, remain, "%s\n", netKey);
+								else
+									os_snprintf(line, sizeof(line), "wpa_passphrase=%s\n", netKey);
+								setNetKey = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wpa_passphrase")) {
+							if ((AUTH_OPEN != authType) && !setNetKey) {
+								if (64 == os_strlen(netKey))
+									os_snprintf(line, sizeof(line), "wpa_psk=%s\n", netKey);
+								else
+									os_snprintf(pos2, remain, "%s\n", netKey);
+								setNetKey = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wep_default_key")) {
+							if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType) &&
+								!setWepKeyIndex) {
+								os_snprintf(pos2, remain, "%d\n", wepKeyIndex - 1);
+								setWepKeyIndex = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wep_key0")) {
+							if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType) &&
+								!setWepKey[0]) {
+								if (os_strlen(wepKey[0])) {
+									if ((5 == os_strlen(wepKey[0])) || (13 == os_strlen(wepKey[0])))
+										os_snprintf(pos2, remain, "\"%s\"\n", wepKey[0]);
+									else
+										os_snprintf(pos2, remain, "%s\n", wepKey[0]);
+								} else
+									line[0] = 0;
+								setWepKey[0] = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wep_key1")) {
+							if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType) &&
+								!setWepKey[1]) {
+								if (os_strlen(wepKey[1])) {
+									if ((5 == os_strlen(wepKey[1])) || (13 == os_strlen(wepKey[1])))
+										os_snprintf(pos2, remain, "\"%s\"\n", wepKey[1]);
+									else
+										os_snprintf(pos2, remain, "%s\n", wepKey[1]);
+								} else
+									line[0] = 0;
+								setWepKey[1] = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wep_key2")) {
+							if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType) &&
+								!setWepKey[2]) {
+								if (os_strlen(wepKey[2])) {
+									if ((5 == os_strlen(wepKey[2])) || (13 == os_strlen(wepKey[2])))
+										os_snprintf(pos2, remain, "\"%s\"\n", wepKey[2]);
+									else
+										os_snprintf(pos2, remain, "%s\n", wepKey[2]);
+								} else
+									line[0] = 0;
+								setWepKey[2] = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wep_key3")) {
+							if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType) &&
+								!setWepKey[3]) {
+								if (os_strlen(wepKey[3])) {
+									if ((5 == os_strlen(wepKey[3])) || (13 == os_strlen(wepKey[3])))
+										os_snprintf(pos2, remain, "\"%s\"\n", wepKey[3]);
+									else
+										os_snprintf(pos2, remain, "%s\n", wepKey[3]);
+								} else
+									line[0] = 0;
+								setWepKey[3] = true;
+							} else
+								line[0] = 0;
+						} else if (0 == os_strcmp(var, "wps_state")) {
+							os_snprintf(pos2, remain, "%d\n", wpsState);
+							setWpsState = true;
+						}
+					}
+				} while (0);
+
+				if (line[0])
+					tmp->write(line, os_strlen(line));
+			}
+		}
+
+		if (!setWirelessInterface && wirelessInterface) {
+			os_snprintf(line, sizeof(line), "interface=%s\n", wirelessInterface);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setWirelessDriver && wirelessDriver) {
+			os_snprintf(line, sizeof(line), "driver=%s\n", wirelessDriver);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setBridgeInterface && bridgeInterface) {
+			os_snprintf(line, sizeof(line), "bridge=%s\n", bridgeInterface);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setIpAddress && ipAddress) {
+			os_snprintf(line, sizeof(line), "own_ip_addr=%s\n", ipAddress);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setNfcInterface && nfcInterface) {
+			os_snprintf(line, sizeof(line), "nfc=%s\n", nfcInterface);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setSsid && ssid) {
+			os_snprintf(line, sizeof(line), "ssid=%s\n", ssid);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setAuth) {
+			os_snprintf(line, sizeof(line), "wpa=%d\n", authType);
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setEncr && (AUTH_OPEN != authType)) {
+			switch (encrType) {
+			case ENCR_TKIP:
+				os_snprintf(line, sizeof(line), "wpa_pairwise=TKIP\n");
+				break;
+			case ENCR_CCMP:
+				os_snprintf(line, sizeof(line), "wpa_pairwise=CCMP\n");
+				break;
+			default:
+				line[0] = 0;
+				break;
+			}
+			if (line[0])
+				tmp->write(line, os_strlen(line));
+		}
+		if (!setKeyMgmt && (AUTH_OPEN != authType)) {
+			os_snprintf(line, sizeof(line), "wpa_key_mgmt=WPA-PSK\n");
+			tmp->write(line, os_strlen(line));
+		}
+		if (!setNetKey && (AUTH_OPEN != authType) && os_strlen(netKey)) {
+			if (64 == os_strlen(netKey))
+				os_snprintf(line, sizeof(line), "wpa_psk=%s\n", netKey);
+			else
+				os_snprintf(line, sizeof(line), "wpa_passphrase=%s\n", netKey);
+			tmp->write(line, os_strlen(line));
+		}
+		if ((AUTH_OPEN == authType) && (ENCR_WEP == encrType)) {
+			int index;
+			if (!setWepKeyIndex) {
+				os_snprintf(line, sizeof(line), "wep_default_key=%d\n", wepKeyIndex - 1);
+				tmp->write(line, os_strlen(line));
+			}
+			for (index = 0; index < 4; index++) {
+				if (!setWepKey[index] && os_strlen(wepKey[index])) {
+					if ((5 == os_strlen(wepKey[index])) || (13 == os_strlen(wepKey[index])))
+						os_snprintf(line, sizeof(line), "wep_key%d=\"%s\"\n", index, wepKey[index]);
+					else
+						os_snprintf(line, sizeof(line), "wep_key%d=%s\n", index, wepKey[index]);
+					tmp->write(line, os_strlen(line));
+				}
+			}
+		}
+		if (!setHwMode) {
+			if ((channel > 14) && (channel <= 64))
+				os_snprintf(line, sizeof(line), "hw_mode=a\n");
+			else
+				os_snprintf(line, sizeof(line), "hw_mode=g\n");
+		}
+		if (!setChan) {
+			if ((channel <= 0) || (channel > 64))
+				channel = 1;
+			os_snprintf(line, sizeof(line), "channel=%d\n", channel);
+		}
+
+		ret = true;
+	} while (0);
+
+	if (conf) {
+		if (conf->isOpen())
+			conf->close();
+		if (ret)
+			conf->remove();
+		delete conf;
+	}
+
+	if (tmp) {
+		if (tmp->isOpen())
+			tmp->close();
+		tmp->setPermissions((QFile::Permissions)0x6644);
+		if (ret) {
+			if (!tmp->copy(HOSTAPD_CONF))
+				ret = false;
+		}
+		delete tmp;
+		if (ret && !setWpsState) {
+			ret = false;
+			conf = new QFile(HOSTAPD_CONF);
+			tmp = new QTemporaryFile();
+
+			do {
+				if (!conf || !conf->exists())
+					break;
+
+				if (!conf->open(QIODevice::ReadOnly))
+					break;
+
+				if (!tmp->open())
+					break;
+
+				while (!conf->atEnd()) {
+					if(-1 != (end = conf->readLine(line, sizeof(line)))) {
+						do {
+							line[end] = 0;
+							os_snprintf(buf, sizeof(buf), "%s", line);
+							pos = buf;
+
+							while (*pos == ' ' || *pos == '\t' || *pos == '\r')
+								pos++;
+							if (*pos == '#' || *pos == '\n' || *pos == '\0' || *pos == '\r')
+								break;
+
+							var = pos;
+							pos = os_strchr(var, '=');
+							if (pos) {
+								*pos++ = 0;
+								value = pos;
+								while (*pos != 0) {
+									if ((*pos == '\n') || (*pos == '\r')) {
+										*pos = 0;
+										break;
+									}
+									pos++;
+								}
+							} else
+								break;
+
+							if (var && (0 == os_strcmp(var, "wps_property"))) {
+								tmp->write(line, os_strlen(line));
+								if (!wpsState) {
+									os_snprintf(line, sizeof(line), "wps_state=%d\n", wpsState);
+									tmp->write(line, os_strlen(line));
+								}
+								line[0] = 0;
+							}
+						} while (0);
+
+						if (line[0])
+							tmp->write(line, os_strlen(line));
+					}
+				}
+				ret = true;
+			} while (0);
+
+			if (conf) {
+				if (conf->isOpen())
+					conf->close();
+				if (ret)
+					conf->remove();
+				delete conf;
+			}
+
+			if (tmp) {
+				if (tmp->isOpen())
+					tmp->close();
+				tmp->setPermissions((QFile::Permissions)0x6644);
+				if (ret){
+					if (!tmp->copy(HOSTAPD_CONF))
+						ret = false;
+				}
+				delete tmp;
+			}
+		}
+	}
+	return ret;
+}
+
+bool MainProcess::setDebugOut(QObject *receiver, const char *method)
+{
+	bool ret = false;
+
+	do {
+		if (!mainProcess)
+			break;
+
+		mainProcess->setReadChannel(QProcess::StandardOutput);
+		mainProcess->setProcessChannelMode(QProcess::MergedChannels);
+		QObject::connect(mainProcess, SIGNAL(readyReadStandardOutput()),
+						 receiver, method);
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+QString MainProcess::readDebugMsg()
+{
+	QString out = "";
+	do {
+		if (!mainProcess)
+			break;
+		out = mainProcess->readLine();
+	} while (0);
+
+	return out;
+}
+
+bool MainProcess::start()
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+
+	do {
+		terminate();
+		if (!mainProcess)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "%s %s -ddd", HOSTAPD, HOSTAPD_CONF);
+		mainProcess->start(cmd);
+		if (!mainProcess->waitForStarted(WAIT_FOR_PROCESS))
+			break;
+
+		iface = os_strdup(wirelessInterface);
+
+		srand(time(0));
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+void MainProcess::terminate()
+{
+	QProcess *rem = new QProcess();
+	char remCmd[BUFSIZ];
+
+	if (mainProcess &&
+		(QProcess::NotRunning != mainProcess->state())) {
+
+		disconnectMonitor(0, 0);
+
+		if (ctrl) {
+			wpa_ctrl_close(ctrl);
+			ctrl = 0;
+		}
+
+		mainProcess->terminate();
+		if (!mainProcess->waitForFinished(WAIT_FOR_PROCESS)) {
+			mainProcess->kill();
+		}
+
+		os_snprintf(remCmd, sizeof(remCmd), "rem -rf %s",
+					HOSTAPD_CTRL_DIR);
+		rem->start(remCmd);
+		rem->waitForFinished(-1);
+		delete rem;
+		rem = 0;
+	}
+
+	if (iface) {
+		os_free(iface);
+		iface = 0;
+	}
+}
+
+#if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+bool MainProcess::connectMonitor(QObject *receiver, const char *method)
+{ bool ret = false;
+	char monitor_iface[BUFSIZ];
+
+	do {
+		if (!receiver || !method)
+			break;
+
+		if (msgNotifier) {
+			delete msgNotifier;
+			msgNotifier = 0;
+		}
+
+		if (!monitor) {
+			os_snprintf(monitor_iface, sizeof(monitor_iface), "%s/%s",
+						HOSTAPD_CTRL_DIR, iface);
+			monitor = wpa_ctrl_open(monitor_iface);
+			if (!monitor)
+				break;
+			if (wpa_ctrl_attach(monitor))
+				break;
+		}
+
+		msgNotifier = new QSocketNotifier(wpa_ctrl_get_fd(monitor),
+										  QSocketNotifier::Read, 0);
+		if (!msgNotifier)
+			break;
+
+		ret = QObject::connect(msgNotifier, SIGNAL(activated(int)), receiver, method);
+	} while (0);
+
+	if (!ret) {
+		printf("Could not connect with monitor.\n");
+		disconnectMonitor(receiver, method);
+	}
+
+	return ret;
+}
+
+bool MainProcess::disconnectMonitor(QObject *receiver, const char *method)
+{
+	if (msgNotifier && receiver && method)
+		QObject::disconnect(msgNotifier, SIGNAL(activated(int)), receiver, method);
+
+	if (msgNotifier) {
+		delete msgNotifier;
+		msgNotifier = 0;
+	}
+
+	if (monitor) {
+		wpa_ctrl_detach(monitor);
+		wpa_ctrl_close(monitor);
+		monitor = 0;
+	}
+
+	return true;
+}
+#endif // defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
+
+bool MainProcess::ctrlPending()
+{
+	return (monitor && (0 < wpa_ctrl_pending(monitor)));
+}
+
+bool MainProcess::receive(char *msg, size_t *len)
+{
+	int ret = false;
+	do {
+		if (!monitor || !msg || !len)
+			break;
+
+		ret = (0 == wpa_ctrl_recv(monitor, msg, len));
+		if (ret)
+			msg[*len] = 0;
+	} while (0);
+
+	return ret;
+}
+
+bool MainProcess::getCtrlRequelst(char *buf, size_t len, int *priority, char *req, char *msg)
+{
+	bool ret = false;
+	char *pos = buf, *pos2;
+	size_t req_len;
+
+	do {
+		if (!buf || !len)
+			break;
+
+		if (req) *req = 0;
+		if (msg) *msg = 0;
+
+		if (*pos == '<') {
+			pos++;
+			if (priority)
+				*priority = atoi(pos);
+			pos = os_strchr(pos, '>');
+			if (pos)
+				pos++;
+			else
+				pos = buf;
+		}
+
+		if (os_strncmp(pos, "CTRL-", 5) == 0) {
+			pos2 = os_strchr(pos, !os_strncmp(pos, WPA_CTRL_REQ, os_strlen(WPA_CTRL_REQ))?':':' ');
+			if (pos2) {
+				pos2++;
+				if (req) {
+					req_len = pos2 - (pos + os_strlen(WPA_CTRL_REQ) + 1);
+					os_strncpy(req, pos + os_strlen(WPA_CTRL_REQ), req_len);
+					req[req_len] = 0;
+				}
+				if (msg) {
+					os_strncpy(msg, pos2, os_strlen(pos2));
+					msg[os_strlen(pos2)] = 0;
+				}
+			} else {
+				pos2 = pos;
+				if (req)
+					*req = 0;
+				if (msg) {
+					os_strncpy(msg, pos2 + os_strlen(WPA_CTRL_REQ), os_strlen(pos2 + os_strlen(WPA_CTRL_REQ)));
+					msg[os_strlen(pos2 + os_strlen(WPA_CTRL_REQ))] = 0;
+				}
+			}
+		} else {
+			os_strncpy(msg, pos, os_strlen(pos));
+			msg[os_strlen(pos)] = 0;
+		}
+
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+int MainProcess::ctrlRequest(char *cmd, char *res, size_t *len)
+{
+	int ret = 0;
+	char ctrl_iface[BUFSIZ];
+
+	do {
+		os_snprintf(ctrl_iface, sizeof(ctrl_iface), "%s/%s",
+					HOSTAPD_CTRL_DIR, iface);
+
+		if (!ctrl) {
+			ctrl = wpa_ctrl_open(ctrl_iface);
+			if (!ctrl) {
+				ret = -3;
+				break;
+			}
+		}
+
+		if (mtx)
+			mtx->lock();
+
+		ret = wpa_ctrl_request(ctrl, cmd, os_strlen(cmd), res, len, 0);
+		if (0 > ret) {
+			wpa_ctrl_close(ctrl);
+			ctrl = 0;
+		}
+
+		if (mtx)
+			mtx->unlock();
+	} while (0);
+
+	if (0 > ret)
+		printf("Fail control-request : %d.\n", ret);
+
+	return ret;
+}
+
+void MainProcess::closeCtrl()
+{
+	if (ctrl) {
+		wpa_ctrl_close(ctrl);
+		ctrl = 0;
+	}
+}
+
+bool MainProcess::reload()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("RECONFIGURE", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to reload configuration.\n");
+
+	return ret;
+}
+
+bool MainProcess::getStatus(char *result, size_t *len)
+{
+	bool ret = false;
+
+	do {
+		if (!result && !len)
+			break;
+
+		if (0 > ctrlRequest("STATUS", result, len))
+			break;
+		result[*len] = 0;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to get status.\n");
+
+	return ret;
+}
+
+bool MainProcess::setRegMode(int regmode)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "WPS_SET_REGMODE %d", regmode);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::setWpsPassword(const char *pwd)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "WPS_SET_PASSWORD %s", pwd?pwd:"");
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to set WPS password.\n");
+
+	return ret;
+}
+
+bool MainProcess::clearWpsPassword()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WPS_CLEAR_PASSWORD", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to clear WPS password.\n");
+
+	return ret;
+}
+
+bool MainProcess::ctrlWpsState(uchar state)
+{
+	bool ret = false;
+	char cmd[BUFSIZ];
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "SET_WPS_STATE %d", state);
+		if (0 > ctrlRequest(cmd, res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to set WPS state.\n");
+
+	return ret;
+}
+
+bool MainProcess::writeNfcConfig()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WRITE_CONFIG_TOKEN", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::readNfcConfig()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("READ_CONFIG_TOKEN", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::writeNfcPassword()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WRITE_PASSWORD_TOKEN", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::readNfcPassword()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("READ_PASSWORD_TOKEN", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to scan NFC token request.\n");
+
+	return ret;
+}
+
+bool MainProcess::cancelScanNfcToken()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("CANCEL_NFC_COMMAND", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to cancel NFC command.\n");
+
+	return ret;
+}
+
+bool MainProcess::startPbc()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		len = sizeof(res) - 1;
+		if (0 > ctrlRequest("WPS_PBC_ENABLED 1", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to start PBC method.\n");
+
+	return ret;
+}
+
+bool MainProcess::stopPbc()
+{
+	bool ret = false;
+	char res[BUFSIZ];
+	size_t len = sizeof(res) - 1;
+
+	do {
+		if (0 > ctrlRequest("WPS_PBC_ENABLED 0", res, &len))
+			break;
+
+		if (os_strncmp(res, "OK", 2))
+			break;
+
+		ret = true;
+	} while (0);
+
+	if (!ret)
+		printf("Fail to stop PBC method.\n");
+
+	return ret;
+}
+
+void MainProcess::generatePIN(char pwd[9])
+{
+	unsigned long pin;
+	unsigned char checksum;
+	unsigned long acc = 0;
+	unsigned long tmp;
+
+	if (!pwd) {
+		printf("Could not generate PIN with NULL-pointer.\n");
+		return;
+	}
+
+	pin = rand() % 10000000;
+	tmp = pin * 10;
+
+	acc += 3 * ((tmp / 10000000) % 10);
+	acc += 1 * ((tmp / 1000000) % 10);
+	acc += 3 * ((tmp / 100000) % 10);
+	acc += 1 * ((tmp / 10000) % 10);
+	acc += 3 * ((tmp / 1000) % 10);
+	acc += 1 * ((tmp / 100) % 10);
+	acc += 3 * ((tmp / 10) % 10);
+
+	checksum = (unsigned char)(10 - (acc % 10)) % 10;
+	os_snprintf(pwd, 9, "%08lu", pin * 10 + checksum);
+}
+
+bool MainProcess::validatePIN(const char pwd[9])
+{
+	bool ret = true;
+	unsigned long pin, check;
+	unsigned char checksum;
+	unsigned long acc = 0;
+	char *tmp = 0;
+
+	do {
+		pin = strtol(pwd, &tmp, 10);
+		if (!tmp || *tmp)
+			break;
+		check = (pin / 10) * 10;
+		acc += 3 * ((check / 10000000) % 10);
+		acc += 1 * ((check / 1000000) % 10);
+		acc += 3 * ((check / 100000) % 10);
+		acc += 1 * ((check / 10000) % 10);
+		acc += 3 * ((check / 1000) % 10);
+		acc += 1 * ((check / 100) % 10);
+		acc += 3 * ((check / 10) % 10);
+		checksum = (unsigned char)(10 - (acc % 10)) % 10;
+
+		if (checksum != (unsigned char)atoi(&pwd[7]))
+			ret = false;
+	} while (0);
+
+	return ret;
+}
+
+void MainProcess::setWirelessInterface(const char *ifname) {
+	if (wirelessInterface) {
+		os_free(wirelessInterface);
+		wirelessInterface = 0;
+	}
+	if (ifname)
+		wirelessInterface = os_strdup(ifname);
+}
+
+char *MainProcess::getWirelessInterface()
+{
+	return wirelessInterface;
+}
+
+void MainProcess::setWirelessDriver(const char *driver) {
+	if (wirelessDriver) {
+		os_free(wirelessDriver);
+		wirelessDriver = 0;
+	}
+	if (driver)
+		wirelessDriver = os_strdup(driver);
+}
+
+char *MainProcess::setWirelessDriver()
+{
+	return wirelessDriver;
+};
+
+void MainProcess::setWiredInterface(const char *ifname)
+{
+	if (wiredInterface) {
+		os_free(wiredInterface);
+		wiredInterface = 0;
+	}
+	if (ifname)
+		wiredInterface = os_strdup(ifname);
+}
+
+char *MainProcess::getWiredInterface()
+{
+	return wiredInterface;
+}
+
+void MainProcess::setBridgeInterface(const char *ifname)
+{
+	if (bridgeInterface) {
+		os_free(bridgeInterface);
+		bridgeInterface = 0;
+	}
+	if (ifname)
+		bridgeInterface = os_strdup(ifname);
+}
+
+char *MainProcess::getBridgeInterface()
+{
+	return bridgeInterface;
+}
+
+void MainProcess::setIpAddress(const char *ipAddr)
+{
+	if (ipAddress) {
+		os_free(ipAddress);
+		ipAddress = 0;
+	}
+	if (ipAddr)
+		ipAddress = os_strdup(ipAddr);
+}
+
+char *MainProcess::getIpAddress()
+{
+	return ipAddress;
+}
+
+void MainProcess::setNetMask(const char *_netMask)
+{
+	if (netMask) {
+		os_free(netMask);
+		netMask = 0;
+	}
+	if (_netMask)
+		netMask = os_strdup(_netMask);
+}
+
+char *MainProcess::getNetMask()
+{
+	return netMask;
+}
+
+void MainProcess::setNfcInterface(const char *ifname)
+{
+	if (nfcInterface) {
+		os_free(nfcInterface);
+		nfcInterface = 0;
+	}
+	if (ifname)
+		nfcInterface = os_strdup(ifname);
+}
+
+char *MainProcess::getNfcInterface()
+{
+	return nfcInterface;
+}
+
+void MainProcess::setSsid(const char *_ssid)
+{
+	os_memset(ssid, 0, sizeof(ssid));
+	if (_ssid)
+		os_snprintf(ssid, sizeof(ssid), "%s", _ssid);
+}
+
+const char *MainProcess::getSsid()
+{
+	return ssid;
+}
+void MainProcess::setAuthType(ushort auth)
+{
+	authType = auth;
+}
+
+ushort MainProcess::getAuthType()
+{
+	return authType;
+}
+
+void MainProcess::setEncrType(ushort encr)
+{
+	encrType = encr;
+}
+
+ushort MainProcess::getEncrType()
+{
+	return encrType;
+}
+
+void MainProcess::setNetKey(const char *key)
+{
+	os_memset(netKey, 0, sizeof(netKey));
+	if (key)
+		os_snprintf(netKey, sizeof(netKey), "%s", key);
+}
+
+const char *MainProcess::getNetKey()
+{
+	return netKey;
+}
+
+void MainProcess::setWepKeyIndex(ushort index)
+{
+	if ((0 < index) && (4 >= index))
+		wepKeyIndex = index;
+}
+
+ushort MainProcess::getWepKeyIndex()
+{
+	return wepKeyIndex;
+}
+
+void MainProcess::setWepKey(ushort index, const char *key)
+{
+	if ((0 < index) && (4 >= index)) {
+		os_memset(wepKey[index - 1], 0, sizeof(wepKey[0]));
+		if (key)
+			os_snprintf(&wepKey[index - 1][0], sizeof(wepKey[index - 1]), "%s", key);
+	}
+}
+
+const char *MainProcess::getWepKey(ushort index)
+{
+	if (!index || (4 < index))
+		return NULL;
+	else
+		return &wepKey[index -1][0];
+}
+
+void MainProcess::setWpsState(uchar state)
+{
+	wpsState = state;
+}
+
+uchar MainProcess::getWpsState()
+{
+	return wpsState;
+}
+
+const char *MainProcess::getChannelList(WIRELESS_MODE _mode)
+{
+	QProcess *iwlist = 0;
+	char cmd[BUFSIZ];
+	QString out = "";
+	QStringList list;
+	QStringList::Iterator it;
+	bool first = true;
+	int _channel;
+
+	do {
+		if (channelList) {
+			os_free(channelList);
+			channelList = 0;
+		}
+
+		iwlist = new QProcess;
+		if (!iwlist)
+			break;
+		iwlist->setReadChannel(QProcess::StandardOutput);
+		iwlist->setProcessChannelMode(QProcess::MergedChannels);
+
+		os_snprintf(cmd, sizeof(cmd), "iwlist %s channel", wirelessInterface);
+		iwlist->start(cmd);
+		if (!iwlist->waitForFinished(WAIT_FOR_PROCESS)) {
+			break;
+		}
+
+		if (0 != iwlist->exitCode())
+			break;
+
+		out = iwlist->readAll();
+		if (!out.length())
+			break;
+
+		channelList = (char *)os_malloc(out.length());
+		if (!channelList)
+			break;
+		channelList[0] = 0;
+
+		list = out.split(QChar('\n'));
+		for (it = list.begin(); it != list.end(); it++) {
+			if (first) {
+				first = false;
+				continue;
+			}
+
+			QStringList cols = it->split(QRegExp("\\s+"));
+			_channel = cols.count() > 2?cols[2].toInt():0;
+			if (!_channel)
+				continue;
+
+			switch (_mode) {
+			case WIRELESS_MODE_11AGB:
+				if (_channel > 64)
+					continue;
+				break;
+			case WIRELESS_MODE_11A:
+				if ((_channel <= 14) || (_channel > 64))
+					continue;
+				break;
+			case WIRELESS_MODE_11GB:
+				if (_channel > 14)
+					continue;
+				break;
+			}
+
+			it->replace(QRegExp("^\\s+"), "");;
+			if (os_strlen(channelList))
+				strcat(channelList, "\n");
+			strcat(channelList, (const char *)it->toAscii());
+		}
+	} while (0);
+
+	if (iwlist) {
+		delete iwlist;
+		iwlist = 0;
+	}
+
+	return channelList;
+}
+
+bool MainProcess::setChannel(WIRELESS_MODE _mode, int _channel)
+{
+	bool ret = false;
+	QProcess *iwconfig = 0;
+	QProcess *iwpriv = 0;
+	char *stringMode = 0;
+	char cmd[BUFSIZ];
+
+	do {
+		os_snprintf(cmd, sizeof(cmd), "iwconfig %s channel 0", wirelessInterface);
+		iwconfig = new QProcess();
+		if (!iwconfig)
+			break;
+		iwconfig->start(cmd);
+		if (!iwconfig->waitForFinished(WAIT_FOR_PROCESS))
+			break;
+		if (0 != iwconfig->exitCode())
+			break;
+
+		switch (_mode) {
+		case WIRELESS_MODE_11AGB:
+		case WIRELESS_MODE_11GB:
+		case WIRELESS_MODE_11A:
+			stringMode = "auto";
+			break;
+		default:
+			break;
+		}
+
+		if (!stringMode)
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "iwpriv %s mode %s",
+					wirelessInterface, stringMode);
+		iwpriv = new QProcess();
+		if (!iwpriv)
+			break;
+		iwpriv->start(cmd);
+		if (!iwpriv->waitForFinished(WAIT_FOR_PROCESS))
+			break;
+		if (0 != iwpriv->exitCode())
+			break;
+
+		os_snprintf(cmd, sizeof(cmd), "iwconfig %s channel %d",
+					wirelessInterface, _channel);
+		iwconfig->start(cmd);
+		if (!iwconfig->waitForFinished(WAIT_FOR_PROCESS))
+			break;
+		if (0 != iwconfig->exitCode())
+			break;
+
+		channel = _channel;
+
+		ret = true;
+	} while (0);
+
+	if (iwconfig) {
+		delete iwconfig;
+		iwconfig = 0;
+	}
+
+	if (iwpriv) {
+		delete iwpriv;
+		iwpriv = 0;
+	}
+
+	return ret;
+}
+
Index: wpa.h
===================================================================
--- wpa.h	(revision 1)
+++ wpa.h	(revision 2)
@@ -183,4 +183,9 @@
 			       struct eapol_state_machine *eapol);
 int wpa_auth_sta_set_vlan(struct wpa_state_machine *sm, int vlan_id);
 
+#ifdef EAP_WPS
+int wpa_wps_prepare(struct wpa_state_machine *sm);
+int wpa_wps_get_state(struct wpa_state_machine *sm);
+#endif /* EAP_WPS */
+
 #endif /* WPA_H */
Index: eap.c
===================================================================
--- eap.c	(revision 1)
+++ eap.c	(revision 2)
@@ -1136,3 +1136,29 @@
 
 	return hdr;
 }
+
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+/**
+ * eap_get_hostapd_data - Get a bss configuration
+ * @sm: Pointer to EAP state machine allocated with eap_sm_init()
+ * Returns: Pointer to wps config data or %NULL if not found
+ */
+const struct hostapd_data *eap_get_hostapd_data(struct eap_sm *sm)
+{
+	return sm->eapol_cb->get_hostapd_data(sm->eapol_ctx);
+}
+
+
+/**
+ * eap_get_wps_config - Get a wps configuration
+ * @sm: Pointer to EAP state machine allocated with eap_sm_init()
+ * Returns: Pointer to wps config data or %NULL if not found
+ */
+const struct wps_config *eap_get_wps_config(struct eap_sm *sm)
+{
+	return sm->eapol_cb->get_wps_config(sm->eapol_ctx);
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
Index: eap.h
===================================================================
--- eap.h	(revision 1)
+++ eap.h	(revision 2)
@@ -21,6 +21,13 @@
 
 struct eap_sm;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+struct hostapd_bss_config;
+struct wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 #define EAP_MAX_METHODS 8
 struct eap_user {
 	struct {
@@ -51,6 +58,13 @@
 	int (*get_eap_user)(void *ctx, const u8 *identity, size_t identity_len,
 			    int phase2, struct eap_user *user);
 	const char * (*get_eap_req_id_text)(void *ctx, size_t *len);
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	const struct hostapd_data * (*get_hostapd_data)(void *ctx);
+	const struct wps_config * (*get_wps_config)(void *ctx);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
 
 struct eap_config {
Index: wps_opt_nfc.c
===================================================================
--- wps_opt_nfc.c	(revision 0)
+++ wps_opt_nfc.c	(revision 2)
@@ -0,0 +1,1202 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_nfc.c
+//  Description: EAP-WPS NFC option source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "hostapd.h"
+#include "wpa.h"
+#include "eloop.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wpa_ctrl.h"
+#include "state_machine.h"
+#include "wps_parser.h"
+#include "wps_opt_nfc.h"
+#include "eap_wps.h"
+#include "WpsNfcType.h"
+#include "WpsNfc.h"
+
+#define STATE_MACHINE_DATA struct wps_opt_nfc_sm
+#define STATE_MACHINE_DEBUG_PREFIX "OPT_NFC"
+
+#define WPS_OPT_NFC_COMP_FILENAME "wps_opf_nfc_cmp.conf"
+
+#ifndef WPSNFCLIB_VERSION
+#ifndef LIB_VERSION
+#define WPSNFCLIB_VERSION 0
+#define LIB_VERSION(a, b, c) 1
+#else
+#define WPSNFCLIB_VERSION LIB_VERSION(1, 0, 0) /* 1.0.0 */
+#endif /* LIB_VERSION */
+#endif /* WPSNFCLIB_VERSION */
+
+/**
+ * struct wps_opt_nfc_sm - Internal data for NFC state machines
+ */
+
+typedef enum {
+	OPT_NFC_INACTIVE = 0,
+	OPT_NFC_IDLE,
+	OPT_NFC_SCANNING,
+	OPT_NFC_SCAN_TIMEOUT,
+	OPT_NFC_FOUND_TOKEN,
+} opt_nfc_states;
+
+struct wps_opt_nfc_sm {
+ 	opt_nfc_states OPT_NFC_state;
+	Boolean changed;
+ 	struct wps_opt_nfc_sm_ctx *ctx;
+	const char *nfcname;
+	Boolean initialized;
+	Boolean isOpenedDevice;
+	Boolean existing;
+	Boolean enablePort;
+#define NFC_LOOP_PERIOD_SEC		1 /* [sec] */
+#define NFC_LOOP_PERIOD_USEC	0 /* [usec] */
+#define SCAN_TIMEOUT_SEC		30 /* [sec] */
+#define SCAN_TIMEOUT_USEC		0 /* [usec] */
+	struct os_time scanTimeout;
+	Boolean foundToken;
+	Boolean cancelCmd;
+	enum {
+		OPT_NFC_CMD_NONE = 0,
+		OPT_NFC_CMD_READ,
+		OPT_NFC_CMD_WRITE,
+	} OPT_NFC_CMD_state;
+	u8 *readBuf;
+	u32 readBufLen;
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+	int (*readCallback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len);
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+	int (*readCallback)(struct wps_opt_nfc_sm *sm);
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+	void (*readTimeoutCallback)(struct wps_opt_nfc_sm *sm);
+	u8 *writeBuf;
+	u32 writeBufLen;
+	int (*writeCallback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len);
+	void (*writeTimeoutCallback)(struct wps_opt_nfc_sm *sm);
+ };
+
+enum wps_opt_nfc_ctrl_req_type {
+	CTRL_REQ_TYPE_READ_TIMEOUT,
+	CTRL_REQ_TYPE_WRITE_TIMEOUT,
+	CTRL_REQ_TYPE_FAIL_READ,
+	CTRL_REQ_TYPE_COMP_READ,
+	CTRL_REQ_TYPE_COMP_WRITE
+};
+
+
+static int wps_opt_nfc_sm_is_timeout(struct wps_opt_nfc_sm *sm)
+{
+	struct os_time now;
+	os_get_time(&now);
+
+	if (now.sec > sm->scanTimeout.sec)
+		return 1;
+	else if ((now.sec == sm->scanTimeout.sec) &&
+			 (now.usec >= sm->scanTimeout.usec))
+		return 1;
+	else
+		return 0;
+}
+
+
+static void wps_opt_nfc_sm_request(struct wps_opt_nfc_sm *sm,
+			   enum wps_opt_nfc_ctrl_req_type type,
+			   const char *msg, size_t msglen)
+{
+	char *buf;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (sm == NULL)
+		return;
+
+	switch (type) {
+	case CTRL_REQ_TYPE_READ_TIMEOUT:
+		field = "NFC_READ_TIMEOUT";
+		txt = "Request Timeout";
+		break;
+	case CTRL_REQ_TYPE_WRITE_TIMEOUT:
+		field = "NFC_WRITE_TIMEOUT";
+		txt = "Request Timeout";
+		break;
+	case CTRL_REQ_TYPE_FAIL_READ:
+		field = "NFC_FAIL_READ";
+		txt = "Fail Reading Token";
+		break;
+	case CTRL_REQ_TYPE_COMP_READ:
+		field = "NFC_COMP_READ";
+		txt = "Complete Reading Token";
+		break;
+	case CTRL_REQ_TYPE_COMP_WRITE:
+		field = "NFC_COMP_WRITE";
+		txt = "Complete Writing Token";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		os_free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	hostapd_msg(sm->ctx->msg_ctx, MSG_INFO, "%s", buf);
+	os_free(buf);
+}
+
+static void wps_opt_nfc_port_timer_tick(void *wps_opt_nfc_ctx, void *timeout_ctx)
+{
+	struct wps_opt_nfc_sm *sm = timeout_ctx;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_port_timer_tick, wps_opt_nfc_ctx, sm);
+	wps_opt_nfc_sm_step(sm);
+}
+
+SM_STATE(OPT_NFC, INACTIVE)
+{
+	SM_ENTRY(OPT_NFC, INACTIVE);
+
+	if (sm->isOpenedDevice) {
+		WpsNfcCloseDevice();
+		sm->isOpenedDevice = 0;
+	}
+}
+
+
+SM_STATE(OPT_NFC, IDLE)
+{
+	SM_ENTRY(OPT_NFC, IDLE);
+
+	if (!sm->isOpenedDevice && sm->nfcname &&
+		(WPS_NFCLIB_ERR_SUCCESS ==
+		 WpsNfcOpenDevice((const int8 * const)sm->nfcname)))
+		 sm->isOpenedDevice = 1;
+}
+
+
+SM_STATE(OPT_NFC, SCANNING)
+{
+	uint32 nfcRet;
+	SM_ENTRY(OPT_NFC, SCANNING)
+
+	do {
+		nfcRet = WpsNfcTokenDiscovery();
+		if (WPS_NFCLIB_ERR_SUCCESS == nfcRet) {
+			sm->foundToken = 1;
+			break;
+		}
+
+		if (WPS_NFCLIB_ERR_TARGET_NOT_FOUND != nfcRet)
+			sm->enablePort = 0;
+
+		sm->foundToken = 0;
+	} while (0);
+}
+
+
+SM_STATE(OPT_NFC, SCAN_TIMEOUT)
+{
+	SM_ENTRY(OPT_NFC, SCAN_TIMEOUT);
+	switch (sm->OPT_NFC_CMD_state) {
+	case OPT_NFC_CMD_READ:
+		os_free(sm->readBuf);
+		sm->readBuf = 0;
+		sm->readBufLen = 0;
+		if (!sm->cancelCmd && sm->readTimeoutCallback)
+			sm->readTimeoutCallback(sm);
+		break;
+	case OPT_NFC_CMD_WRITE:
+		os_free(sm->writeBuf);
+		sm->writeBuf = 0;
+		sm->writeBufLen = 0;
+		if (!sm->cancelCmd && sm->writeTimeoutCallback)
+			sm->writeTimeoutCallback(sm);
+		break;
+	default:
+		break;
+	}
+	sm->cancelCmd = 0;
+	sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+}
+
+
+SM_STATE(OPT_NFC, FOUND_TOKEN)
+{
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+	uint32 buf_len;
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+
+	SM_ENTRY(OPT_NFC, FOUND_TOKEN)
+
+	switch (sm->OPT_NFC_CMD_state) {
+	case OPT_NFC_CMD_READ:
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+		if (WPS_NFCLIB_ERR_SUCCESS ==
+			WpsNfcReadToken((int8 * const)sm->readBuf,
+				            (uint32 * const)&buf_len)) {
+			sm->readBufLen = buf_len;
+			if (sm->readCallback)
+				sm->readCallback(sm, sm->readBuf, sm->readBufLen);
+			os_free(sm->readBuf);
+			sm->readBuf = 0;
+			sm->readBufLen = 0;
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		} else
+			sm->foundToken = 0;
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		if (sm->readCallback && sm->readCallback(sm)) {
+			sm->foundToken = 0;
+			break;
+		}
+		os_free(sm->readBuf);
+		sm->readBuf = 0;
+		sm->readBufLen = 0;
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		break;
+	case OPT_NFC_CMD_WRITE:
+		if (WPS_NFCLIB_ERR_SUCCESS ==
+			WpsNfcWriteToken((int8 * const)sm->writeBuf, sm->writeBufLen)) {
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+			if (sm->writeCallback)
+				sm->writeCallback(sm, sm->writeBuf, sm->writeBufLen);
+			os_free(sm->writeBuf);
+			sm->writeBuf = 0;
+			sm->writeBufLen = 0;
+			sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		} else
+			sm->foundToken = 0;
+		break;
+	default:
+		if (sm->readBuf) {
+			os_free(sm->readBuf);
+			sm->readBuf = 0;
+			sm->readBufLen = 0;
+		}
+		if (sm->writeBuf) {
+			os_free(sm->writeBuf);
+			sm->writeBuf = 0;
+			sm->writeBufLen = 0;
+		}
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+		break;
+	}
+}
+
+
+SM_STEP(OPT_NFC)
+{
+	if (sm->existing)
+		sm->enablePort = 0;
+	else if (!sm->initialized) {
+		if (WPS_NFCLIB_ERR_SUCCESS == WpsNfcInit()) {
+			sm->initialized = 1;
+			sm->isOpenedDevice = 0;
+		}
+	}
+
+	if (!sm->initialized)
+		return;
+
+	do {
+		sm->changed = 0;
+
+		if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state) {
+			if (sm->cancelCmd || wps_opt_nfc_sm_is_timeout(sm))
+				SM_ENTER_GLOBAL(OPT_NFC, SCAN_TIMEOUT);
+		}
+
+		switch(sm->OPT_NFC_state) {
+		case OPT_NFC_INACTIVE:
+			if (sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		case OPT_NFC_IDLE:
+			if (!sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			else if (sm->OPT_NFC_CMD_state != OPT_NFC_CMD_NONE) {
+				SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+				if (OPT_NFC_SCANNING == sm->OPT_NFC_state)
+					sm->changed = 0;
+			}
+			break;
+		case OPT_NFC_SCANNING:
+			if (!sm->enablePort)
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			else {
+				if (sm->foundToken)
+					SM_ENTER_GLOBAL(OPT_NFC, FOUND_TOKEN);
+				else if (OPT_NFC_CMD_NONE == sm->OPT_NFC_CMD_state)
+					SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+				else
+					SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+			}
+			break;
+		case OPT_NFC_SCAN_TIMEOUT:
+			SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		case OPT_NFC_FOUND_TOKEN:
+			wpa_printf(MSG_DEBUG, "WPS_OPT_NFC: Found Token");
+			if (!sm->enablePort) {
+				SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+				break;
+			} else if (!sm->foundToken)
+				SM_ENTER_GLOBAL(OPT_NFC, SCANNING);
+			else
+				SM_ENTER_GLOBAL(OPT_NFC, IDLE);
+			break;
+		default:
+			sm->enablePort = 0;
+			SM_ENTER_GLOBAL(OPT_NFC, INACTIVE);
+			break;
+		}
+	} while (sm->changed);
+
+	if ((sm->existing) && (sm->initialized)) {
+			WpsNfcDeinit();
+			sm->initialized = 0;
+			sm->existing = 0;
+	}
+}
+
+
+void wps_opt_nfc_sm_step(struct wps_opt_nfc_sm *sm)
+{
+	SM_STEP_RUN(OPT_NFC);
+}
+
+void wps_opt_nfc_sm_set_ifname(struct wps_opt_nfc_sm *sm, const char *nfcname)
+{
+	if (sm) {
+		sm->nfcname = nfcname;
+	}
+}
+
+struct wps_opt_nfc_sm *wps_opt_nfc_sm_init(struct wps_opt_nfc_sm_ctx *ctx)
+{
+	struct wps_opt_nfc_sm *sm;
+
+	sm = wpa_zalloc(sizeof(*sm));
+	if (sm == NULL)
+		return NULL;
+	sm->ctx = ctx;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_port_timer_tick, NULL, sm);
+
+	return sm;
+}
+
+void wps_opt_nfc_sm_deinit(struct wps_opt_nfc_sm *sm)
+{
+	if (sm == NULL)
+		return;
+	eloop_cancel_timeout(wps_opt_nfc_port_timer_tick, sm->ctx, sm);
+	sm->existing = 1;
+	wps_opt_nfc_sm_step(sm);
+	os_free(sm->ctx);
+	os_free(sm);
+}
+
+
+static void wps_opt_nfc_sm_command(void *wps_opt_nfc_ctx, void *timeout_ctx)
+{
+	struct wps_opt_nfc_sm *sm = (struct wps_opt_nfc_sm *)wps_opt_nfc_ctx;
+	struct wps_opt_nfc_sm *cmd = (struct wps_opt_nfc_sm *)timeout_ctx;
+
+	if ((OPT_NFC_INACTIVE == sm->OPT_NFC_state) ||
+		(OPT_NFC_IDLE == sm->OPT_NFC_state)) {
+		switch (cmd->OPT_NFC_CMD_state) {
+		case OPT_NFC_CMD_READ:
+			sm->readBuf = cmd->readBuf;
+			sm->readBufLen = cmd->readBufLen;
+			sm->readCallback = cmd->readCallback;
+			sm->readTimeoutCallback = cmd->readTimeoutCallback;
+			break;
+		case OPT_NFC_CMD_WRITE:
+			sm->writeBuf = cmd->writeBuf;
+			sm->writeBufLen = cmd->writeBufLen;
+			sm->writeCallback = cmd->writeCallback;
+			sm->writeTimeoutCallback = cmd->writeTimeoutCallback;
+			break;
+		default:
+			break;
+		}
+		os_get_time(&sm->scanTimeout);
+		sm->scanTimeout.sec += SCAN_TIMEOUT_SEC;
+		sm->scanTimeout.usec += SCAN_TIMEOUT_USEC;
+		sm->OPT_NFC_CMD_state = cmd->OPT_NFC_CMD_state;
+
+		os_free(cmd);
+		if (!sm->enablePort)
+			sm->enablePort = 1;
+	} else
+		eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+}
+
+
+static int wps_opt_nfc_sm_read_command(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+		int (*callback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len),
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		int (*callback)(struct wps_opt_nfc_sm *sm),
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+		void (*timeout)(struct wps_opt_nfc_sm *sm))
+{
+	struct wps_opt_nfc_sm *cmd;
+
+	if (sm->cancelCmd)
+		sm->cancelCmd = 0;
+
+	cmd = (struct wps_opt_nfc_sm *)calloc(sizeof(struct wps_opt_nfc_sm), 1);
+	if (!cmd)
+		return -1;
+
+	cmd->readBuf = buf;
+	cmd->readBufLen = len;
+	cmd->OPT_NFC_CMD_state = OPT_NFC_CMD_READ;
+	cmd->readCallback = callback;
+	cmd->readTimeoutCallback = timeout;
+
+	if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state)
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+
+	return 0;
+}
+
+
+static int wps_opt_nfc_sm_write_command(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len,
+		int (*callback)(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len),
+		void (*timeout)(struct wps_opt_nfc_sm *sm))
+{
+	struct wps_opt_nfc_sm *cmd;
+
+	if (sm->cancelCmd)
+		sm->cancelCmd = 0;
+
+	cmd = (struct wps_opt_nfc_sm *)calloc(sizeof(struct wps_opt_nfc_sm), 1);
+	if (!cmd)
+		return -1;
+
+	cmd->writeBuf = buf;
+	cmd->writeBufLen = len;
+	cmd->OPT_NFC_CMD_state = OPT_NFC_CMD_WRITE;
+	cmd->writeCallback = callback;
+	cmd->writeTimeoutCallback = timeout;
+
+	if (OPT_NFC_CMD_NONE != sm->OPT_NFC_CMD_state)
+		sm->OPT_NFC_CMD_state = OPT_NFC_CMD_NONE;
+
+	eloop_register_timeout(NFC_LOOP_PERIOD_SEC, NFC_LOOP_PERIOD_USEC, wps_opt_nfc_sm_command, sm, cmd);
+
+	return 0;
+}
+
+
+static int wps_opt_nfc_read_password_callback(struct wps_opt_nfc_sm *sm, u8 *buf, size_t len)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	struct wps_config *conf;
+	u8 version;
+	u8 *oobdevpwd = 0;
+	u16 length;
+	u8 *pwd;
+	size_t pwd_len;
+	u8 dev_pwd[SIZE_64_BYTES + 1];
+	char msg[32];
+
+	do {
+		conf = (sm->ctx->get_conf(sm->ctx->ctx))->wps;
+		if (!conf)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* OOB Device Password */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, NULL, &length);
+		if (!length)
+			break;
+		oobdevpwd = (u8 *)calloc(1, length);
+		if (!oobdevpwd)
+			break;
+		if(wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, oobdevpwd, &length))
+			break;
+
+		if (length < 20 + 2 + 6)
+			break;
+
+		os_memcpy(conf->pub_key, oobdevpwd, 20);
+		conf->set_pub_key = 1;
+		conf->dev_pwd_id = WPA_GET_BE16(oobdevpwd + 20);
+		pwd = oobdevpwd + 22;
+		pwd_len = length - 22;
+		conf->dev_pwd_len = wpa_snprintf_hex_uppercase((char *)dev_pwd, sizeof(dev_pwd), pwd, pwd_len);
+		os_memcpy(conf->dev_pwd, dev_pwd, sizeof(conf->dev_pwd));
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (oobdevpwd)
+		os_free(oobdevpwd);
+
+	os_snprintf(msg, sizeof(msg), "Password Token");
+	if (ret) {
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_FAIL_READ, msg, os_strlen(msg));
+	} else {
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_READ, msg, os_strlen(msg));
+	}
+
+	return ret;
+}
+
+
+#if WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1)
+static int wps_opt_nfc_read_password_callback2(struct wps_opt_nfc_sm *sm)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u16 length;
+	int8 *buf = 0;
+	uint32 len = 0;
+	uint32 num = 0;
+	uint32 i;
+
+	do {
+		if (WPS_NFCLIB_ERR_SUCCESS != WpsNfcReadTokenMessage(&num))
+			break;
+
+		do {
+			if (!num)
+				break;
+
+			for (i = 0; (i < num) && ret; i++) {
+				len = 0;
+				if (WPS_NFCLIB_ERR_SUCCESS !=
+					WpsNfcGetRecordFromMessage(i, &buf, &len))
+					continue;
+
+				do {
+					if (wps_create_wps_data(&wps))
+						break;
+
+					if(wps_parse_wps_data((uint8 *)buf, len, wps))
+						break;
+
+					/* Version */
+					if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+						break;
+					if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+						break;
+
+					/* OOB Device Password */
+					length = 0;
+					(void)wps_get_value(wps, WPS_TYPE_OOB_DEV_PWD, NULL, &length);
+					if (!length)
+						break;
+
+					ret = 0;
+				} while (0);
+
+				(void)wps_destroy_wps_data(&wps);
+
+				if (ret) {
+					if (buf) os_free(buf);
+					buf = 0;
+				}
+			}
+		} while (0);
+		(void)wps_opt_nfc_read_password_callback(sm, (uint8 *)buf, len);
+		ret = 0;
+	} while (0);
+
+	if (buf) os_free(buf);
+
+	return ret;
+}
+#endif /* WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1) */
+
+
+static void wps_opt_nfc_read_password_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	os_snprintf(msg, sizeof(msg), "Password Token");
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_READ_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_write_password_callback(struct wps_opt_nfc_sm *sm, u8 *buf, size_t len)
+{
+	char msg[32];
+	os_snprintf(msg, sizeof(msg), "Password Token");
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_WRITE, msg, os_strlen(msg));
+	return 0;
+}
+
+
+static void wps_opt_nfc_write_password_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	os_snprintf(msg, sizeof(msg), "Password Token");
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_WRITE_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_read_config_callback(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 * credential = 0;
+	u16 length;
+	char msg[64];
+
+	do {
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if(wps_parse_wps_data(buf, len, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Creadential */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, NULL, &length);
+		if (!length)
+			break;
+		credential = (u8 *)calloc(1, length);
+		if (!credential)
+			break;
+		if(wps_get_value(wps, WPS_TYPE_CREDENTIAL, credential, &length))
+			break;
+
+		if (wps_set_ssid_configuration(sm->ctx->ctx, WPS_OPT_NFC_COMP_FILENAME, credential, length))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (credential)
+		os_free(credential);
+
+	if (ret) {
+		os_snprintf(msg, sizeof(msg), "Config Token");
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_FAIL_READ, msg, os_strlen(msg));
+	} else {
+		os_snprintf(msg, sizeof(msg), "Config Token:%s", WPS_OPT_NFC_COMP_FILENAME);
+		wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_READ, msg, os_strlen(msg));
+	}
+
+	return ret;
+}
+
+
+#if WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1)
+static int wps_opt_nfc_read_config_callback2(struct wps_opt_nfc_sm *sm)
+{
+	Boolean ret = -1;
+	struct wps_data *wps = 0;
+	u8 version;
+	u16 length;
+	int8 *buf = 0;
+	uint32 len = 0;
+	uint32 num = 0;
+	uint32 i;
+
+	do {
+		if (WPS_NFCLIB_ERR_SUCCESS != WpsNfcReadTokenMessage(&num))
+			break;
+
+		do {
+			if (!num)
+				break;
+
+			for (i = 0; (i < num) && ret; i++) {
+				len = 0;
+				if (WPS_NFCLIB_ERR_SUCCESS !=
+					WpsNfcGetRecordFromMessage(i, &buf, &len))
+					continue;
+
+				do {
+					if (wps_create_wps_data(&wps))
+						break;
+
+					if(wps_parse_wps_data((uint8 *)buf, len, wps))
+						break;
+
+					/* Version */
+					if (wps_get_value(wps, WPS_TYPE_VERSION, &version, NULL))
+						break;
+					if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+						break;
+
+					/* Creadential */
+					length = 0;
+					(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, NULL, &length);
+					if (!length)
+						break;
+
+					ret = 0;
+				} while (0);
+
+				(void)wps_destroy_wps_data(&wps);
+
+				if (ret) {
+					if (buf) os_free(buf);
+					buf = 0;
+				}
+			}
+		} while (0);
+		(void)wps_opt_nfc_read_config_callback(sm, (uint8 *)buf, len);
+		ret = 0;
+	} while (0);
+
+	if (buf) os_free(buf);
+
+	return ret;
+}
+#endif /* WPSNFCLIB_VERSION >= LIB_VERSION(1, 1, 1) */
+
+
+static void wps_opt_nfc_read_config_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char *msg = "Config Token";
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_READ_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+static int wps_opt_nfc_write_config_callback(struct wps_opt_nfc_sm *sm, u8 * buf, size_t len)
+{
+	int ret = 0;
+	struct hostapd_config *conf;
+	struct wps_config *wps = 0;
+	struct wps_data *data = 0;
+	u8 version;
+	u8 * credential = 0;
+	u16 length;
+	char msg[64];
+
+	os_snprintf(msg, sizeof(msg), "Config Token");
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf && !conf->wps)
+			break;
+		wps = conf->wps;
+
+		if (WPS_WPSSTATE_UNCONFIGURED == wps->wps_state) {
+			ret = -1;
+
+			do {
+				if (wps_create_wps_data(&data))
+					break;
+
+				if(wps_parse_wps_data(buf, len, data))
+					break;
+
+				/* Version */
+				if (wps_get_value(data, WPS_TYPE_VERSION, &version, NULL))
+					break;
+				if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+					break;
+
+				/* Creadential */
+				length = 0;
+				(void)wps_get_value(data, WPS_TYPE_CREDENTIAL, NULL, &length);
+				if (!length)
+					break;
+				credential = (u8 *)calloc(1, length);
+				if (!credential)
+					break;
+				if(wps_get_value(data, WPS_TYPE_CREDENTIAL, credential, &length))
+					break;
+
+				if (wps_set_ssid_configuration(sm->ctx->ctx, WPS_OPT_NFC_COMP_FILENAME, credential, length))
+					break;
+
+				ret = 0;
+			} while (0);
+
+			(void)wps_destroy_wps_data(&data);
+			if (credential)
+				os_free(credential);
+
+			if (!ret)
+				os_snprintf(msg, sizeof(msg), "Config Token:%s", WPS_OPT_NFC_COMP_FILENAME);
+		}
+	} while (0);
+
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_COMP_WRITE, msg, os_strlen(msg));
+
+	return ret;
+}
+
+
+static void wps_opt_nfc_write_config_timeout_callback(struct wps_opt_nfc_sm *sm)
+{
+	char msg[32];
+	os_snprintf(msg, sizeof(msg), "Config Token");
+	wps_opt_nfc_sm_request(sm, CTRL_REQ_TYPE_WRITE_TIMEOUT, msg, os_strlen(msg));
+}
+
+
+int wps_opt_nfc_cancel_nfc_comand(struct wps_opt_nfc_sm *sm)
+{
+	sm->cancelCmd = 1;
+	return 0;
+}
+
+
+static int wps_opt_nfc_generate_oob_device_password(
+	struct wps_opt_nfc_sm *sm, u8 *hash,
+	u16 *dev_pwd_id, u8 *pwd, int pwd_len)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_config *wps = 0;
+	u8 dev_pwd[SIZE_64_BYTES + 1];
+	int dev_pwd_len;
+	u8 tmp[SIZE_256_BITS];
+
+	do {
+		if (!hash || !dev_pwd_id || !pwd )
+			break;
+
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf && !conf->wps)
+			break;
+		wps = conf->wps;
+		if ((16 > pwd_len) || ((pwd_len * 2) > sizeof(wps->dev_pwd)))
+			break;
+
+		if (eap_wps_generate_public_key(&wps->dh_secret, wps->pub_key))
+			break;
+		wps->set_pub_key = 1;
+
+		if (eap_wps_generate_sha256hash(wps->pub_key, sizeof(wps->pub_key), tmp))
+			break;
+		os_memcpy(hash, tmp, SIZE_20_BYTES);
+
+		if (eap_wps_generate_device_password_id(dev_pwd_id))
+			break;
+
+		if (eap_wps_generate_device_password(pwd, pwd_len))
+			break;
+
+		dev_pwd_len = wpa_snprintf_hex_uppercase((char *)dev_pwd, sizeof(dev_pwd), pwd, pwd_len);
+		if (dev_pwd_len != (pwd_len * 2))
+			break;
+
+		wps->dev_pwd_id = *dev_pwd_id;
+		os_memcpy(wps->dev_pwd, dev_pwd, dev_pwd_len);
+		wps->dev_pwd_len = dev_pwd_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (wps) {
+			if (wps->dh_secret)
+				eap_wps_free_dh(&wps->dh_secret);
+			wps->set_pub_key = 0;
+
+			wps->dev_pwd_len = 0;
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+		}
+	}
+
+	return ret;
+}
+
+
+int wps_opt_nfc_read_password_token(struct wps_opt_nfc_sm *sm)
+{
+#define DEFAULT_READ_BUF_SIZE 0x800
+	int ret = -1;
+	struct hostapd_config *conf;
+	u8 * buf = 0;
+	size_t len;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		buf = (u8 *)calloc(1, DEFAULT_READ_BUF_SIZE);
+		if (!buf)
+			break;
+		len = DEFAULT_READ_BUF_SIZE;
+		if (wps_opt_nfc_sm_read_command(sm, buf, len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+										wps_opt_nfc_read_password_callback,
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_password_callback2,
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_password_timeout_callback))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && buf) {
+		os_free(buf);
+		buf = 0;
+		len = 0;
+	}
+
+	return ret;
+#undef DEFAULT_READ_BUF_SIZE
+}
+
+
+int wps_opt_nfc_write_password_token(struct wps_opt_nfc_sm *sm)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 pub_key_hash[20];
+	u16 dev_pwd_id;
+	u8 dev_pwd[32];
+	u8 oob_dev_pwd[sizeof(pub_key_hash) + sizeof(dev_pwd_id) + sizeof(dev_pwd)];
+	u8 *tmp;
+	u8 *buf = 0;
+	u16 buf_len;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_opt_nfc_generate_oob_device_password(sm, pub_key_hash,
+					&dev_pwd_id, dev_pwd, sizeof(dev_pwd)))
+			break;
+		tmp = oob_dev_pwd;
+		os_memcpy(tmp, pub_key_hash, sizeof(pub_key_hash));
+		tmp += sizeof(pub_key_hash);
+		WPA_PUT_BE16(tmp, dev_pwd_id);
+		tmp += sizeof(dev_pwd_id);
+		os_memcpy(tmp, dev_pwd, sizeof(dev_pwd));
+		tmp += sizeof(dev_pwd);
+
+		/* Version */
+		if (conf->wps && conf->wps->version)
+			version = conf->wps->version;
+		else
+			version = WPS_VERSION;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+
+		/* OOB Device Password */
+		if (wps_set_value(wps, WPS_TYPE_OOB_DEV_PWD, oob_dev_pwd, sizeof(oob_dev_pwd)))
+			break;
+
+		if(wps_write_wps_data(wps, &buf, &buf_len))
+			break;
+
+		if (wps_opt_nfc_sm_write_command(sm, buf, buf_len,
+										 wps_opt_nfc_write_password_callback,
+										 wps_opt_nfc_write_password_timeout_callback))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (ret && buf) {
+		os_free(buf);
+		buf = 0;
+	}
+
+	return ret;
+}
+
+
+int wps_opt_nfc_read_config_token(struct wps_opt_nfc_sm *sm)
+{
+#define DEFAULT_READ_BUF_SIZE 0x800
+	int ret = -1;
+	u8 * buf = 0;
+	size_t len;
+
+	do {
+		buf = (u8 *)calloc(1, DEFAULT_READ_BUF_SIZE);
+		if (!buf)
+			break;
+		len = DEFAULT_READ_BUF_SIZE;
+		if (wps_opt_nfc_sm_read_command(sm, buf, len,
+#if WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1)
+										wps_opt_nfc_read_config_callback,
+#else /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_config_callback2,
+#endif /* WPSNFCLIB_VERSION < LIB_VERSION(1, 1, 1) */
+										wps_opt_nfc_read_config_timeout_callback))
+			break;
+		ret = 0;
+	} while (0);
+
+	if (ret && buf) {
+		os_free(buf);
+		buf = 0;
+		len = 0;
+	}
+
+	return ret;
+#undef DEFAULT_READ_BUF_SIZE
+}
+
+
+int wps_opt_nfc_write_config_token(struct wps_opt_nfc_sm *sm)
+{
+	int ret = -1;
+	struct hostapd_config *conf;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 nwIdx;
+	u8 *buf = 0, *tmp = 0;
+	size_t tmp_len;
+	u16 buf_len;
+	u16 len;
+
+	do {
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf)
+			break;
+
+		/* Make Creadential Attribute */
+		if (conf->wps && (WPS_WPSSTATE_UNCONFIGURED == conf->wps->wps_state)) {
+			if (wps_get_auto_configuration(sm->ctx->ctx, &tmp, &tmp_len))
+				break;
+		} else {
+			if (wps_get_ssid_configuration(sm->ctx->ctx, &tmp, &tmp_len, 0))
+				break;
+		}
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Network Index */
+		nwIdx = 1;
+		if (wps_set_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, 0))
+			break;
+
+		buf_len = 0;
+		if (wps_write_wps_data(wps, &buf, &buf_len))
+			break;
+
+		(void)wps_destroy_wps_data(&wps);
+
+		buf = os_realloc(buf, buf_len + tmp_len);
+		if (!buf)
+			break;
+		os_memcpy(buf + buf_len, tmp, tmp_len);
+		buf_len += tmp_len;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (conf->wps && conf->wps->version)
+			version = conf->wps->version;
+		else
+			version = WPS_VERSION;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+
+		/* Credential */
+		if (wps_set_value(wps, WPS_TYPE_CREDENTIAL, buf, (u16)buf_len))
+			break;
+
+		os_free(buf);
+		buf = 0;
+		len = 0;
+		if(wps_write_wps_data(wps, &buf, &len))
+			break;
+
+		if (wps_opt_nfc_sm_write_command(sm, buf, len,
+										 wps_opt_nfc_write_config_callback,
+										 wps_opt_nfc_write_config_timeout_callback))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+	if (ret && buf) {
+		os_free(buf);
+		buf = 0;
+	}
+
+	if (tmp)
+		os_free(tmp);
+
+	return ret;
+}
+
+
Index: base64.c
===================================================================
--- base64.c	(revision 0)
+++ base64.c	(revision 2)
@@ -0,0 +1,188 @@
+/*
+ * Base64 encoding/decoding (RFC1341)
+ * Copyright (c) 2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#include "includes.h"
+
+#include "os.h"
+#include "base64.h"
+
+static const unsigned char base64_table[65] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+/**
+ * base64_encode - Base64 encode
+ * @src: Data to be encoded
+ * @len: Length of the data to be encoded
+ * @out_len: Pointer to output length variable, or %NULL if not used
+ * Returns: Allocated buffer of out_len bytes of encoded data,
+ * or %NULL on failure
+ *
+ * Caller is responsible for freeing the returned buffer. Returned buffer is
+ * nul terminated to make it easier to use as a C string. The nul terminator is
+ * not included in out_len.
+ */
+unsigned char * base64_encode(const unsigned char *src, size_t len,
+			      size_t *out_len)
+{
+	unsigned char *out, *pos;
+	const unsigned char *end, *in;
+	size_t olen;
+	int line_len;
+
+	olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
+	olen += olen / 72; /* line feeds */
+	olen++; /* nul termination */
+	out = os_malloc(olen);
+	if (out == NULL)
+		return NULL;
+
+	end = src + len;
+	in = src;
+	pos = out;
+	line_len = 0;
+	while (end - in >= 3) {
+		*pos++ = base64_table[in[0] >> 2];
+		*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
+		*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
+		*pos++ = base64_table[in[2] & 0x3f];
+		in += 3;
+		line_len += 4;
+		if (line_len >= 72) {
+			*pos++ = '\n';
+			line_len = 0;
+		}
+	}
+
+	if (end - in) {
+		*pos++ = base64_table[in[0] >> 2];
+		if (end - in == 1) {
+			*pos++ = base64_table[(in[0] & 0x03) << 4];
+			*pos++ = '=';
+		} else {
+			*pos++ = base64_table[((in[0] & 0x03) << 4) |
+					      (in[1] >> 4)];
+			*pos++ = base64_table[(in[1] & 0x0f) << 2];
+		}
+		*pos++ = '=';
+		line_len += 4;
+	}
+
+	if (line_len)
+		*pos++ = '\n';
+
+	*pos = '\0';
+	if (out_len)
+		*out_len = pos - out;
+	return out;
+}
+
+
+/**
+ * base64_decode - Base64 decode
+ * @src: Data to be decoded
+ * @len: Length of the data to be decoded
+ * @out_len: Pointer to output length variable
+ * Returns: Allocated buffer of out_len bytes of decoded data,
+ * or %NULL on failure
+ *
+ * Caller is responsible for freeing the returned buffer.
+ */
+unsigned char * base64_decode(const unsigned char *src, size_t len,
+			      size_t *out_len)
+{
+	unsigned char dtable[256], *out, *pos, in[4], block[4], tmp;
+	size_t i, count, olen;
+
+	os_memset(dtable, 0x80, 256);
+	for (i = 0; i < sizeof(base64_table) - 1; i++)
+		dtable[base64_table[i]] = (unsigned char) i;
+	dtable['='] = 0;
+
+	count = 0;
+	for (i = 0; i < len; i++) {
+		if (dtable[src[i]] != 0x80)
+			count++;
+	}
+
+	if (count % 4)
+		return NULL;
+
+	olen = count / 4 * 3;
+	pos = out = os_malloc(olen);
+	if (out == NULL)
+		return NULL;
+
+	count = 0;
+	for (i = 0; i < len; i++) {
+		tmp = dtable[src[i]];
+		if (tmp == 0x80)
+			continue;
+
+		in[count] = src[i];
+		block[count] = tmp;
+		count++;
+		if (count == 4) {
+			*pos++ = (block[0] << 2) | (block[1] >> 4);
+			*pos++ = (block[1] << 4) | (block[2] >> 2);
+			*pos++ = (block[2] << 6) | block[3];
+			count = 0;
+		}
+	}
+
+	if (pos > out) {
+		if (in[2] == '=')
+			pos -= 2;
+		else if (in[3] == '=')
+			pos--;
+	}
+
+	*out_len = pos - out;
+	return out;
+}
+
+
+#ifdef TEST_MAIN
+#include <stdio.h>
+
+int main(int argc, char *argv[])
+{
+	FILE *f;
+	size_t len, elen;
+	unsigned char *buf, *e;
+
+	if (argc != 4) {
+		printf("Usage: base64 <encode|decode> <in file> <out file>\n");
+		return -1;
+	}
+
+	buf = os_readfile(argv[2], &len);
+	if (buf == NULL)
+		return -1;
+
+	if (strcmp(argv[1], "encode") == 0)
+		e = base64_encode(buf, len, &elen);
+	else
+		e = base64_decode(buf, len, &elen);
+	if (e == NULL)
+		return -2;
+	f = fopen(argv[3], "w");
+	if (f == NULL)
+		return -3;
+	fwrite(e, 1, elen, f);
+	fclose(f);
+	free(e);
+
+	return 0;
+}
+#endif /* TEST_MAIN */
Index: wps_parser.c
===================================================================
--- wps_parser.c	(revision 0)
+++ wps_parser.c	(revision 2)
@@ -0,0 +1,711 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_parser.c
+//  Description: EAP-WPS parser source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "wps_config.h"
+#include "wps_parser.h"
+
+#define GENERIC_INFO_ELEM 0xdd
+#define RSN_INFO_ELEM 0x30
+
+#define WPS_LENTYPE_FIX		0
+#define WPS_LENTYPE_MAX		1
+#define WPS_LENTYPE_MIN		2
+
+struct wps_tlv {
+	u16		type;
+	u16		length;
+	u16		value_type;
+	union _value {
+		Boolean	bool_;
+		u8		u8_;
+		u16		u16_;
+		u32		u32_;
+		u8 *	ptr_;
+	} value;
+};
+
+struct wps_tlv_set {
+	u16		type;
+	u16		length;
+	u16		length_type;
+	u16		value_type;
+};
+
+const struct wps_tlv_set wps_tlv_sets [] = {
+	{WPS_TYPE_AP_CHANNEL,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ASSOC_STATE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTH_TYPE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTH_TYPE_FLAGS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_AUTHENTICATOR,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONFIG_METHODS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_CONFIG_ERROR,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_CONF_URL4,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONF_URL6,			76,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_CONN_TYPE,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_CONN_TYPE_FLAGS,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_CREDENTIAL,			0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_DEVICE_NAME,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_DEVICE_PWD_ID,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_E_HASH1,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_HASH2,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_SNONCE1,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_E_SNONCE2,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_ENCR_SETTINGS,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_ENCR_TYPE,			2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ENCR_TYPE_FLAGS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_ENROLLEE_NONCE,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_FEATURE_ID,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_IDENTITY,				80,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_IDENTITY_PROOF,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_WRAP_AUTH,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_IDENTIFIER,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MAC_ADDR,				6,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MANUFACTURER,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MSG_TYPE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_MODEL_NAME,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MODEL_NUMBER,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NW_INDEX,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_NW_KEY,				64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NW_KEY_INDEX,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_NEW_DEVICE_NAME,		32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_NEW_PWD,				64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_OOB_DEV_PWD,			58,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_OS_VERSION,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_POWER_LEVEL,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PSK_CURRENT,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PSK_MAX,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_PUBLIC_KEY,			192,	WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_RADIO_ENABLED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REBOOT,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REGISTRAR_CURRENT,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_REGISTRAR_ESTBLSHD,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_REGISTRAR_LIST,		512,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REGISTRAR_MAX,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_REGISTRAR_NONCE,		16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REQ_TYPE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_RESP_TYPE,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_RF_BANDS,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_R_HASH1,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_HASH2,				32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_SNONCE1,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_R_SNONCE2,			16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_SEL_REGISTRAR,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_SERIAL_NUM,			32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_WPSSTATE,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_SSID,					32,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_TOT_NETWORKS,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_UUID_E,				16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_UUID_R,				16,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_VENDOR_EXT,			1024,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_VERSION,				1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U8},
+	{WPS_TYPE_X509_CERT_REQ,		0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_X509_CERT,			0xFFFF,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_EAP_IDENTITY,			64,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_MSG_COUNTER,			8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_PUBKEY_HASH,			20,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_REKEY_KEY,			32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_LIFETIME,			4,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U32},
+	{WPS_TYPE_PERM_CFG_METHODS,		2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_SEL_REG_CFG_METHODS,	2,		WPS_LENTYPE_FIX,	WPS_VALTYPE_U16},
+	{WPS_TYPE_PRIM_DEV_TYPE,		8,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_SEC_DEV_TYPE_LIST,	128,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_PORTABLE_DEVICE,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_AP_SETUP_LOCKED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_APP_EXT,				512,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_EAP_TYPE,				8,		WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_INIT_VECTOR,			32,		WPS_LENTYPE_FIX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_KEY_PROVIDED_AUTO,	1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_8021X_ENABLED,		1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{WPS_TYPE_APP_SESS_KEY,			128,	WPS_LENTYPE_MAX,	WPS_VALTYPE_PTR},
+	{WPS_TYPE_WEP_TX_KEY,			1,		WPS_LENTYPE_FIX,	WPS_VALTYPE_BOOL},
+	{0, 0, 0, 0},
+};
+
+static int wps_create_tlv(struct wps_tlv **tlv)
+{
+	if (!tlv)
+		return -1;
+
+	*tlv = (struct wps_tlv *)calloc(1, sizeof(struct wps_tlv));
+	if (!*tlv)
+		return -1;	/* Memory allocation error */
+
+	return 0;
+}
+
+static int wps_destroy_tlv(struct wps_tlv **tlv)
+{
+	if (!tlv || !*tlv)
+		return -1;
+
+	if (WPS_VALTYPE_PTR == (*tlv)->value_type) {
+		if ((*tlv)->value.ptr_)
+			os_free((*tlv)->value.ptr_);
+	}
+
+	os_free(*tlv);
+	*tlv = 0;
+
+	return 0;
+}
+
+static const struct wps_tlv_set *wps_get_tlv_set(
+	const u16 type)
+{
+	const struct wps_tlv_set *set = wps_tlv_sets;
+
+	while (set->type) {
+		if (type == set->type)
+			break;
+		set++;
+	}
+
+	if (!set->type)
+		return 0;	/* Invalidate tlv */
+
+	return set;
+}
+
+static const struct wps_tlv_set *wps_match_tlv(
+	const u16 type, const u16 length)
+{
+	const struct wps_tlv_set *set = wps_tlv_sets;
+
+	while (set->type) {
+		if (type == set->type) {
+			if (WPS_LENTYPE_FIX == set->length_type) {
+				if (length == set->length)
+					break;
+			} else if (WPS_LENTYPE_MAX == set->length_type) {
+				if (length <= set->length)
+					break;
+			} else if (WPS_LENTYPE_MIN == set->length_type) {
+				if (length < set->length)
+					break;
+			} else
+				return 0;	/* Application Error */
+		}
+		set++;
+	}
+
+	if (!set->type)
+		return 0;	/* Invalidate tlv */
+
+	return set;
+}
+
+static int wps_get_tlv(const u8 *buf, size_t len,
+	struct wps_tlv **tlv)
+{
+	const u8 *pos = buf;
+	const struct wps_tlv_set *set;
+	u16 type;
+	size_t length;
+	Boolean b_value = FALSE;
+	u8 u8_value = 0;
+	u16 u16_value = 0;
+	u32 u32_value = 0;
+	u8 *ptr_value = 0;
+
+	if (!buf || 4 >= len || !tlv)
+		return -1;
+
+	*tlv = 0;
+
+	type = WPA_GET_BE16(pos);
+	length = WPA_GET_BE16(pos+2);
+
+	set = wps_match_tlv(type, length);
+	if (!set)
+		return -1;	/* Invalidate tlv */
+
+	if (length + 4 > len)
+		return -1;	/* Buffer too short */
+
+	switch (set->value_type) {
+	case WPS_VALTYPE_BOOL:
+		if (length != 1)
+			return -1;
+		b_value = (Boolean)*(pos+4);
+		break;
+	case WPS_VALTYPE_U8:
+		if (length != 1)
+			return -1;
+		u8_value = *(pos+4);
+		break;
+	case WPS_VALTYPE_U16:
+		if (length != 2)
+			return -1;
+		u16_value = WPA_GET_BE16(pos+4);
+		break;
+	case WPS_VALTYPE_U32:
+		if (length != 4)
+			return -1;
+		u32_value = WPA_GET_BE32(pos+4);
+		break;
+	case WPS_VALTYPE_PTR:
+		ptr_value = (u8 *)os_malloc(length);
+		if (!ptr_value)
+			return -1; /* Memory allocation error */
+		os_memcpy(ptr_value, pos+4, length);
+		break;
+	default:
+		return -1;
+	}
+
+	if (0 != wps_create_tlv(tlv)) {
+		if (ptr_value)
+			os_free(ptr_value);
+		return -1; /* Memory allocation error */
+	}
+
+	(*tlv)->type = type;
+	(*tlv)->length = length;
+	(*tlv)->value_type = set->value_type;
+	switch ((*tlv)->value_type) {
+	case WPS_VALTYPE_BOOL:
+		(*tlv)->value.bool_ = (u8)b_value;
+		break;
+	case WPS_VALTYPE_U8:
+		(*tlv)->value.u8_ = u8_value;
+		break;
+	case WPS_VALTYPE_U16:
+		(*tlv)->value.u16_ = u16_value;
+		break;
+	case WPS_VALTYPE_U32:
+		(*tlv)->value.u32_ = u32_value;
+		break;
+	case WPS_VALTYPE_PTR:
+		(*tlv)->value.ptr_ = ptr_value;
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static int wps_add_tlv(struct wps_data *data, struct wps_tlv *tlv, Boolean allocate)
+{
+	const struct wps_tlv_set *set;
+
+	set = wps_match_tlv(tlv->type, tlv->length);
+	if (!set)
+		return -1;	/* Invalid tlv */
+
+	data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+				sizeof(struct wpa_tlv *) * (data->count + 1));
+
+	if (!data->tlvs)
+		return -1;	/* Memory allocation error */
+
+	if (allocate) {
+		Boolean fail_adding = 1;
+		struct wps_tlv * newTlv = (struct wps_tlv *)os_malloc(sizeof(struct wps_tlv));
+		do {
+			if (wps_create_tlv(&newTlv))
+				break;
+			os_memcpy(newTlv, tlv, sizeof(struct wps_tlv));
+			if (WPS_VALTYPE_PTR == set->value_type) {
+				if (tlv->length) {
+					newTlv->value.ptr_ = (u8 *)os_malloc(tlv->length);
+					if (!newTlv->value.ptr_) {
+						os_free(newTlv);
+						newTlv = 0;
+						break;
+					}
+					os_memcpy(newTlv->value.ptr_, tlv->value.ptr_, tlv->length);
+				} else
+					newTlv->value.ptr_ = 0;
+			}
+			data->tlvs[data->count++] = newTlv;
+			fail_adding = 0;
+		} while (0);
+
+		if (fail_adding) {
+			if (data->count)
+				data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+							sizeof(struct wpa_tlv *) * data->count);
+			else {
+				os_free(data->tlvs);
+				data->tlvs = 0;
+			}
+			return -1;
+		}
+	} else
+		data->tlvs[data->count++] = tlv;
+
+	return 0;
+}
+
+static int wps_del_tlv(struct wps_data *data, const u16 type)
+{
+	struct wps_tlv *tlv;
+	int index, found = 0;
+
+	for ( index = 0; index < data->count; index++, tlv++) {
+		tlv = data->tlvs[index];
+		if (tlv->type == type) {
+			wps_destroy_tlv(&tlv);
+			found = 1;
+			break;
+		}
+	}
+
+	if (found) {
+		for ( index++; index < data->count; index++, tlv++) {
+			data->tlvs[index-1] = data->tlvs[index];
+		}
+
+		if (0 < data->count - 1) {
+			data->tlvs = (struct wps_tlv **)os_realloc(data->tlvs,
+							sizeof(struct wps_tlv *) * (--data->count));
+			if (!data->tlvs)
+				return -1;
+		} else {
+			os_free(data->tlvs);
+			data->tlvs = 0;
+			data->count = 0;
+		}
+	}
+
+	return found?0:-1;
+}
+
+int wps_create_wps_data(struct wps_data **data)
+{
+	if (!data)
+		return -1;
+
+	*data = calloc(1, sizeof(struct wps_data));
+	if (!*data)
+		return -1;
+
+	return 0;
+}
+
+int wps_destroy_wps_data(struct wps_data **data)
+{
+	if (!data | !*data)
+		return -1;
+
+	while((*data)->count--)
+		wps_destroy_tlv(&((*data)->tlvs[(*data)->count]));
+
+	os_free((*data)->tlvs);
+	(*data)->tlvs = 0;
+
+	os_free(*data);
+	*data = 0;
+
+	return 0;
+}
+
+int wps_parse_wps_ie(const u8 *wps_ie, size_t wps_ie_len,
+	struct wps_data *data)
+{
+	const u8 *pos = wps_ie;
+
+	if (!wps_ie || 4 >= wps_ie_len || !data)
+		return -1;
+
+	if (pos[0] == GENERIC_INFO_ELEM && pos[1] >= 4 &&
+		os_memcmp(pos + 2, "\x00\x50\xf2\x04", 4) == 0) {
+		pos += 6;
+		return wps_parse_wps_data(pos, wps_ie_len - 6, data);
+	}
+
+	return -1;
+}
+
+int wps_parse_wps_data(const u8 *buf, size_t len,
+	struct wps_data *data)
+{
+	const u8 *pos = buf;
+	const u8 *end = buf + len;
+	struct wps_tlv *tlv;
+
+	if (!buf || 4 >= len || !data)
+		return -1;
+
+	data->count = 0;
+	while (pos + 4 < end) {
+		if (0 != wps_get_tlv(pos, end - pos, &tlv))
+			return -1;
+
+		wps_add_tlv(data, tlv, 0);
+
+		pos += 4 + tlv->length;
+	}
+
+	return 0;
+}
+
+int wps_write_wps_ie(struct wps_data * data, u8 **ie, u16 *length)
+{
+	int ret = -1;
+	u8 *buf = 0;
+	u16 len;
+
+	do {
+		if (!data || !ie || !length)
+			break;
+
+		*ie = 0;
+		*length = 0;
+
+		if (wps_write_wps_data(data, &buf, &len))
+			break;
+
+		if ((len + 4) > 255)
+			break;
+
+		*ie = (u8 *)os_malloc(len + 6);
+		if (!*ie)
+			break;
+		*(*ie) = GENERIC_INFO_ELEM;
+		*((*ie)+1) = (u8)(len + 4);
+		os_memcpy((*ie)+2, "\x00\x50\xf2\x04", 4);
+		os_memcpy((*ie)+6, buf, len);
+		*length = len + 6;
+
+		ret = 0;
+	} while (0);
+
+	if (buf)
+		os_free(buf);
+
+	if (ret) {
+		if (ie && *ie) {
+			os_free(*ie);
+			*ie = 0;
+		}
+		if (length)
+			*length = 0;
+	}
+
+	return ret;
+}
+
+int wps_write_wps_data(struct wps_data * data, u8 **buf, u16 *length)
+{
+	Boolean err = 0;
+	u8 index;
+	u8 *tmp;
+	struct wps_tlv *tlv;
+	if (!buf | !length)
+		return -1;
+
+	*buf = 0;
+	*length = 0;
+
+	if (!data)
+		return -1;
+
+	for (index = 0; index < data->count && !err; index++) {
+		tlv = data->tlvs[index];
+		*buf = (u8 *)os_realloc(*buf, *length + 4 + tlv->length);
+		if (!*buf) {
+			err = -1;
+			break;
+		}
+		tmp = *buf + *length;
+		*length += 4 + tlv->length;
+
+		WPA_PUT_BE16(tmp, tlv->type);
+		WPA_PUT_BE16(tmp+2, tlv->length);
+		switch(tlv->value_type) {
+		case WPS_VALTYPE_BOOL:
+			*(tmp+4) = (u8)tlv->value.bool_;
+			break;
+		case WPS_VALTYPE_U8:
+			*(tmp+4) = tlv->value.u8_;
+			break;
+		case WPS_VALTYPE_U16:
+			WPA_PUT_BE16(tmp+4, tlv->value.u16_);
+			break;
+		case WPS_VALTYPE_U32:
+			WPA_PUT_BE32(tmp+4, tlv->value.u32_);
+			break;
+		case WPS_VALTYPE_PTR:
+			os_memcpy(tmp+4, tlv->value.ptr_, tlv->length);
+			break;
+		default:
+			err = -1;
+			break;
+		}
+	}
+
+	if (err) {
+		os_free(*buf);
+		*buf = 0;
+		*length = 0;
+	}
+
+	return err;
+}
+
+int wps_get_value(const struct wps_data *data, u16 type, void *value, u16 *length)
+{
+	int ret = 0;
+	struct wps_tlv *tlv = 0;
+	int i;
+
+	for (i = 0; i < data->count; i++) {
+		if ((data->tlvs[i])->type == type) {
+			tlv = data->tlvs[i];
+			break;
+		}
+	}
+
+	if (!tlv)
+		return -1;
+
+	switch (tlv->value_type) {
+	case WPS_VALTYPE_BOOL:
+		if (value)
+			*(Boolean*)value = tlv->value.bool_;
+		break;
+	case WPS_VALTYPE_U8:
+		if (value)
+			*(u8 *)value = tlv->value.u8_;
+		break;
+	case WPS_VALTYPE_U16:
+		if (value)
+			*(u16 *)value = tlv->value.u16_;
+		break;
+	case WPS_VALTYPE_U32:
+		if (value)
+			*(u32 *)value = tlv->value.u32_;
+		break;
+	case WPS_VALTYPE_PTR:
+		if (!length || (*length < tlv->length))
+			ret = -1;
+		else if (value && tlv->value.ptr_)
+			os_memcpy(value, tlv->value.ptr_, tlv->length);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	if (length)
+		*length = tlv->length;
+
+	if (!value)
+		ret = -1;
+
+	return ret;
+}
+
+int wps_set_value(const struct wps_data *data, u16 type, void *value, u16 length)
+{
+	const struct wps_tlv_set *set = 0;
+	struct wps_tlv tlv;
+
+	if (!value && length)
+		return -1;
+
+	set = wps_get_tlv_set(type);
+	if (!set)
+		return -1;
+
+	tlv.value_type = set->value_type;
+	switch (tlv.value_type) {
+	case WPS_VALTYPE_BOOL:
+		tlv.type = type;
+		tlv.length = 1;
+		tlv.value.bool_ = *(Boolean*)value;
+		break;
+	case WPS_VALTYPE_U8:
+		tlv.type = type;
+		tlv.length = 1;
+		tlv.value.u8_ = *(u8*)value;
+		break;
+	case WPS_VALTYPE_U16:
+		tlv.type = type;
+		tlv.length = 2;
+		tlv.value.u16_ = *(u16*)value;
+		break;
+	case WPS_VALTYPE_U32:
+		tlv.type = type;
+		tlv.length = 4;
+		tlv.value.u32_ = *(u16*)value;
+		break;
+	case WPS_VALTYPE_PTR:
+		tlv.type = type;
+		tlv.length = length;
+		tlv.value.ptr_ = (u8*)value;
+		break;
+	default:
+		return -1;
+	}
+
+	return wps_add_tlv((struct wps_data *)data, &tlv, 1);
+}
+
+int wps_remove_value(struct wps_data *data, u16 type)
+{
+	return wps_del_tlv(data, type);
+}
+
+
+u8 wps_get_message_type(u8 *buf, size_t length)
+{
+	u8 msg_type = -1;
+	struct wps_data *wps = 0;
+
+	do {
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(buf, length, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg_type;
+}
+
+
Index: wps_opt_nfc.h
===================================================================
--- wps_opt_nfc.h	(revision 0)
+++ wps_opt_nfc.h	(revision 2)
@@ -0,0 +1,61 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_nfc.h
+//  Description: EAP-WPS NFC option source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_OPT_NFC_H
+#define WPS_OPT_NFC_H
+
+struct hostapd_config;
+struct wps_opt_nfc_sm;
+
+struct wps_opt_nfc_sm_ctx {
+	void *ctx;		/* pointer to arbitrary upper level context */
+	void *msg_ctx;
+
+	int (*get_own_addr)(void *ctx, u8* mac);
+	struct hostapd_config *(*get_conf)(void *ctx);
+};
+
+struct wps_opt_nfc_sm *wps_opt_nfc_sm_init(struct wps_opt_nfc_sm_ctx *ctx);
+void wps_opt_nfc_sm_deinit(struct wps_opt_nfc_sm *sm);
+void wps_opt_nfc_sm_set_ifname(struct wps_opt_nfc_sm *sm, const char *nfcname);
+void wps_opt_nfc_sm_step(struct wps_opt_nfc_sm *sm);
+
+int wps_opt_nfc_cancel_nfc_comand(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_read_password_token(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_write_password_token(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_read_config_token(struct wps_opt_nfc_sm *sm);
+int wps_opt_nfc_write_config_token(struct wps_opt_nfc_sm *sm);
+
+
+#endif /* WPS_OPT_NFC_H */
Index: base64.h
===================================================================
--- base64.h	(revision 0)
+++ base64.h	(revision 2)
@@ -0,0 +1,23 @@
+/*
+ * Base64 encoding/decoding (RFC1341)
+ * Copyright (c) 2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef BASE64_H
+#define BASE64_h
+
+unsigned char * base64_encode(const unsigned char *src, size_t len,
+			      size_t *out_len);
+unsigned char * base64_decode(const unsigned char *src, size_t len,
+			      size_t *out_len);
+
+#endif /* BASE64_H */
Index: upnp_wps_device.c
===================================================================
--- upnp_wps_device.c	(revision 0)
+++ upnp_wps_device.c	(revision 2)
@@ -0,0 +1,1755 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_device.c
+//  Description: EAP-WPS UPnP device source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include <upnp/ithread.h>
+#include <upnp/upnp.h>
+#include <upnp/upnptools.h>
+#include "common.h"
+#include "upnp_wps_common.h"
+#include "upnp_wps_device.h"
+#include "base64.h"
+#include <stdlib.h>
+
+#include <sys/ioctl.h>
+#include <linux/if.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <linux/route.h>
+#include <errno.h>
+
+#define WPS_MAXVARS		11
+#define WPS_MAX_VAL_LEN	255
+
+#define WPS_MAXACTIONS	14
+
+#define DEFAULT_TIMEOUT	1801
+
+
+struct wps_device_vars {
+	int cnt;
+	char *name[WPS_MAXVARS];
+	char *val[WPS_MAXVARS];
+};
+
+
+struct wps_device_actions {
+	int cnt;
+	char *name[WPS_MAXACTIONS];
+	int (*action[WPS_MAXACTIONS])(struct upnp_wps_device_sm *sm,
+				  IXML_Document *req,
+				  IXML_Document **rsp,
+				  char **err_string);
+};
+
+
+struct wps_device_service {
+	struct wps_device_vars var;
+	struct wps_device_actions act;
+};
+
+
+struct upnp_wps_device_sm {
+	struct upnp_wps_device_ctx *ctx;
+	void *priv;
+	char *root_dir;
+	char *desc_url;
+	int initialized;
+	ithread_mutex_t mutex_device;
+	int mutex_initialized;
+	UpnpDevice_Handle device_handle;
+	char udn[NAME_SIZE];
+	char service_id[NAME_SIZE];
+	char service_type[NAME_SIZE];
+	struct wps_device_service service;
+};
+
+
+/*
+static const char *wps_device_type = "urn:schemas-wifialliance-org:device:WFADevice:1";
+*/
+static const char *wps_service_type = "urn:schemas-wifialliance-org:service:WFAWLANConfig:1";
+
+enum WPS_VAR {
+	WPS_VAR_FIRST = 0,
+	WPS_VAR_MESSAGE = WPS_VAR_FIRST,
+	WPS_VAR_INMESSAGE,
+	WPS_VAR_OUTMESSAGE,
+	WPS_VAR_DEVICEINFO,
+	WPS_VAR_APSETTINGS,
+	WPS_VAR_APSTATUS,
+	WPS_VAR_STASETTINGS,
+	WPS_VAR_STASTATUS,
+	WPS_VAR_WLANEVENT,
+	WPS_VAR_WLANEVENTTYPE,
+	WPS_VAR_WLANEVENTMAC,
+	WPS_VAR_LAST = WPS_VAR_WLANEVENTMAC
+};
+
+
+static const char *wps_service_var_name[WPS_MAXVARS] = {
+	"Message",
+	"InMessage",
+	"OutMessage",
+	"DeviceInfo",
+	"APSettings",
+	"APStatus",
+	"STASettings",
+	"STAStatus",
+	"WLANEvent",
+	"WLANEventType",
+	"WLANEventMAC"
+};
+
+
+static const char *wps_service_var_default_val[WPS_MAXVARS] = {
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	""
+};
+
+
+enum WPS_ACTION {
+	WPS_ACTION_GETDEVICEINFO = 0,
+	WPS_ACTION_PUTMESSAGE,
+	WPS_ACTION_GETAPSETTINGS,
+	WPS_ACTION_SETAPSETTINGS,
+	WPS_ACTION_DELAPSETTINGS,
+	WPS_ACTION_GETSTASETTINGS,
+	WPS_ACTION_SETSTASETTINGS,
+	WPS_ACTION_DELSTASETTINGS,
+	WPS_ACTION_PUTWLANRESPONSE,
+	WPS_ACTION_SETSELECTEDREGISTRAR,
+	WPS_ACTION_REBOOTAP,
+	WPS_ACTION_RESETAP,
+	WPS_ACTION_REBOOTSTA,
+	WPS_ACTION_RESETSTA,
+};
+
+
+static const char *wps_service_action_name[WPS_MAXACTIONS] = {
+	"GetDeviceInfo",
+	"PutMessage",
+	"GetAPSettings",
+	"SetAPSettings",
+	"DelAPSettings",
+	"GetSTASettings",
+	"SetSTASettings",
+	"DelSTASettings",
+	"PutWLANResponse",
+	"SetSelectedRegistrar",
+	"RebootAP",
+	"ResetAP",
+	"RebootSTA",
+	"ResetSTA"
+};
+
+
+struct upnp_wps_device_sm *
+upnp_wps_device_init(struct upnp_wps_device_ctx *ctx,
+					 char *root_dir,
+					 char *desc_url,
+					 void *priv)
+{
+	struct upnp_wps_device_sm *sm = 0;
+	do {
+		if (!root_dir || !desc_url)
+			break;
+
+		sm = wpa_zalloc(sizeof(*sm));
+		if (!sm)
+			break;
+		sm->ctx = ctx;
+		sm->priv = priv;
+		sm->root_dir = os_strdup(root_dir);
+		sm->desc_url = os_strdup(desc_url);
+		sm->device_handle = -1;
+	} while (0);
+
+	return sm;
+}
+
+
+void
+upnp_wps_device_deinit(struct upnp_wps_device_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+		upnp_wps_device_stop(sm);
+
+		if (sm->root_dir)
+			os_free(sm->root_dir);
+		if (sm->desc_url)
+			os_free(sm->desc_url);
+
+		os_free(sm->ctx);
+		os_free(sm);
+	} while (0);
+}
+
+
+int add_ssdp_network(char *net_if)
+{
+#define SSDP_TARGET		"239.0.0.0"
+#define SSDP_NETMASK	"255.0.0.0"
+	int ret = -1;
+	SOCKET sock = -1;
+	struct rtentry rt;
+	struct sockaddr_in *sin;
+
+	do {
+		if (!net_if)
+			break;
+
+		os_memset(&rt, 0, sizeof(rt));
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+		if (-1 == sock)
+			break;
+
+		rt.rt_dev = net_if;
+		sin = (struct sockaddr_in *)&rt.rt_dst;
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0;
+		sin->sin_addr.s_addr = inet_addr(SSDP_TARGET);
+		sin = (struct sockaddr_in *)&rt.rt_genmask;
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0;
+		sin->sin_addr.s_addr = inet_addr(SSDP_NETMASK);
+		rt.rt_flags = RTF_UP;
+		if (ioctl(sock, SIOCADDRT, &rt) < 0) {
+			if (EEXIST != errno)
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (-1 != sock)
+		close(sock);
+
+	return ret;
+#undef SSDP_TARGET
+#undef SSDP_NETMASK
+}
+
+
+int get_ip_address(char *net_if, char **ipaddr)
+{
+#define MAX_INTERFACES 256
+	int ret = -1;
+	char buf[MAX_INTERFACES * sizeof(struct ifreq)];
+	struct ifconf conf;
+	struct ifreq *req;
+	struct sockaddr_in sock_addr;
+	int sock = -1;
+	int i;
+
+	do {
+		if (!ipaddr)
+			break;
+		*ipaddr = 0;
+
+		if (!net_if)
+			break;
+
+		if(0 > (sock = socket(AF_INET, SOCK_DGRAM, 0)))
+			break;
+
+		conf.ifc_len = sizeof(buf);
+		conf.ifc_ifcu.ifcu_buf = (caddr_t)buf;
+		if (0 > ioctl(sock, SIOCGIFCONF, &conf))
+			break;
+
+		for( i = 0; i < conf.ifc_len; ) {
+			req = (struct ifreq *)((caddr_t)conf.ifc_req + i);
+			i += sizeof(*req);
+
+			if (AF_INET == req->ifr_addr.sa_family) {
+				if (!os_strcmp(net_if, req->ifr_name)) {
+					size_t len;
+					os_memcpy(&sock_addr, &req->ifr_addr, sizeof(req->ifr_addr));
+					len = os_strlen(inet_ntoa(sock_addr.sin_addr)) + 1;
+					*ipaddr = wpa_zalloc(len);
+					if (!*ipaddr)
+						break;
+					os_snprintf(*ipaddr, len, "%s", inet_ntoa(sock_addr.sin_addr));
+					ret = 0;
+					break;
+				}
+			}
+		}
+	} while (0);
+
+	if (0 <= sock)
+		close(sock);
+
+	return ret;
+#undef MAX_INTERFACES
+}
+
+
+int get_mac_from_ip(char *ipaddr, char mac[18])
+{
+#define MAX_INTERFACES 256
+	int ret = -1;
+	char buf[MAX_INTERFACES * sizeof(struct ifreq)];
+	struct ifconf conf;
+	struct ifreq *req;
+	struct sockaddr_in sock_addr;
+	int sock = -1;
+	int i;
+
+	do {
+		if(0 > (sock = socket(AF_INET, SOCK_DGRAM, 0)))
+			break;
+
+		conf.ifc_len = sizeof(buf);
+		conf.ifc_ifcu.ifcu_buf = (caddr_t)buf;
+		if (0 > ioctl(sock, SIOCGIFCONF, &conf))
+			break;
+
+		for( i = 0; i < conf.ifc_len; ) {
+			req = (struct ifreq *)((caddr_t)conf.ifc_req + i);
+			i += sizeof(*req);
+
+			if (AF_INET == req->ifr_addr.sa_family) {
+				os_memcpy(&sock_addr, &req->ifr_addr, sizeof(req->ifr_addr));
+				if (!os_strcmp(ipaddr, inet_ntoa(sock_addr.sin_addr))) {
+					os_snprintf(mac, 18, "%02X:%02X:%02X:%02X:%02X:%02X",
+					(u8)(req->ifr_hwaddr.sa_data[0]),
+					(u8)(req->ifr_hwaddr.sa_data[1]),
+					(u8)(req->ifr_hwaddr.sa_data[2]),
+					(u8)(req->ifr_hwaddr.sa_data[3]),
+					(u8)(req->ifr_hwaddr.sa_data[4]),
+					(u8)(req->ifr_hwaddr.sa_data[5]));
+					ret = 0;
+					break;
+				}
+			}
+		}
+	} while (0);
+
+	if (0 <= sock)
+		close(sock);
+
+	return ret;
+#undef MAX_INTERFACES
+}
+
+
+static int
+upnp_wps_device_encode_base64(u8 *data, size_t data_len,
+							  char **encoded, size_t *encoded_len)
+{
+	int ret = -1;
+
+	do {
+		if (!data || !encoded || !encoded_len)
+			break;
+		*encoded = 0;
+		*encoded_len = 0;
+
+		*encoded = (char *)base64_encode(data,
+								data_len, encoded_len);
+		if (!*encoded)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (encoded && *encoded) {
+			os_free(*encoded);
+			*encoded = 0;
+		}
+		if (encoded_len)
+			*encoded_len = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_decode_base64(char *data, size_t data_len,
+								  u8 **decoded, size_t *decoded_len)
+{
+	int ret = -1;
+
+	do {
+		if (!data || !decoded || !decoded_len)
+			break;
+		*decoded = 0;
+		*decoded_len = 0;
+
+		*decoded = base64_decode((u8 *)data,
+								 data_len, decoded_len);
+		if (!*decoded)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (decoded && *decoded) {
+			os_free(*decoded);
+			*decoded = 0;
+		}
+		if (decoded_len)
+			*decoded_len = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_handle_subscription_request(struct upnp_wps_device_sm *sm,
+											struct Upnp_Subscription_Request *event)
+{
+	int ret = -1;
+	do {
+		if (!sm || !event)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_device);
+
+		if (!os_strcmp(event->UDN, sm->udn) &&
+			!os_strcmp(event->ServiceId, sm->service_id)) {
+			UpnpAcceptSubscription(sm->device_handle,
+								   event->UDN,
+								   event->ServiceId,
+								   (const char **)sm->service.var.name,
+								   (const char **)sm->service.var.val,
+								   sm->service.var.cnt,
+								   event->Sid);
+			ret = 0;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_device);
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_handle_get_var_request(struct upnp_wps_device_sm *sm,
+									   struct Upnp_State_Var_Request *event)
+{
+	int ret = -1, i;
+
+	do {
+		if (!sm || !event)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_device);
+
+		if (!os_strcmp(event->DevUDN, sm->udn) &&
+			!os_strcmp(event->ServiceID, sm->service_id)) {
+			for (i = 0; i < sm->service.var.cnt; i++) {
+				if (!os_strcmp(event->StateVarName, sm->service.var.name[i])) {
+					event->CurrentVal =
+						ixmlCloneDOMString(sm->service.var.val[i]);
+					ret = 0;
+					break;
+				}
+			}
+		}
+
+		if (!ret)
+			event->ErrCode = UPNP_E_SUCCESS;
+		else
+			event->ErrCode = 404;
+
+		ithread_mutex_unlock(&sm->mutex_device);
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_handle_action_request(struct upnp_wps_device_sm *sm,
+									  struct Upnp_Action_Request *event)
+{
+	int ret = -1, i;
+	char *str_error = 0;
+
+	do {
+		if (!sm || !event)
+			break;
+
+		ithread_mutex_lock(&sm->mutex_device);
+
+		if (!os_strcmp(event->DevUDN, sm->udn) &&
+			!os_strcmp(event->ServiceID, sm->service_id)) {
+			for(i = 0; i < sm->service.act.cnt; i++) {
+				if (!os_strcmp(event->ActionName, sm->service.act.name[i])) {
+					if (sm->service.act.action[i])
+						event->ErrCode = sm->service.act.action[i](
+														sm,
+														event->ActionRequest,
+														&event->ActionResult,
+														&str_error);
+					else {
+						str_error = os_strdup("Function not found");
+						event->ErrCode = 501;
+					}
+					ret = 0;
+				}
+			}
+		}
+
+		if (!ret && str_error)
+			os_strncpy(event->ErrStr, str_error, sizeof(event->ErrStr));
+		else if (ret) {
+			event->ActionResult = 0;
+			os_strncpy(event->ErrStr, "Invalid Action", sizeof(event->ErrStr));
+			event->ErrCode = 401;
+		}
+
+		ithread_mutex_unlock(&sm->mutex_device);
+	} while (0);
+
+	if (str_error)
+		os_free(str_error);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_callback_event_handler(Upnp_EventType event_type,
+									   void *event, void *cookie)
+{
+	switch (event_type) {
+	/* GENA */
+	case UPNP_EVENT_SUBSCRIPTION_REQUEST:
+	{
+		struct upnp_wps_device_sm *sm = (struct upnp_wps_device_sm *)cookie;
+		struct Upnp_Subscription_Request *sub_event = event;
+		upnp_wps_device_handle_subscription_request(sm, sub_event);
+		break;
+	}
+	/* SOAP */
+	case UPNP_CONTROL_GET_VAR_REQUEST:
+	{
+		struct upnp_wps_device_sm *sm = (struct upnp_wps_device_sm *)cookie;
+		struct Upnp_State_Var_Request *var_event = event;
+		upnp_wps_device_handle_get_var_request(sm, var_event);
+		break;
+	}
+	case UPNP_CONTROL_ACTION_REQUEST:
+	{
+		struct upnp_wps_device_sm *sm = (struct upnp_wps_device_sm *)cookie;
+		struct Upnp_Action_Request *action_event = event;
+		upnp_wps_device_handle_action_request(sm, action_event);
+		break;
+	}
+	default:
+		/* ignore */
+		break;
+	}
+
+	return 0;
+}
+
+
+static int
+upnp_wps_device_set_var(struct upnp_wps_device_sm *sm,
+						int var, char *val)
+{
+	int ret = -1;
+
+	do {
+		if (!sm || ((WPS_VAR_FIRST > var) || (WPS_VAR_LAST < var)))
+			break;
+
+		if (sm->service.var.val[var]) {
+			os_free(sm->service.var.val[var]);
+			sm->service.var.val[var] = 0;
+		}
+
+		if (val)
+			sm->service.var.val[var] = os_strdup(val);
+		else
+			sm->service.var.val[var] = os_strdup("");
+
+		UpnpNotify(sm->device_handle,
+				   sm->udn,
+				   sm->service_id,
+				   (const char **)&sm->service.var.name[var],
+				   (const char **)&sm->service.var.val[var], 1);
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+upnp_wps_device_send_wlan_event(struct upnp_wps_device_sm *sm,
+								int ev_type,
+								u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+	char type[2];
+	char mac[32];
+	u8 *raw = 0;
+	size_t raw_len;
+	char *val = 0;
+	size_t val_len;
+	int pos = 0;
+
+	do {
+		if (!sm)
+			break;
+
+		os_snprintf(type, sizeof(type), "%1u", ev_type);
+
+		if (get_mac_from_ip(UpnpGetServerIpAddress(), mac))
+			break;
+
+		raw_len = 1 + 17 + ((msg && msg_len)?msg_len:0);
+		raw = (u8 *)wpa_zalloc(raw_len);
+		if (!raw)
+			break;
+
+		*(raw + pos) = (u8)ev_type;
+		pos += 1;
+		os_memcpy(raw + pos, mac, 17);
+		pos += 17;
+		if (msg && msg_len) {
+			os_memcpy(raw + pos, msg, msg_len);
+			pos += msg_len;
+		}
+
+		if (upnp_wps_device_encode_base64(raw, raw_len, &val, &val_len))
+			break;
+
+		upnp_wps_device_set_var(sm, WPS_VAR_WLANEVENTTYPE, type);
+		upnp_wps_device_set_var(sm, WPS_VAR_WLANEVENTMAC, mac);
+		upnp_wps_device_set_var(sm, WPS_VAR_WLANEVENT, val);
+
+		ret = 0;
+	} while (0);
+
+	if (raw) os_free(raw);
+	if (val) os_free(val);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_get_device_info(struct upnp_wps_device_sm *sm,
+								IXML_Document *req,
+								IXML_Document **rsp,
+								char **err_string)
+{
+	int ret = 501;
+	u8 *raw_msg = 0;
+	size_t raw_msg_len;
+	char *device_info = 0;
+	size_t device_info_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string)
+			break;
+		*rsp = 0;
+		*err_string = 0;
+
+		if (!sm->ctx->received_req_get_device_info)
+			break;
+
+		if (sm->ctx->received_req_get_device_info(sm->priv, &raw_msg, &raw_msg_len))
+			break;
+
+		(void)upnp_wps_device_encode_base64(raw_msg, raw_msg_len, &device_info, &device_info_len);
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "GetDeviceInfo",
+									sm->service_type,
+									"NewDeviceInfo", device_info?device_info:""))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_DEVICEINFO, device_info);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (raw_msg) os_free(raw_msg);
+	if (device_info) os_free(device_info);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_put_message(struct upnp_wps_device_sm *sm,
+							IXML_Document *req,
+							IXML_Document **rsp,
+							char **err_string)
+{
+	int ret = 501;
+	char *in_msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+	u8 *raw_msg = 0;
+	size_t raw_msg_len;
+	char *out_msg = 0;
+	size_t out_msg_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewInMessage", &in_msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(in_msg, os_strlen(in_msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_put_message)
+			break;
+
+		if (sm->ctx->received_req_put_message(sm->priv, decoded, decoded_len,
+											  &raw_msg, &raw_msg_len))
+			break;
+
+		(void)upnp_wps_device_encode_base64(raw_msg, raw_msg_len, &out_msg, &out_msg_len);
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "PutMessage",
+									sm->service_type,
+									"NewOutMessage", out_msg?out_msg:""))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_INMESSAGE, in_msg);
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_OUTMESSAGE, out_msg);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (in_msg) os_free(in_msg);
+	if (decoded) os_free(decoded);
+	if (raw_msg) os_free(raw_msg);
+	if (out_msg) os_free(out_msg);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_get_ap_settings(struct upnp_wps_device_sm *sm,
+								IXML_Document *req,
+								IXML_Document **rsp,
+								char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+	u8 *raw_msg = 0;
+	size_t raw_msg_len;
+	char *ap_settings = 0;
+	size_t ap_settings_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_get_ap_settings)
+			break;
+
+		if (sm->ctx->received_req_get_ap_settings(sm->priv, decoded, decoded_len,
+											  &raw_msg, &raw_msg_len))
+			break;
+
+		if (upnp_wps_device_encode_base64(raw_msg, raw_msg_len, &ap_settings, &ap_settings_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "GetAPSettings",
+									sm->service_type,
+									"NewAPSettings", ap_settings?ap_settings:""))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_APSETTINGS, ap_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+	if (raw_msg) os_free(raw_msg);
+	if (ap_settings) os_free(ap_settings);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_set_ap_settings(struct upnp_wps_device_sm *sm,
+								IXML_Document *req,
+								IXML_Document **rsp,
+								char **err_string)
+{
+	int ret = 501;
+	char *ap_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewAPSettings", &ap_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(ap_settings, os_strlen(ap_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_set_ap_settings)
+			break;
+
+		if (sm->ctx->received_req_set_ap_settings(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "SetAPSettings", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_APSETTINGS, ap_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (ap_settings) os_free(ap_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_del_ap_settings(struct upnp_wps_device_sm *sm,
+								IXML_Document *req,
+								IXML_Document **rsp,
+								char **err_string)
+{
+	int ret = 501;
+	char *ap_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewAPSettings", &ap_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(ap_settings, os_strlen(ap_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_del_ap_settings)
+			break;
+
+		if (sm->ctx->received_req_del_ap_settings(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "DelAPSettings", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_APSETTINGS, ap_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (ap_settings) os_free(ap_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_get_sta_settings(struct upnp_wps_device_sm *sm,
+								 IXML_Document *req,
+								 IXML_Document **rsp,
+								 char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+	u8 *raw_msg = 0;
+	size_t raw_msg_len;
+	char *sta_settings = 0;
+	size_t sta_settings_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_get_sta_settings)
+			break;
+
+		if (sm->ctx->received_req_get_sta_settings(sm->priv, decoded, decoded_len,
+											  &raw_msg, &raw_msg_len))
+			break;
+
+		if (upnp_wps_device_encode_base64(raw_msg, raw_msg_len, &sta_settings, &sta_settings_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "GetSTASettings",
+									sm->service_type,
+									"NewSTASettings", sta_settings?sta_settings:""))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_STASETTINGS, sta_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+	if (raw_msg) os_free(raw_msg);
+	if (sta_settings) os_free(sta_settings);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_set_sta_settings(struct upnp_wps_device_sm *sm,
+								 IXML_Document *req,
+								 IXML_Document **rsp,
+								 char **err_string)
+{
+	int ret = 501;
+	char *sta_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewSTASettings", &sta_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(sta_settings, os_strlen(sta_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_set_sta_settings)
+			break;
+
+		if (sm->ctx->received_req_set_sta_settings(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "SetSTASettings", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_STASETTINGS, sta_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (sta_settings) os_free(sta_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_del_sta_settings(struct upnp_wps_device_sm *sm,
+								 IXML_Document *req,
+								 IXML_Document **rsp,
+								 char **err_string)
+{
+	int ret = 501;
+	char *sta_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewSTASettings", &sta_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(sta_settings, os_strlen(sta_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_del_sta_settings)
+			break;
+
+		if (sm->ctx->received_req_del_sta_settings(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "DelSTASettings", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_STASETTINGS, sta_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (sta_settings) os_free(sta_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_put_wlan_response(struct upnp_wps_device_sm *sm,
+								  IXML_Document *req,
+								  IXML_Document **rsp,
+								  char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+	char *type = 0;
+	int ev_type;
+	char *mac = 0;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string)
+			break;
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (upnp_get_first_document_item(req, "NewWLANEventType", &type))
+			break;
+		ev_type = atoi(type);
+
+		if (upnp_get_first_document_item(req, "NewWLANEventMAC", &mac))
+			break;
+
+		if (!sm->ctx->received_req_put_wlan_event_response)
+			break;
+
+		if (sm->ctx->received_req_put_wlan_event_response(sm->priv, ev_type,
+														  decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "PutWLANResponse", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_WLANEVENTTYPE, type);
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_WLANEVENTMAC, mac);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+	if (type) os_free(type);
+	if (mac) os_free(mac);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_set_selected_registrar(struct upnp_wps_device_sm *sm,
+									   IXML_Document *req,
+									   IXML_Document **rsp,
+									   char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_set_selected_registrar)
+			break;
+
+		if (sm->ctx->received_req_set_selected_registrar(sm->priv,
+														 decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "SetSelectedRegistrar", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_reboot_ap(struct upnp_wps_device_sm *sm,
+						  IXML_Document *req,
+						  IXML_Document **rsp,
+						  char **err_string)
+{
+	int ret = 501;
+	char *ap_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewAPSettings", &ap_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(ap_settings, os_strlen(ap_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_reboot_ap)
+			break;
+
+		if (sm->ctx->received_req_reboot_ap(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "RebootAP", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_APSETTINGS, ap_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (ap_settings) os_free(ap_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_reset_ap(struct upnp_wps_device_sm *sm,
+						 IXML_Document *req,
+						 IXML_Document **rsp,
+						 char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_reset_ap)
+			break;
+
+		if (sm->ctx->received_req_reset_ap(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "ResetAP", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_reboot_sta(struct upnp_wps_device_sm *sm,
+						   IXML_Document *req,
+						   IXML_Document **rsp,
+						   char **err_string)
+{
+	int ret = 501;
+	char *sta_settings = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewSTASettings", &sta_settings))
+			break;
+
+		if (upnp_wps_device_decode_base64(sta_settings, os_strlen(sta_settings),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_reboot_sta)
+			break;
+
+		if (sm->ctx->received_req_reboot_sta(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "RebootSTA", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_STASETTINGS, sta_settings);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (sta_settings) os_free(sta_settings);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_reset_sta(struct upnp_wps_device_sm *sm,
+						  IXML_Document *req,
+						  IXML_Document **rsp,
+						  char **err_string)
+{
+	int ret = 501;
+	char *msg = 0;
+	u8 *decoded = 0;
+	size_t decoded_len;
+
+	do {
+		if (!sm || !sm->ctx || !req || !rsp || !err_string) {
+			break;
+		}
+		*rsp = 0;
+		*err_string = 0;
+
+		if (upnp_get_first_document_item(req, "NewMessage", &msg))
+			break;
+
+		if (upnp_wps_device_decode_base64(msg, os_strlen(msg),
+										  &decoded, &decoded_len))
+			break;
+
+		if (!sm->ctx->received_req_reset_sta)
+			break;
+
+		if (sm->ctx->received_req_reset_sta(sm->priv, decoded, decoded_len))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpAddToActionResponse(rsp, "ResetSTA", sm->service_type, 0, 0))
+			break;
+
+		(void)upnp_wps_device_set_var(sm, WPS_VAR_MESSAGE, msg);
+
+		ret = UPNP_E_SUCCESS;
+	} while (0);
+
+	if (msg) os_free(msg);
+	if (decoded) os_free(decoded);
+
+	if (UPNP_E_SUCCESS != ret) {
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (err_string)
+			*err_string = os_strdup("Internal Error");
+	}
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_deinit_service(struct upnp_wps_device_sm *sm)
+{
+	int ret = -1, i;
+
+	do {
+		if (!sm)
+			break;
+
+		for (i = 0; i < sm->service.var.cnt; i++) {
+			if (sm->service.var.name[i]) {
+				os_free(sm->service.var.name[i]);
+				sm->service.var.name[i] = 0;
+			}
+			if (sm->service.var.val[i]) {
+				os_free(sm->service.var.val[i]);
+				sm->service.var.val[i] = 0;
+			}
+		}
+
+		for (i = 0; i < sm->service.act.cnt; i++) {
+			if (sm->service.act.name[i]) {
+				os_free(sm->service.act.name[i]);
+				sm->service.act.name[i] = 0;
+			}
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+upnp_wps_device_init_service(struct upnp_wps_device_sm *sm,
+							 char *desc_url)
+{
+	int ret = -1, i;
+	IXML_Document *desc_doc = 0;
+	char *udn = 0, *service_id = 0, *scpd_url = 0,
+		 *control_url = 0, *event_url = 0;
+
+	do {
+		if (!sm || !desc_url)
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpDownloadXmlDoc(desc_url, &desc_doc))
+			break;
+
+		if (upnp_get_first_document_item(desc_doc, "UDN", &udn))
+			break;
+
+		if (!upnp_find_service(desc_doc, desc_url, (char *)wps_service_type,
+							   &service_id, &scpd_url, &control_url, &event_url))
+			break;
+
+		os_strncpy(sm->udn, udn, sizeof(sm->udn));
+		os_strncpy(sm->service_id, service_id, sizeof(sm->service_id));
+		os_strncpy(sm->service_type, wps_service_type, sizeof(sm->service_type));
+
+		sm->service.var.cnt = WPS_MAXVARS;
+		for (i = 0; i < sm->service.var.cnt; i++) {
+			sm->service.var.name[i] = os_strdup(wps_service_var_name[i]);
+			sm->service.var.val[i] = os_strdup(wps_service_var_default_val[i]);
+		}
+
+		sm->service.act.cnt = WPS_MAXACTIONS;
+		for (i = 0; i < sm->service.act.cnt; i++) {
+			sm->service.act.name[i] = os_strdup(wps_service_action_name[i]);
+			switch (i) {
+			case WPS_ACTION_GETDEVICEINFO:
+				sm->service.act.action[i] = upnp_wps_device_get_device_info;
+				break;
+			case WPS_ACTION_PUTMESSAGE:
+				sm->service.act.action[i] = upnp_wps_device_put_message;
+				break;
+			case WPS_ACTION_GETAPSETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_get_ap_settings;
+				break;
+			case WPS_ACTION_SETAPSETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_set_ap_settings;
+				break;
+			case WPS_ACTION_DELAPSETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_del_ap_settings;
+				break;
+			case WPS_ACTION_GETSTASETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_get_sta_settings;
+				break;
+			case WPS_ACTION_SETSTASETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_set_sta_settings;
+				break;
+			case WPS_ACTION_DELSTASETTINGS:
+				sm->service.act.action[i] = upnp_wps_device_del_sta_settings;
+				break;
+			case WPS_ACTION_PUTWLANRESPONSE:
+				sm->service.act.action[i] = upnp_wps_device_put_wlan_response;
+				break;
+			case WPS_ACTION_SETSELECTEDREGISTRAR:
+				sm->service.act.action[i] = upnp_wps_device_set_selected_registrar;
+				break;
+			case WPS_ACTION_REBOOTAP:
+				sm->service.act.action[i] = upnp_wps_device_reboot_ap;
+				break;
+			case WPS_ACTION_RESETAP:
+				sm->service.act.action[i] = upnp_wps_device_reset_ap;
+				break;
+			case WPS_ACTION_REBOOTSTA:
+				sm->service.act.action[i] = upnp_wps_device_reboot_sta;
+				break;
+			case WPS_ACTION_RESETSTA:
+				sm->service.act.action[i] = upnp_wps_device_reset_sta;
+				break;
+			default:
+				break;
+			}
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		(void)upnp_wps_device_deinit_service(sm);
+
+	if (desc_doc) ixmlDocument_free(desc_doc);
+	if (udn) os_free(udn);
+	if (service_id) os_free(service_id);
+	if (scpd_url) os_free(scpd_url);
+	if (control_url) os_free(control_url);
+	if (event_url) os_free(event_url);
+
+	return ret;
+}
+
+
+int
+upnp_wps_device_start(struct upnp_wps_device_sm *sm, char *net_if)
+{
+	int ret = -1;
+	char *ip_address = 0;
+	u16 port;
+	char desc_url[BUFSIZ];
+
+	do {
+		if (!sm || !net_if)
+			break;
+
+		if (sm->initialized)
+			upnp_wps_device_stop(sm);
+
+		ithread_mutex_init(&sm->mutex_device, 0);
+		sm->mutex_initialized = 1;
+
+		if (add_ssdp_network(net_if))
+			break;
+
+		if (get_ip_address(net_if, &ip_address))
+			break;
+
+		if (UPNP_E_SUCCESS != UpnpInit(ip_address, 0))
+			break;
+		sm->initialized++;
+
+		if (os_strcmp(UpnpGetServerIpAddress(), ip_address))
+			break;
+
+		port = UpnpGetServerPort();
+
+		if (UPNP_E_SUCCESS !=
+			UpnpSetWebServerRootDir(sm->root_dir))
+			break;
+
+		os_snprintf(desc_url, sizeof(desc_url), "http://%s:%u/%s", ip_address, port,
+				 sm->desc_url);
+		if (UPNP_E_SUCCESS !=
+			UpnpRegisterRootDevice(desc_url,
+								   upnp_wps_device_callback_event_handler,
+								   (void *)sm, &sm->device_handle))
+			break;
+		sm->initialized++;
+
+		if (upnp_wps_device_init_service(sm, desc_url))
+			break;
+
+		if (UPNP_E_SUCCESS !=
+			UpnpSendAdvertisement(sm->device_handle, DEFAULT_TIMEOUT))
+				break;
+
+		ret = 0;
+	} while (0);
+
+	if (ip_address)
+		os_free(ip_address);
+
+	return ret;
+}
+
+
+int
+upnp_wps_device_stop(struct upnp_wps_device_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+
+		if (!sm->initialized)
+			break;
+
+		if (sm->mutex_initialized)
+			ithread_mutex_lock(&sm->mutex_device);
+		if (0 <= (int)sm->device_handle) {
+			UpnpUnRegisterRootDevice(sm->device_handle);
+			sm->device_handle = -1;
+			sm->initialized--;
+		}
+
+		(void)upnp_wps_device_deinit_service(sm);
+
+		if (sm->initialized) {
+			UpnpFinish();
+			sm->initialized--;
+		}
+
+		if (sm->mutex_initialized) {
+			ithread_mutex_unlock(&sm->mutex_device);
+			ithread_mutex_destroy(&sm->mutex_device);
+			sm->mutex_initialized = 0;
+		}
+	} while (0);
+
+	if (sm)
+		sm->initialized = 0;
+	return 0;
+}
+
+
Index: wps_parser.h
===================================================================
--- wps_parser.h	(revision 0)
+++ wps_parser.h	(revision 2)
@@ -0,0 +1,65 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_parser.h
+//  Description: EAP-WPS parser source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_PARSER_H
+#define WPS_PARSER_H
+
+#define WPS_VALTYPE_BOOL	0
+#define WPS_VALTYPE_U8		1
+#define WPS_VALTYPE_U16		2
+#define WPS_VALTYPE_U32		3
+#define	WPS_VALTYPE_PTR		4
+
+struct wps_tlv;
+
+struct wps_data {
+	u8 count;
+	struct wps_tlv **tlvs;
+};
+
+int wps_create_wps_data(struct wps_data **data);
+int wps_destroy_wps_data(struct wps_data **data);
+
+int wps_parse_wps_ie(const u8 *wps_ie, size_t wps_ie_len, struct wps_data *data);
+int wps_parse_wps_data(const u8 *buf, size_t len, struct wps_data *data);
+
+int wps_write_wps_ie(struct wps_data * data, u8 **ie, u16 *length);
+int wps_write_wps_data(struct wps_data * data, u8 **buf, u16 *length);
+
+int wps_get_value(const struct wps_data *data, u16 type, void *value, u16 *length);
+int wps_set_value(const struct wps_data *data, u16 type, void *value, u16 length);
+int wps_remove_value(struct wps_data *data, u16 type);
+
+u8 wps_get_message_type(u8 *buf, size_t length);
+#endif /* WPS_PARSER_H */
Index: upnp_wps_device.h
===================================================================
--- upnp_wps_device.h	(revision 0)
+++ upnp_wps_device.h	(revision 2)
@@ -0,0 +1,95 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: upnp_wps_device.h
+//  Description: EAP-WPS UPnP device source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef UPNP_WPS_CTRLPT_H
+#define UPNP_WPS_CTRLPT_H
+
+struct upnp_wps_device_sm;
+
+struct upnp_wps_device_ctx {
+	int (*received_req_get_device_info)(void *priv,
+										u8 **rsp, size_t *rsp_len);
+	int (*received_req_put_message)(void *priv,
+									u8 *msg, size_t msg_len,
+									u8 **rsp, size_t *rsp_len);
+	int (*received_req_get_ap_settings)(void *priv,
+										u8 *msg, size_t msg_len,
+										u8 **rsp, size_t *rsp_len);
+	int (*received_req_set_ap_settings)(void *priv,
+										u8 *msg, size_t msg_len);
+	int (*received_req_del_ap_settings)(void *priv,
+										u8 *msg, size_t msg_len);
+	int (*received_req_get_sta_settings)(void *priv,
+										 u8 *msg, size_t msg_len,
+										 u8 **rsp, size_t *rsp_len);
+	int (*received_req_set_sta_settings)(void *priv,
+										 u8 *msg, size_t msg_len);
+	int (*received_req_del_sta_settings)(void *priv,
+										 u8 *msg, size_t msg_len);
+	int (*received_req_put_wlan_event_response)(void *priv,
+												int ev_type,
+												u8 *msg, size_t msg_len);
+	int (*received_req_set_selected_registrar)(void *priv,
+											   u8 *msg, size_t msg_len);
+	int (*received_req_reboot_ap)(void *priv,
+								  u8 *msg, size_t msg_len);
+	int (*received_req_reset_ap)(void *priv,
+								 u8 *msg, size_t msg_len);
+	int (*received_req_reboot_sta)(void *priv,
+								   u8 *msg, size_t msg_len);
+	int (*received_req_reset_sta)(void *priv,
+								  u8 *msg, size_t msg_len);
+};
+
+struct upnp_wps_device_sm *
+upnp_wps_device_init(struct upnp_wps_device_ctx *ctx,
+					 char *root_dir,
+					 char *desc_url,
+					 void *priv);
+void upnp_wps_device_deinit(struct upnp_wps_device_sm *sm);
+
+int upnp_wps_device_start(struct upnp_wps_device_sm *sm, char *net_if);
+int upnp_wps_device_stop(struct upnp_wps_device_sm *sm);
+
+#ifndef NAME_SIZE
+#define NAME_SIZE 256
+#endif /* NAME_SIZE */
+
+
+#define UPNP_WPS_WLANEVENT_TYPE_PROBE	1
+#define UPNP_WPS_WLANEVENT_TYPE_EAP		2
+int upnp_wps_device_send_wlan_event(struct upnp_wps_device_sm *sm,
+									int ev_type,
+									u8 *msg, size_t msg_len);
+#endif /* UPNP_WPS_CTRLPT_H */
Index: config.c
===================================================================
--- config.c	(revision 1)
+++ config.c	(revision 2)
@@ -24,7 +24,13 @@
 #include "radius_client.h"
 #include "wpa_common.h"
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
+
 #define MAX_STA_COUNT 2007
 
 
@@ -241,6 +247,7 @@
 }
 
 
+#ifndef MODIFIED_BY_SONY /* move to hostapd.c to be global function */
 static int hostapd_parse_ip_addr(const char *txt, struct hostapd_ip_addr *addr)
 {
 	if (inet_aton(txt, &addr->u.v4)) {
@@ -257,6 +264,7 @@
 
 	return -1;
 }
+#endif /* MODIFIED_BY_SONY */
 
 
 int hostapd_mac_comp(const void *a, const void *b)
@@ -448,10 +456,12 @@
 			    ssid->wpa_psk->psk, PMK_LEN);
 		ssid->wpa_psk->group = 1;
 
+#ifndef EAP_WPS
 		memset(ssid->wpa_passphrase, 0,
-		       strlen(ssid->wpa_passphrase));
+		       os_strlen(ssid->wpa_passphrase));
 		free(ssid->wpa_passphrase);
 		ssid->wpa_passphrase = NULL;
+#endif /* EAP_WPS */
 	}
 
 	if (ssid->wpa_psk_file) {
@@ -1149,6 +1159,856 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+/*
+ * Structure for network configuration parsing. This data is used to implement
+ * a generic parser for each network block variable. The table of configuration
+ * variables is defined below in this file (wps_fields[]).
+ */
+struct parse_data {
+	/* Configuration variable name */
+	char *name;
+
+	/* Parser function for this variable */
+	int (*parser)(const struct parse_data *data, void *ssid,
+		      int line, const char *value);
+
+	/* Writer function (i.e., to get the variable in text format from
+	 * internal presentation). */
+	char * (*writer)(const struct parse_data *data, void *ssid);
+
+	/* Variable specific parameters for the parser. */
+	void *param1, *param2, *param3, *param4;
+
+	/* 0 = this variable can be included in debug output
+	 * 1 = this variable contains key/private data and it must not be
+	 *     included in debug output unless explicitly requested
+	 */
+	int key_data;
+};
+
+
+static char * hostapd_config_parse_string(const char *value, size_t *len)
+{
+	if (*value == '"') {
+		char *pos;
+		value++;
+		pos = strrchr(value, '"');
+		if (pos == NULL || pos[1] != '\0')
+			return NULL;
+		*pos = '\0';
+		*len = strlen(value);
+		return strdup(value);
+	} else {
+		u8 *str;
+		size_t hlen = strlen(value);
+		if (hlen % 1)
+			return NULL;
+		*len = hlen / 2;
+		str = malloc(*len);
+		if (str == NULL)
+			return NULL;
+		if (hexstr2bin(value, str, *len)) {
+			free(str);
+			return NULL;
+		}
+		return (char *) str;
+	}
+}
+
+
+static int hostapd_config_parse_str(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	size_t res_len, *dst_len;
+	char **dst;
+
+	dst = (char **) (((u8 *) ssid) + (long) data->param1);
+	dst_len = (size_t *) (((u8 *) ssid) + (long) data->param2);
+
+	free(*dst);
+	*dst = hostapd_config_parse_string(value, &res_len);
+	if (*dst == NULL) {
+		wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'.",
+			   line, data->name,
+			   data->key_data ? "[KEY DATA REMOVED]" : value);
+		return -1;
+	}
+	if (data->param2)
+		*dst_len = res_len;
+
+	if (data->key_data) {
+		wpa_hexdump_ascii_key(MSG_MSGDUMP, data->name,
+				      (u8 *) *dst, res_len);
+	} else {
+		wpa_hexdump_ascii_key(MSG_MSGDUMP, data->name,
+				  (u8 *) *dst, res_len);
+	}
+
+	if (data->param3 && res_len < (size_t) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too short %s (len=%lu "
+			   "min_len=%ld)", line, data->name,
+			   (unsigned long) res_len, (long) data->param3);
+		free(*dst);
+		*dst = NULL;
+		return -1;
+	}
+
+	if (data->param4 && res_len > (size_t) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too long %s (len=%lu "
+			   "max_len=%ld)", line, data->name,
+			   (unsigned long) res_len, (long) data->param4);
+		free(*dst);
+		*dst = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+#if !defined(EAP_WPS) || defined(USE_INTEL_SDK)
+static int is_hex(const u8 *data, size_t len)
+#else // !defined(EAP_WPS) || defined(USE_INTEL_SDK)
+int is_hex(const u8 *data, size_t len)
+#endif // !defined(EAP_WPS) || defined(USE_INTEL_SDK)
+{
+	size_t i;
+
+	for (i = 0; i < len; i++) {
+		if (data[i] < 32 || data[i] >= 127)
+			return 1;
+	}
+	return 0;
+}
+
+
+static char * hostapd_config_write_string_ascii(const u8 *value, size_t len)
+{
+	char *buf;
+
+	buf = malloc(len + 3);
+	if (buf == NULL)
+		return NULL;
+	buf[0] = '"';
+	memcpy(buf + 1, value, len);
+	buf[len + 1] = '"';
+	buf[len + 2] = '\0';
+
+	return buf;
+}
+
+
+static char * hostapd_config_write_string_hex(const u8 *value, size_t len)
+{
+	char *buf;
+
+	buf = wpa_zalloc(2 * len + 1);
+	if (buf == NULL)
+		return NULL;
+	wpa_snprintf_hex(buf, 2 * len + 1, value, len);
+
+	return buf;
+}
+
+
+static char * hostapd_config_write_string(const u8 *value, size_t len)
+{
+	if (value == NULL)
+		return NULL;
+
+	if (is_hex(value, len))
+		return hostapd_config_write_string_hex(value, len);
+	else
+		return hostapd_config_write_string_ascii(value, len);
+}
+
+
+static char * hostapd_config_write_str(const struct parse_data *data, void *ssid)
+{
+	size_t len;
+	char **src;
+
+	src = (char **) (((u8 *) ssid) + (long) data->param1);
+	if (*src == NULL)
+		return NULL;
+
+	if (data->param2)
+		len = *((size_t *) (((u8 *) ssid) + (long) data->param2));
+	else
+		len = strlen(*src);
+
+	return hostapd_config_write_string((const u8 *) *src, len);
+}
+
+
+#if 0
+static int hostapd_config_parse_int(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	int *dst;
+
+	dst = (int *) (((u8 *) ssid) + (long) data->param1);
+	*dst = atoi(value);
+	wpa_printf(MSG_MSGDUMP, "%s=%d (0x%x)", data->name, *dst, *dst);
+
+	if (data->param3 && *dst < (long) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=%d "
+			   "min_value=%ld)", line, data->name, *dst,
+			   (long) data->param3);
+		*dst = (long) data->param3;
+		return -1;
+	}
+
+	if (data->param4 && *dst > (long) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=%d "
+			   "max_value=%ld)", line, data->name, *dst,
+			   (long) data->param4);
+		*dst = (long) data->param4;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * hostapd_config_write_int(const struct parse_data *data, void *ssid)
+{
+	int *src;
+	char *value;
+
+	src = (int *) (((u8 *) ssid) + (long) data->param1);
+
+	value = malloc(20);
+	if (value == NULL)
+		return NULL;
+	snprintf(value, 20, "%d", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+#endif
+
+
+static int hostapd_config_parse_hex8(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	u8 *dst;
+
+	dst = (u8 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u8)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%02x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%02x "
+			   "min_value=0x%02x)", line, data->name, *dst,
+			   (u8) ((u32) data->param3));
+		*dst = (u8) ((u32) data->param3);
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%02x "
+			   "max_value=0x%02x)", line, data->name, *dst,
+			   (u8) ((u32)data->param4));
+		*dst = (u8) ((u32)data->param4);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * hostapd_config_write_hex8(const struct parse_data *data, void *ssid)
+{
+	u8 *src;
+	char *value;
+
+	src = (u8 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = malloc(20);
+	if (value == NULL)
+		return NULL;
+	snprintf(value, 20, "0x%02x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int hostapd_config_parse_hex16(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	u16 *dst;
+
+	dst = (u16 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u16)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%04x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%04x "
+			   "min_value=0x%04x)", line, data->name, *dst,
+			   (u16) ((u32) data->param3));
+		*dst = (u16) ((u32) data->param3);
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%04x "
+			   "max_value=0x%04x)", line, data->name, *dst,
+			   (u16) ((u32)data->param4));
+		*dst = (u16) ((u32)data->param4);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * hostapd_config_write_hex16(const struct parse_data *data, void *ssid)
+{
+	u16 *src;
+	char *value;
+
+	src = (u16 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = malloc(20);
+	if (value == NULL)
+		return NULL;
+	snprintf(value, 20, "0x%04x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int hostapd_config_parse_hex32(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	u32 *dst;
+
+	dst = (u32 *) (((u8 *) ssid) + (long) data->param1);
+	*dst = (u32)strtoul(value, NULL, 16);
+	wpa_printf(MSG_MSGDUMP, "%s=0x%08x", data->name, *dst);
+
+	if (data->param3 && (u32) *dst < (u32) data->param3) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=0x%08x "
+			   "min_value=0x%08x)", line, data->name, *dst,
+			   (u32) data->param3);
+		*dst = (u32) data->param3;
+		return -1;
+	}
+
+	if (data->param4 && (u32) *dst > (u32) data->param4) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=0x%08x "
+			   "max_value=0x%08x)", line, data->name, *dst,
+			   (u32)data->param4);
+		*dst = (u32)data->param4;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static char * hostapd_config_write_hex32(const struct parse_data *data, void *ssid)
+{
+	u32 *src;
+	char *value;
+
+	src = (u32 *) (((u8 *) ssid) + (long) data->param1);
+
+	value = malloc(20);
+	if (value == NULL)
+		return NULL;
+	snprintf(value, 20, "0x%08x", *src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wps_config_parse_uuid(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (hexstr2bin(value, wps->uuid, SIZE_16_BYTES) ||
+	    value[SIZE_16_BYTES * 2] != '\0') {
+		wpa_printf(MSG_ERROR, "Line %d: Invalid UUID '%s'.",
+			   line, value);
+		return -1;
+	}
+
+	wps->uuid_set = 1;
+	wpa_hexdump_key(MSG_MSGDUMP, "UUID", wps->uuid, SIZE_16_BYTES);
+	return 0;
+}
+
+
+static char * wps_config_write_uuid(const struct parse_data *data, void *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (wps->uuid_set)
+		return hostapd_config_write_string_hex(wps->uuid, SIZE_16_BYTES);
+
+	return NULL;
+}
+
+
+static int _wps_config_parse_dev_category(const struct parse_data *data,
+				void *ssid, int line, const char *value, int sub)
+{
+	u16 *dst;
+	struct wps_config *wps = (struct wps_config *)ssid;
+	u16 min, max;
+	int save_offset;
+
+	if (!sub) {
+		dst = &wps->dev_category;
+		min = 1;
+		max = 10;
+		save_offset = 0;
+	} else {
+		dst = &wps->dev_sub_category;
+		min = 1;
+		max = 3;
+		save_offset = 6;
+	}
+
+	*dst = (u16) atoi(value);
+	wpa_printf(MSG_MSGDUMP, "%s=%d (0x%04x)", data->name, *dst, *dst);
+
+	if (min && *dst < min) {
+		wpa_printf(MSG_ERROR, "Line %d: too small %s (value=%d "
+			   "min_value=%d)", line, data->name, *dst, min);
+		*dst = min;
+		return -1;
+	}
+
+	if (max && *dst > max) {
+		wpa_printf(MSG_ERROR, "Line %d: too large %s (value=%d "
+			   "max_value=%d)", line, data->name, *dst, max);
+		*dst = max;
+		return -1;
+	}
+
+	WPA_PUT_BE16(&wps->prim_dev_type[save_offset], *dst);
+	return 0;
+}
+
+
+static char * _wps_config_write_dev_category(const u16 src)
+{
+	char *value;
+
+	value = malloc(20);
+	if (value == NULL)
+		return NULL;
+	snprintf(value, 20, "%d", src);
+	value[20 - 1] = '\0';
+	return value;
+}
+
+
+static int wps_config_parse_dev_category(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	return _wps_config_parse_dev_category(data, ssid, line, value, 0);
+}
+
+
+static char * wps_config_write_dev_category(const struct parse_data *data, void *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+	return _wps_config_write_dev_category(wps->dev_category);
+}
+
+
+static int wps_config_parse_dev_sub_category(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	return _wps_config_parse_dev_category(data, ssid, line, value, 1);
+}
+
+
+static char * wps_config_write_dev_sub_category(const struct parse_data *data, void *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+	return _wps_config_write_dev_category(wps->dev_category);
+}
+
+
+static int wps_config_parse_dev_oui(const struct parse_data *data,
+				void *ssid, int line, const char *value)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	if (hexstr2bin(value, wps->dev_oui, SIZE_4_BYTES) ||
+	    value[SIZE_4_BYTES * 2] != '\0') {
+		wpa_printf(MSG_ERROR, "Line %d: Invalid Device OUI '%s'.",
+			   line, value);
+		return -1;
+	}
+
+	wpa_hexdump_key(MSG_MSGDUMP, "Device OUI", wps->dev_oui, SIZE_4_BYTES);
+	memcpy(&wps->prim_dev_type[2], wps->dev_oui, SIZE_4_BYTES);
+	return 0;
+}
+
+
+static char * wps_config_write_dev_oui(const struct parse_data *data, void *ssid)
+{
+	struct wps_config *wps = (struct wps_config *)ssid;
+
+	return hostapd_config_write_string_hex(wps->dev_oui, SIZE_4_BYTES);
+}
+
+
+/* Helper macros for network block parser */
+
+#ifdef OFFSET
+#undef OFFSET
+#endif /* OFFSET */
+/* OFFSET: Get offset of a variable within the wps_config structure */
+#define OFFSET(v) ((void *) &((struct wps_config *) 0)->v)
+
+/* STR: Define a string variable for an ASCII string; f = field name */
+#define _STR(f) #f, hostapd_config_parse_str, hostapd_config_write_str, OFFSET(f)
+#define STR(f) _STR(f), NULL, NULL, NULL, 0
+#define STR_KEY(f) _STR(f), NULL, NULL, NULL, 1
+
+/* STR_LEN: Define a string variable with a separate variable for storing the
+ * data length. Unlike STR(), this can be used to store arbitrary binary data
+ * (i.e., even nul termination character). */
+#define _STR_LEN(f) _STR(f), OFFSET(f ## _len)
+#define STR_LEN(f) _STR_LEN(f), NULL, NULL, 0
+#define STR_LEN_KEY(f) _STR_LEN(f), NULL, NULL, 1
+
+/* STR_RANGE: Like STR_LEN(), but with minimum and maximum allowed length
+ * explicitly specified. */
+#define _STR_RANGE(f, min, max) _STR_LEN(f), (void *) (min), (void *) (max)
+#define STR_RANGE(f, min, max) _STR_RANGE(f, min, max), 0
+#define STR_RANGE_KEY(f, min, max) _STR_RANGE(f, min, max), 1
+
+#define _HEX(h,f) #f, hostapd_config_parse_hex##h, hostapd_config_write_hex##h, \
+	OFFSET(f), (void *) 0
+
+/* HEX: Define an hex variable */
+#define HEX8(f) _HEX(8, f), NULL, NULL, 0
+#define HEX16(f) _HEX(16, f), NULL, NULL, 0
+#define HEX32(f) _HEX(32, f), NULL, NULL, 0
+
+/* HEX_RANGE: Define an hex variable with allowed value range */
+#define HEX8_RANGE(f, min, max) _HEX(8, f), (void *) (min), (void *) (max), 0
+#define HEX16_RANGE(f, min, max) _HEX(16, f), (void *) (min), (void *) (max), 0
+#define HEX32_RANGE(f, min, max) _HEX(32, f), (void *) (min), (void *) (max), 0
+
+#define _INT(f) #f, hostapd_config_parse_int, hostapd_config_write_int, \
+	OFFSET(f), (void *) 0
+
+/* INT: Define an integer variable */
+#define INT(f) _INT(f), NULL, NULL, 0
+
+/* INT_RANGE: Define an integer variable with allowed value range */
+#define INT_RANGE(f, min, max) _INT(f), (void *) (min), (void *) (max), 0
+
+/* FUNC: Define a configuration variable that uses a custom function for
+ * parsing and writing the value. */
+#define _FUNC(f) #f, wps_config_parse_ ## f, wps_config_write_ ## f, \
+	NULL, NULL, NULL, NULL
+#define FUNC(f) _FUNC(f), 0
+#define FUNC_KEY(f) _FUNC(f), 1
+
+/*
+ * Table of network configuration variables. This table is used to parse each
+ * network configuration variable, e.g., each line in hostapd.conf file
+ * that is inside a network block.
+ *
+ * This table is generated using the helper macros defined above and with
+ * generous help from the C pre-processor. The field name is stored as a string
+ * into .name and for STR and INT types, the offset of the target buffer within
+ * struct wps_config is stored in .param1. .param2 (if not NULL) is similar
+ * offset to the field containing the length of the configuration variable.
+ * .param3 and .param4 can be used to mark the allowed range (length for STR
+ * and value for INT).
+ *
+ * For each configuration line in hostapd.conf, the parser goes through
+ * this table and select the entry that matches with the field name. The parser
+ * function (.parser) is then called to parse the actual value of the field.
+ *
+ * This kind of mechanism makes it easy to add new configuration parameters,
+ * since only one line needs to be added into this table and into the
+ * struct wps_config definition if the new variable is either a string or
+ * integer. More complex types will need to use their own parser and writer
+ * functions.
+ */
+static const struct parse_data wps_fields[] = {
+	{ HEX8(version) },
+	{ FUNC(uuid) },
+	{ HEX16(auth_type_flags) },
+	{ HEX16(encr_type_flags) },
+	{ HEX8(conn_type_flags) },
+	{ HEX16(config_methods) },
+	{ HEX8(wps_state) },
+	{ HEX8(rf_bands) },
+	{ STR_RANGE(manufacturer, 0, SIZE_64_BYTES) },
+	{ STR_RANGE(model_name, 0, SIZE_32_BYTES) },
+	{ STR_RANGE(model_number, 0, SIZE_32_BYTES) },
+	{ STR_RANGE(serial_number, 0, SIZE_32_BYTES) },
+	{ FUNC_KEY(dev_category) },
+	{ FUNC_KEY(dev_sub_category) },
+	{ FUNC_KEY(dev_oui) },
+	{ STR_RANGE(dev_name, 0, SIZE_32_BYTES) },
+	{ HEX32(os_version) }
+#ifdef WPS_OPT_UPNP
+	,
+	{ STR(upnp_root_dir) },
+	{ STR(upnp_desc_url) }
+#endif /* WPS_OPT_UPNP */
+};
+
+#undef OFFSET
+#undef _STR
+#undef STR
+#undef STR_KEY
+#undef _STR_LEN
+#undef STR_LEN
+#undef STR_LEN_KEY
+#undef _STR_RANGE
+#undef STR_RANGE
+#undef STR_RANGE_KEY
+#undef _INT
+#undef INT
+#undef INT_RANGE
+#undef _FUNC
+#undef FUNC
+#undef FUNC_KEY
+#define NUM_WPS_FIELDS (sizeof(wps_fields) / sizeof(wps_fields[0]))
+
+
+/**
+ * wps_config_set - Set a variable in wps configuration
+ * @wps: Pointer to wps configuration data
+ * @var: Variable name, e.g., "version"
+ * @value: Variable value
+ * @line: Line number in configuration file or 0 if not used
+ * Returns: 0 on success, -1 on failure
+ *
+ * This function can be used to set wps configuration variables based on
+ * both the configuration file and management interface input. The value
+ * parameter must be in the same format as the text-based configuration file is
+ * using. For example, strings are using double quotation marks.
+ */
+int wps_config_set(struct wps_config *wps, const char *var, const char *value,
+		   int line)
+{
+	size_t i;
+	int ret = 0;
+
+	if (wps == NULL || var == NULL || value == NULL)
+		return -1;
+
+	for (i = 0; i < NUM_WPS_FIELDS; i++) {
+		const struct parse_data *field = &wps_fields[i];
+		if (strcmp(var, field->name) != 0)
+			continue;
+
+		if (field->parser(field, (void *)wps, line, value)) {
+			if (line) {
+				wpa_printf(MSG_ERROR, "Line %d: failed to "
+					   "parse %s '%s'.", line, var, value);
+			}
+			ret = -1;
+		}
+		break;
+	}
+	if (i == NUM_WPS_FIELDS) {
+		if (line) {
+			wpa_printf(MSG_ERROR, "Line %d: unknown wps_property field "
+				   "'%s'.", line, var);
+		}
+		ret = -1;
+	}
+
+	return ret;
+}
+
+
+/**
+ * wps_config_get - Get a variable in wps configuration
+ * @wps: Pointer to wps configuration data
+ * @var: Variable name, e.g., "ssid"
+ * Returns: Value of the variable or %NULL on failure
+ *
+ * This function can be used to get wps configuration variables. The
+ * returned value is a copy of the configuration variable in text format, i.e,.
+ * the same format that the text-based configuration file and wps_config_set()
+ * are using for the value. The caller is responsible for freeing the returned
+ * value.
+ */
+char * wps_config_get(struct wps_config *wps, const char *var)
+{
+	size_t i;
+
+	if (wps == NULL || var == NULL)
+		return NULL;
+
+	for (i = 0; i < NUM_WPS_FIELDS; i++) {
+		const struct parse_data *field = &wps_fields[i];
+		if (strcmp(var, field->name) == 0)
+			return field->writer(field, (void *)wps);
+	}
+
+	return NULL;
+}
+
+
+/**
+ * hostapd_config_free_wps_config - Free wps configuration
+ * @wps: Pointer to wps configuration to be freed
+ */
+void hostapd_config_free_wps_config(struct wps_config *wps)
+{
+	if (wps) {
+		if (wps->manufacturer)
+			os_free(wps->manufacturer);
+		if (wps->model_name)
+			os_free(wps->model_name);
+		if (wps->model_number)
+			os_free(wps->model_number);
+		if (wps->serial_number)
+			os_free(wps->serial_number);
+		if (wps->dev_name)
+			os_free(wps->dev_name);
+		if (wps->dh_secret)
+			wps_config_free_dh(&wps->dh_secret);
+		if (wps->config)
+			os_free(wps->config);
+#ifdef WPS_OPT_UPNP
+		if (wps->upnp_root_dir)
+			os_free(wps->upnp_root_dir);
+		if (wps->upnp_desc_url)
+			os_free(wps->upnp_desc_url);
+		if (wps->upnp_iface)
+			os_free(wps->upnp_iface);
+#endif /* WPS_OPT_UPNP */
+		os_free(wps);
+	}
+}
+
+
+static char * hostapd_config_get_line(char *s, int size, FILE *stream, int *line,
+				  char **_pos)
+{
+	char *pos, *end, *sstart;
+
+	while (fgets(s, size, stream)) {
+		(*line)++;
+		s[size - 1] = '\0';
+		pos = s;
+
+		while (*pos == ' ' || *pos == '\t' || *pos == '\r')
+			pos++;
+		if (*pos == '#' || *pos == '\n' || *pos == '\0' ||
+		    *pos == '\r')
+			continue;
+
+		/* Remove # comments unless they are within a double quoted
+		 * string. Remove trailing white space. */
+		sstart = strchr(pos, '"');
+		if (sstart)
+			sstart = strrchr(sstart + 1, '"');
+		if (!sstart)
+			sstart = pos;
+		end = strchr(sstart, '#');
+		if (end)
+			*end-- = '\0';
+		else
+			end = pos + strlen(pos) - 1;
+		while (end > pos &&
+		       (*end == '\n' || *end == ' ' || *end == '\t' ||
+			*end == '\r')) {
+			*end-- = '\0';
+		}
+		if (*pos == '\0')
+			continue;
+
+		if (_pos)
+			*_pos = pos;
+		return pos;
+	}
+
+	if (_pos)
+		*_pos = NULL;
+	return NULL;
+}
+
+
+static struct wps_config * hostapd_config_read_wps_property(FILE *f, int *line)
+{
+	struct wps_config *wps;
+	int errors = 0, end = 0;
+	char buf[256], *pos, *pos2;
+
+	wpa_printf(MSG_MSGDUMP, "Line: %d - start of a wps_property block",
+		   *line);
+	wps = wpa_zalloc(sizeof(*wps));
+	if (wps == NULL)
+		return NULL;
+
+	while (hostapd_config_get_line(buf, sizeof(buf), f, line, &pos)) {
+		if (strcmp(pos, "}") == 0) {
+			end = 1;
+			break;
+		}
+
+		pos2 = strchr(pos, '=');
+		if (pos2 == NULL) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid property line "
+				   "'%s'.", *line, pos);
+			errors++;
+			continue;
+		}
+
+		*pos2++ = '\0';
+		if (*pos2 == '"') {
+			if (strchr(pos2 + 1, '"') == NULL) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid "
+					   "quotation '%s'.", *line, pos2);
+				errors++;
+				continue;
+			}
+		}
+
+		if (wps_config_set(wps, pos, pos2, *line) < 0)
+			errors++;
+	}
+
+	if (!end) {
+		wpa_printf(MSG_ERROR, "Line %d: wps_property block was not "
+			   "terminated properly.", *line);
+		errors++;
+	}
+
+	if (errors) {
+		hostapd_config_free_wps_config(wps);
+		wps = NULL;
+	} else {
+		if (wps->wps_state == WPS_WPSSTATE_CONFIGURED)
+			wps->reg_mode = WPS_REGMODE_REGISTER_STA;
+		if (wps->wps_state == WPS_WPSSTATE_UNCONFIGURED)
+			wps->reg_mode = WPS_REGMODE_NONE_GET_CONF;
+		else {
+			wps->reg_mode = WPS_REGMODE_REGISTER_STA;
+			wps->wps_state = WPS_WPSSTATE_CONFIGURED;
+		}
+	}
+
+	return wps;
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
 struct hostapd_config * hostapd_config_read(const char *fname)
 {
 	struct hostapd_config *conf;
@@ -1158,6 +2018,11 @@
 	int line = 0;
 	int errors = 0;
 	size_t i;
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config *wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 
 	f = fopen(fname, "r");
 	if (f == NULL) {
@@ -1463,6 +2328,10 @@
 			}
 		} else if (strcmp(buf, "wpa") == 0) {
 			bss->wpa = atoi(pos);
+#ifdef MODIFIED_BY_SONY
+			if (!bss->wpa)
+				bss->wpa_key_mgmt = 0;
+#endif /* MODIFIED_BY_SONY */
 		} else if (strcmp(buf, "wpa_group_rekey") == 0) {
 			bss->wpa_group_rekey = atoi(pos);
 		} else if (strcmp(buf, "wpa_strict_rekey") == 0) {
@@ -1723,6 +2592,36 @@
 		} else if (strcmp(buf, "ieee80211w") == 0) {
 			bss->ieee80211w = atoi(pos);
 #endif /* CONFIG_IEEE80211W */
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+		} else if (os_strcmp(buf, "wps_property") == 0) {
+			wps = hostapd_config_read_wps_property(f, &line);
+			if (conf->wps) {
+				if (wps)
+					free(wps);
+				wpa_printf(MSG_ERROR, "Line %d: Failed to "
+					   "set multiple WPS properties.", line);
+				errors++;
+				continue;
+			} else if (!wps) {
+				wpa_printf(MSG_ERROR, "Line %d: failed to "
+					   "parse wps_property block.", line);
+				errors++;
+				continue;
+			}
+			conf->wps = wps;
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_NFC
+		} else if (os_strcmp(buf, "nfc") == 0) {
+			if (conf->nfcname) {
+				wpa_printf(MSG_ERROR, "Line %d: Failed to "
+					   "set multiple NFC devices.", line);
+				errors++;
+				continue;
+			}
+			conf->nfcname = os_strdup(pos);
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
 		} else {
 			printf("Line %d: unknown configuration item '%s'\n",
 			       line, buf);
@@ -1889,6 +2788,18 @@
 		hostapd_config_free_bss(&conf->bss[i]);
 	free(conf->bss);
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	hostapd_config_free_wps_config(conf->wps);
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_NFC
+	if (conf->nfcname) {
+		free(conf->nfcname);
+		conf->nfcname = 0;
+	}
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
+
 	free(conf);
 }
 
Index: ap.h
===================================================================
--- ap.h	(revision 1)
+++ ap.h	(revision 2)
@@ -82,6 +82,11 @@
 	struct hostapd_ssid *ssid_probe; /* SSID selection based on ProbeReq */
 
 	int vlan_id;
+
+#ifdef EAP_WPS
+	u8 wps_ie[256];
+	size_t wps_ie_len;
+#endif /* EAP_WPS */
 };
 
 
Index: config.h
===================================================================
--- config.h	(revision 1)
+++ config.h	(revision 2)
@@ -21,6 +21,12 @@
 
 struct hostapd_radius_servers;
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+struct wps_config;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 #define HOSTAPD_MAX_SSID_LEN 32
 
 #define NUM_WEP_KEYS 4
@@ -339,6 +345,15 @@
 		INTERNAL_BRIDGE_DISABLED = 0,
 		INTERNAL_BRIDGE_ENABLED = 1
 	} bridge_packets;
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config *wps;
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_NFC
+	char *nfcname;
+#endif /* WPS_OPT_NFC */
+#endif /* EAP_WPS */
 };
 
 
Index: eap_i.h
===================================================================
--- eap_i.h	(revision 1)
+++ eap_i.h	(revision 2)
@@ -189,4 +189,11 @@
 			       size_t payload_len, u8 code, u8 identifier,
 			       u8 **payload);
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+const struct hostapd_data *eap_get_hostapd_data(struct eap_sm *sm);
+const struct wps_config *eap_get_wps_config(struct eap_sm *sm);
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 #endif /* EAP_I_H */
Index: vlan_init.c
===================================================================
--- vlan_init.c	(revision 1)
+++ vlan_init.c	(revision 2)
@@ -19,11 +19,16 @@
 #include "driver.h"
 #include "vlan_init.h"
 
-
+/* MODIFIED_BY_SONY --
 #ifdef CONFIG_FULL_DYNAMIC_VLAN
+ -- MODIFIED_BY_SONY */
+#if defined(CONFIG_FULL_DYNAMIC_VLAN) || defined(WPS_OPT_UPNP)
 
 #include <net/if.h>
 #include <sys/ioctl.h>
+
+#ifdef CONFIG_FULL_DYNAMIC_VLAN
+
 #include <linux/sockios.h>
 #include <linux/if_vlan.h>
 typedef __uint64_t __u64;
@@ -42,6 +47,7 @@
 	int s; /* socket on which to listen for new/removed interfaces. */
 };
 
+#endif /* CONFIG_FULL_DYNAMIC_VLAN */
 
 static int ifconfig_helper(const char *if_name, int up)
 {
@@ -78,18 +84,27 @@
 }
 
 
-static int ifconfig_up(const char *if_name)
+#ifndef WPS_OPT_UPNP
+static
+#endif /* WPS_OPT_UPNP */
+int ifconfig_up(const char *if_name)
 {
 	return ifconfig_helper(if_name, 1);
 }
 
 
-static int ifconfig_down(const char *if_name)
+#ifndef WPS_OPT_UPNP
+static
+#endif /* WPS_OPT_UPNP */
+int ifconfig_down(const char *if_name)
 {
 	return ifconfig_helper(if_name, 0);
 }
 
+#endif /* defined(CONFIG_FULL_DYNAMIC_VLAN) || defined(WPS_OPT_UPNP) */
 
+#ifdef CONFIG_FULL_DYNAMIC_VLAN
+
 /*
  * These are only available in recent linux headers (without the leading
  * underscore).
Index: vlan_init.h
===================================================================
--- vlan_init.h	(revision 1)
+++ vlan_init.h	(revision 2)
@@ -28,4 +28,8 @@
 			      struct hostapd_ssid *mssid,
 			      const char *dyn_vlan);
 
+#ifdef WPS_OPT_UPNP
+int ifconfig_up(const char *if_name);
+int ifconfig_down(const char *if_name);
+#endif /* WPS_OPT_UPNP */
 #endif /* VLAN_INIT_H */
Index: Makefile
===================================================================
--- Makefile	(revision 1)
+++ Makefile	(revision 2)
@@ -319,6 +319,40 @@
 CFLAGS += -DCONFIG_FULL_DYNAMIC_VLAN
 endif
 
+ifdef CONFIG_EAP_WPS
+CFLAGS += -DEAP_WPS
+OBJS += wps_parser.o
+ifdef CONFIG_DRIVER_MADWIFI
+CFLAGS += -DATH_WPS_IE
+endif #CONFIG_DRIVER_MADWIFI
+ifdef CONFIG_USE_INTEL_SDK
+CFLAGS += -DUSE_INTEL_SDK
+OBJS += intel_eap_wps.o \
+		intel_udplib.o \
+		intel_ie_wps.o
+ifdef DIFF_PORT_FROM_SUPPS
+CFLAGS += -DDIFF_PORT_FROM_SUPPS
+endif #DIFF_PORT_FROM_SUPPS
+else #CONFIG_USE_INTEL_SDK
+OBJS += eap_wps.o wps_config.o
+ifdef CONFIG_WPS_OPT_UPNP
+CFLAGS += -DWPS_OPT_UPNP
+OBJS += wps_opt_upnp.o \
+		upnp_wps_common.o \
+		upnp_wps_device.o \
+		base64.o
+endif #CONFIG_WPS_OPT_UPNP
+ifdef CONFIG_WPS_OPT_NFC
+CFLAGS += -DWPS_OPT_NFC
+OBJS += wps_opt_nfc.o
+endif #CONFIG_WPS_OPT_NFC
+endif #CONFIG_USE_INTEL_SDK
+endif #CONFIG_EAP_WPS
+
+ifdef MODIFIED_BY_SONY
+CFLAGS += -DMODIFIED_BY_SONY
+endif
+
 ALL=hostapd hostapd_cli
 
 all: verify_config $(ALL)
Index: hostapd.c
===================================================================
--- hostapd.c	(revision 1)
+++ hostapd.c	(revision 2)
@@ -43,7 +43,19 @@
 #include "eap.h"
 #include "version.h"
 
+#ifdef WPS_OPT_UPNP
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+#include "wps_opt_nfc.h"
+#endif /* WPS_OPT_NFC */
+#ifdef USE_INTEL_SDK
+#include "intel_ie_wps.h"
+#elif defined(EAP_WPS)
+#include "wps_config.h"
+#endif /* USE_INTEL_SDK */
 
+
 struct hapd_interfaces {
 	size_t count;
 	struct hostapd_iface **iface;
@@ -57,6 +69,13 @@
 extern int wpa_debug_timestamp;
 
 
+#ifndef CONFIG_NATIVE_WINDOWS
+#ifdef EAP_WPS
+int reloading;
+#endif /* EAP_WPS */
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+
 void hostapd_logger(struct hostapd_data *hapd, const u8 *addr,
 		    unsigned int module, int level, const char *fmt, ...)
 {
@@ -185,6 +204,26 @@
 }
 
 
+#ifdef MODIFIED_BY_SONY
+int hostapd_parse_ip_addr(const char *txt, struct hostapd_ip_addr *addr)
+{
+	if (inet_aton(txt, &addr->u.v4)) {
+		addr->af = AF_INET;
+		return 0;
+	}
+
+#ifdef CONFIG_IPV6
+	if (inet_pton(AF_INET6, txt, &addr->u.v6) > 0) {
+		addr->af = AF_INET6;
+		return 0;
+	}
+#endif /* CONFIG_IPV6 */
+
+	return -1;
+}
+#endif /* MODIFIED_BY_SONY */
+
+
 int hostapd_ip_diff(struct hostapd_ip_addr *a, struct hostapd_ip_addr *b)
 {
 	if (a == NULL && b == NULL)
@@ -348,6 +387,7 @@
 
 
 #ifndef CONFIG_NATIVE_WINDOWS
+#ifndef EAP_WPS
 static void handle_reload(int sig, void *eloop_ctx, void *signal_ctx)
 {
 	struct hapd_interfaces *hapds = (struct hapd_interfaces *) eloop_ctx;
@@ -384,6 +424,7 @@
 		}
 	}
 }
+#endif /* EAP_WPS */
 
 
 #ifdef HOSTAPD_DUMP_STATE
@@ -571,6 +612,11 @@
  */
 static void hostapd_cleanup(struct hostapd_data *hapd)
 {
+#ifdef WPS_OPT_UPNP
+	wps_opt_upnp_sm_deinit(hapd->wps_opt_upnp);
+	hapd->wps_opt_upnp = NULL;
+#endif /* WPS_OPT_UPNP */
+
 	hostapd_ctrl_iface_deinit(hapd);
 
 	free(hapd->default_wep_key);
@@ -579,6 +625,15 @@
 	hapd->iapp = NULL;
 	accounting_deinit(hapd);
 	rsn_preauth_iface_deinit(hapd);
+
+#ifdef USE_INTEL_SDK
+	wps_ie_deinit(hapd);
+#endif /* USE_INTEL_SDK */
+#ifdef WPS_OPT_NFC
+	wps_opt_nfc_sm_deinit(hapd->wps_opt_nfc);
+	hapd->wps_opt_nfc = NULL;
+#endif /* WPS_OPT_NFC */
+
 	if (hapd->wpa_auth) {
 		wpa_deinit(hapd->wpa_auth);
 		hapd->wpa_auth = NULL;
@@ -906,6 +961,82 @@
 }
 
 
+#if defined(EAP_WPS) && !defined(USE_INTEL_SDK)
+static struct hostapd_config *hostapd_get_conf(void *ctx)
+{
+	struct hostapd_data *hapd = (struct hostapd_data *)ctx;
+	return hapd?hapd->iconf:NULL;
+}
+
+
+#ifdef WPS_OPT_UPNP
+static int hostapd_init_wps_opt_upnp(struct hostapd_data *hapd)
+{
+	struct wps_opt_upnp_sm_ctx *ctx;
+	ctx = wpa_zalloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate UPnP context.");
+		return -1;
+	}
+
+	ctx->ctx = hapd;
+	ctx->msg_ctx = hapd;
+
+	ctx->get_conf = hostapd_get_conf;
+
+	hapd->wps_opt_upnp = wps_opt_upnp_sm_init(ctx);
+	if (hapd->wps_opt_upnp == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to initialize UPnP state "
+			   "machine");
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* WPS_OPT_UPNP */
+
+
+#ifdef WPS_OPT_NFC
+static int hostapd_get_own_addr(void *ctx, u8 *mac)
+{
+	int ret = 0;
+	struct hostapd_data *hapd = (struct hostapd_data *)ctx;
+	if (hapd)
+		memcpy(mac, hapd->own_addr, ETH_ALEN);
+	else
+		ret = -1;
+	return ret;
+}
+
+
+static int hostapd_init_wps_opt_nfc(struct hostapd_data *hapd)
+{
+	struct wps_opt_nfc_sm_ctx *ctx;
+	ctx = wpa_zalloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate NFC context.");
+		return -1;
+	}
+
+	ctx->ctx = hapd;
+	ctx->msg_ctx = hapd;
+
+	ctx->get_own_addr = hostapd_get_own_addr;
+	ctx->get_conf = hostapd_get_conf;
+
+	hapd->wps_opt_nfc = wps_opt_nfc_sm_init(ctx);
+	if (hapd->wps_opt_nfc == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to initialize NFC state "
+			   "machine");
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* WPS_OPT_NFC */
+#endif /* defined(EAP_WPS) && !defined(USE_INTEL_SDK) */
+
+
 /**
  * hostapd_validate_bssid_configuration - Validate BSSID configuration
  * @iface: Pointer to interface data
@@ -1060,7 +1191,12 @@
 	 * if one was specified in the config file, verify they
 	 * match.
 	 */
+#ifndef MODIFIED_BY_SONY
 	ssid_len = hostapd_get_ssid(hapd, ssid, sizeof(ssid));
+#else /* MODIFIED_BY_SONY */
+	memset(ssid, 0, sizeof(ssid));
+	ssid_len = hostapd_get_ssid(hapd, ssid, HOSTAPD_MAX_SSID_LEN);
+#endif /* MODIFIED_BY_SONY */
 	if (ssid_len < 0) {
 		printf("Could not read SSID from system\n");
 		return -1;
@@ -1276,6 +1412,11 @@
 		return -1;
 	}
 
+#ifdef WPS_OPT_UPNP
+	if (hostapd_init_wps_opt_upnp(hapd) < 0)
+		return -1;
+#endif /* WPS_OPT_UPNP */
+
 	return ret;
 }
 
@@ -1359,6 +1500,12 @@
 	size_t i;
 	char country[4];
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	struct wps_config * wps;
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
 	/*
 	 * Initialize the driver interface and make sure that all BSSes get
 	 * configured with a pointer to this driver interface.
@@ -1412,6 +1559,54 @@
 		}
 	}
 
+#ifdef USE_INTEL_SDK
+	if (wps_ie_init(hapd)) {
+		printf("WPS IE initialization failed.\n");
+		return -1;
+	}
+#elif defined(EAP_WPS)
+	wps = hapd->iconf->wps;
+	if (wps) {
+		struct hostapd_hw_modes *modes;
+		u16 num_modes, flags;
+
+
+		memcpy(wps->mac, hapd->own_addr, sizeof(wps->mac));
+		wps->mac_set = 1;
+
+		modes = hostapd_get_hw_feature_data(hapd, &num_modes, &flags);
+		if (modes) {
+			int i;
+			extern int eap_wps_set_ie(struct hostapd_data *hapd);
+
+			wps->rf_bands = 0;
+			for (i = 0; i < num_modes; i++) {
+				if(modes[i].mode & HOSTAPD_MODE_IEEE80211A)
+					wps->rf_bands |= WPS_RFBAND_50GHZ;
+				else if (modes[i].mode & (HOSTAPD_MODE_IEEE80211B|
+										  HOSTAPD_MODE_IEEE80211G))
+					wps->rf_bands |= WPS_RFBAND_24GHZ;
+				if (modes[i].channels)
+					free(modes[i].channels);
+				if (modes[i].rates)
+					free(modes[i].rates);
+			}
+			free(modes);
+
+			/* reset wps information elements */
+			(void)eap_wps_set_ie(hapd);
+		}
+	}
+#endif /* USE_INTEL_SDK */
+
+#ifdef WPS_OPT_NFC
+	if (hostapd_init_wps_opt_nfc(hapd) < 0)
+		return -1;
+	if (hapd->iconf->nfcname) {
+		wps_opt_nfc_sm_set_ifname(hapd->wps_opt_nfc, hapd->iconf->nfcname);
+	}
+#endif /* WPS_OPT_NFC */
+
 	/* TODO: merge with hostapd_driver_init() ? */
 	if (hostapd_wireless_event_init(hapd) < 0)
 		return -1;
@@ -1578,6 +1773,13 @@
 		"IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator\n"
 		"Copyright (c) 2002-2007, Jouni Malinen <j@w1.fi> "
 		"and contributors\n");
+#ifdef MODIFIED_BY_SONY
+	fprintf(stderr,
+		"\nWi-Fi Protected Setup Reference Application,\n"
+		"Version '" MODIFIED_BY_SONY_VERSION_STR "', modified by Sony.\n"
+		"Copyright (c) 2007, Sony Corporation "
+		"and contributers\n");
+#endif /* MODIFIED_BY_SONY */
 }
 
 
@@ -1756,6 +1958,31 @@
 }
 
 
+#ifndef CONFIG_NATIVE_WINDOWS
+#ifdef EAP_WPS
+static void handle_reload(int sig, void *eloop_ctx, void *signal_ctx)
+{
+	reloading = 1;
+	eloop_terminate();
+}
+
+
+static
+void hostapd_reload_configuration_timer(void *eloop_ctx, void *timeout_ctx)
+{
+	handle_reload(0, eloop_get_user_data(), 0);
+}
+
+
+int hostapd_reload_configuration(struct hostapd_data *hapd)
+{
+	eloop_register_timeout(5, 0, hostapd_reload_configuration_timer, 0, 0);
+	return 0;
+}
+#endif /* EAP_WPS */
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+
 /**
  * register_drivers - Register driver interfaces
  *
@@ -1790,6 +2017,22 @@
 	int c, debug = 0, daemonize = 0;
 	const char *pid_file = NULL;
 
+#ifdef MODIFIED_BY_SONY
+	setvbuf(stdout, 0, _IOLBF, 0);
+	setvbuf(stderr, 0, _IOLBF, 0);
+#endif /* MODIFIED_BY_SONY */
+
+#ifndef CONFIG_NATIVE_WINDOWS
+#ifdef EAP_WPS
+	do {
+		reloading = 0;
+		ret = 1;
+		debug = 0;
+		daemonize = 0;
+		pid_file = 0;
+#endif /* EAP_WPS */
+#endif /* CONFIG_NATIVE_WINDOWS */
+
 	for (;;) {
 		c = getopt(argc, argv, "BdhKP:tv");
 		if (c < 0)
@@ -1932,5 +2175,42 @@
 
 	os_daemonize_terminate(pid_file);
 
+#ifndef CONFIG_NATIVE_WINDOWS
+#ifdef EAP_WPS
+	} while (reloading);
+#endif /* EAP_WPS */
+#endif /* CONFIG_NATIVE_WINDOWS */
+
 	return ret;
 }
+
+
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+#if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
+void hostapd_msg(struct hostapd_data *hapd, int level, char *fmt, ...)
+{
+	va_list ap;
+	char *buf;
+	const int buflen = 2048;
+	int len;
+
+	buf = malloc(buflen);
+	if (buf == NULL) {
+		wpa_printf(MSG_ERROR, "hapd_msg: Failed to allocate message "
+			   "buffer");
+		return;
+	}
+	va_start(ap, fmt);
+	len = vsnprintf(buf, buflen, fmt, ap);
+	va_end(ap);
+	wpa_printf(level, "%s", buf);
+	if (hapd->ctrl_sock) {
+		hostapd_ctrl_iface_send(hapd, level, buf, len);
+	}
+	free(buf);
+}
+#endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
Index: hostapd.h
===================================================================
--- hostapd.h	(revision 1)
+++ hostapd.h	(revision 2)
@@ -106,6 +106,13 @@
 struct full_dynamic_vlan;
 #endif /* CONFIG_FULL_DYNAMIC_VLAN */
 
+#ifdef WPS_OPT_UPNP
+struct wps_opt_upnp_sm;
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+struct wps_opt_nfc_sm;
+#endif /* WPS_OPT_NFC */
+
 /**
  * struct hostapd_data - hostapd per-BSS data structure
  */
@@ -115,6 +122,13 @@
 	struct hostapd_bss_config *conf;
 	int interface_added; /* virtual interface added for this BSS */
 
+#ifdef WPS_OPT_UPNP
+	struct wps_opt_upnp_sm *wps_opt_upnp;
+#endif /* WPS_OPT_UPNP */
+#ifdef WPS_OPT_NFC
+	struct wps_opt_nfc_sm *wps_opt_nfc;
+#endif /* WPS_OPT_NFC */
+
 	u8 own_addr[ETH_ALEN];
 
 	int num_sta; /* number of entries in sta_list */
@@ -250,6 +264,19 @@
 
 const char * hostapd_ip_txt(const struct hostapd_ip_addr *addr, char *buf,
 			    size_t buflen);
+#ifdef MODIFIED_BY_SONY
+int hostapd_parse_ip_addr(const char *txt, struct hostapd_ip_addr *addr);
+#endif /* MODIFIED_BY_SONY */
 int hostapd_ip_diff(struct hostapd_ip_addr *a, struct hostapd_ip_addr *b);
 
+#ifdef EAP_WPS
+int hostapd_reload_configuration(struct hostapd_data *hapd);
+#if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
+void hostapd_msg(struct hostapd_data *hapd, int level, char *fmt, ...)
+PRINTF_FORMAT(3, 4);
+#else /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
+#define hostapd_msg(args...) do { } while (0)
+#endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
+#endif /* EAP_WPS */
+
 #endif /* HOSTAPD_H */
Index: eap_methods.c
===================================================================
--- eap_methods.c	(revision 1)
+++ eap_methods.c	(revision 2)
@@ -247,6 +247,13 @@
 	}
 #endif /* EAP_VENDOR_TEST */
 
+#ifdef EAP_WPS
+	if (ret == 0) {
+		int eap_server_wps_register(void);
+		ret = eap_server_wps_register();
+	}
+#endif /* EAP_WPS */
+
 	return ret;
 }
 
Index: version.h
===================================================================
--- version.h	(revision 1)
+++ version.h	(revision 2)
@@ -3,4 +3,8 @@
 
 #define VERSION_STR "0.5.8"
 
+#ifdef MODIFIED_BY_SONY
+#define MODIFIED_BY_SONY_VERSION_STR "sony_r5.7"
+#endif /* MODIFIED_BY_SONY */
+
 #endif /* VERSION_H */
Index: wps_opt_upnp.c
===================================================================
--- wps_opt_upnp.c	(revision 0)
+++ wps_opt_upnp.c	(revision 2)
@@ -0,0 +1,1062 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_upnp.c
+//  Description: EAP-WPS UPnP option source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "hostapd.h"
+#include "eloop.h"
+#include "config.h"
+#include "wps_config.h"
+#include "wpa_ctrl.h"
+#include "state_machine.h"
+#include "wps_parser.h"
+#include "wps_opt_upnp.h"
+#include "eap_wps.h"
+#include "upnp_wps_device.h"
+
+
+#define STATE_MACHINE_DATA struct wps_opt_upnp_sm
+#define STATE_MACHINE_DEBUG_PREFIX "OPT_UPNP"
+
+/**
+ * struct wps_opt_upnp_sm - Internal data for UPNP state machines
+ */
+
+struct wps_opt_upnp_sm {
+	struct wps_opt_upnp_sm_ctx *ctx;
+	struct upnp_wps_device_sm *upnp_device_sm;
+	struct eap_wps_data *proc_data;
+	u8 *rcvUpnpMsg;
+	size_t rcvUpnpMsgLen;
+	struct os_time end_selreg_time;
+};
+
+
+static void wps_opt_upnp_request(struct wps_opt_upnp_sm *sm,
+								 int req_type, const char *msg,
+								 size_t msg_len)
+{
+#define CTRL_REQ_TYPE_COMP			0
+#define CTRL_REQ_TYPE_PASSWORD		1
+	char *buf;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (!sm || !sm->ctx)
+		return;
+
+	switch(req_type) {
+	case CTRL_REQ_TYPE_COMP:
+		field = "UPNP_COMP";
+		txt = "Complete EAP-WPS with UPnP authentication";
+		break;
+	case CTRL_REQ_TYPE_PASSWORD:
+		field = "UPNP_PASSWORD";
+		txt = "Request Password for EAP-WPS with UPnP";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		os_free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	hostapd_msg(sm->ctx->msg_ctx, MSG_INFO, "%s", buf);
+	os_free(buf);
+}
+
+
+static void wps_opt_upnp_deinit_data(struct eap_wps_data *data)
+{
+	do {
+		if (!data)
+			break;
+		eap_wps_config_deinit_data(data);
+	} while (0);
+}
+
+
+static int wps_opt_upnp_init_data(struct wps_opt_upnp_sm *sm,
+								  struct eap_wps_data **data)
+{
+	int ret = -1;
+	struct wps_config *conf;
+
+	do {
+		if (!sm || !sm->ctx || !data)
+			break;
+		*data = 0;
+
+		if (!sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+		if (!conf)
+			break;
+
+		*data = (struct eap_wps_data *)wpa_zalloc(sizeof(**data));
+		if (!*data)
+			break;
+		if (eap_wps_config_init_data((struct hostapd_data *)sm->ctx->ctx, conf, *data))
+			break;
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (data && *data) {
+			os_free(*data);
+			*data = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static u8 *
+wps_opt_upnp_build_req_enrollee(struct wps_opt_upnp_sm *sm,
+								struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *req_len)
+{
+#define EAP_WPS_COMP_FILENAME "eap_wps_upnp_cmp.conf"
+	u8 *req = 0;
+	struct eap_wps_target_info *target;
+
+	do {
+		if (!sm || !conf || !data || !data->target || !req_len)
+			break;
+		target = data->target;
+
+		switch (data->state) {
+		case START:
+		{
+			/* Should be received Start Message */
+			/* Build M1 message */
+			if (!(req = eap_wps_config_build_message_M1(conf, data, req_len)))
+				break;
+			data->state = M2;
+			break;
+		}
+		case M3:
+		{
+			/* Build M3 message */
+			if (!(req = eap_wps_config_build_message_M3(conf, data, req_len)))
+				break;
+			data->state = M4;
+			break;
+		}
+		case M5:
+		{
+			/* Build M5 message */
+			if (!(req = eap_wps_config_build_message_M5(conf, data, req_len)))
+				break;
+			data->state = M6;
+			break;
+		}
+		case M7:
+		{
+			/* Build M7 message */
+			if (!(req = eap_wps_config_build_message_M7(conf, data, req_len)))
+				break;
+			data->state = M8;
+			break;
+		}
+		case NACK:
+		{
+			if (!(req = eap_wps_config_build_message_special(conf, data, WPS_MSGTYPE_NACK,
+															 data->nonce, target->nonce,
+															 req_len)))
+				break;
+			data->state = NACK;
+			break;
+		}
+		case DONE:
+		{
+			struct hostapd_data *hapd = (struct hostapd_data *)sm->ctx->ctx;
+
+			/* Build Done */
+			if (!(req = eap_wps_config_build_message_special(conf, data, WPS_MSGTYPE_DONE,
+															 data->nonce, target->nonce,
+															 req_len)))
+				break;
+
+			switch (data->reg_mode) {
+			case WPS_REGMODE_NONE_GET_CONF:
+				if (target->config) {
+					/* Set Network Configuration */
+					(void)eap_wps_config_set_ssid_configuration(hapd, conf, data,
+																target->config,
+																target->config_len,
+																0,
+																EAP_WPS_COMP_FILENAME);
+					wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, EAP_WPS_COMP_FILENAME,
+										 os_strlen(EAP_WPS_COMP_FILENAME));
+				} else
+					/* Send EAP-WPS complete message */
+					wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+				break;
+			case WPS_REGMODE_NONE_ADDED:
+				/* Send EAP-WPS complete message */
+				wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+				break;
+			default:
+				break;
+			}
+
+			if (conf->enabled_pbc) {
+				(void)eap_wps_enabled_pbc(hapd, conf, 0);
+			}
+
+			if (conf->dev_pwd_len) {
+				conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+				os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+				conf->dev_pwd_len = 0;
+			}
+
+			if (conf->set_pub_key) {
+				if (conf->dh_secret)
+					eap_wps_free_dh(&conf->dh_secret);
+				os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+				conf->set_pub_key = 0;
+			}
+
+			data->state = FAILURE;
+			break;
+		}
+		default:
+		{
+			/* Build NACK */
+			if (!(req = eap_wps_config_build_message_special(conf, data, WPS_MSGTYPE_NACK,
+															 data->nonce, target->nonce,
+															 req_len)))
+				break;
+			data->state = NACK;
+			break;
+		}
+		}
+	} while (0);
+
+	return req;
+#undef EAP_WPS_COMP_FILENAME
+}
+
+
+static int
+wps_opt_upnp_process_enrollee(struct wps_opt_upnp_sm *sm,
+							  struct wps_config *conf,
+							  struct eap_wps_data *data)
+{
+#define EAP_WPS_COMP_FILENAME "eap_wps_upnp_cmp.conf"
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	int prev_state;
+
+	do {
+		if (!sm || !conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		prev_state = data->state;
+		switch (data->state) {
+		case M2:
+		{
+			Boolean with_config;
+			/* Should be received M2/M2D message */
+			if (!eap_wps_config_process_message_M2(conf, data, &with_config)) {
+				/* Received M2 */
+				if (with_config) {
+					/* Build Done message */
+					data->state = DONE;
+				} else {
+					/* Build M3 message */
+					data->state = M3;
+				}
+			} else if (!eap_wps_config_process_message_M2D(conf, data)) {
+				char msg[32];
+				int len;
+
+				/* Received M2D */
+				/* Build NACK message */
+				data->state = NACK;
+
+				len = os_snprintf(msg, sizeof(msg), "ENROLLEE:%d", data->reg_mode);
+				if ((data->reg_mode != WPS_REGMODE_REGISTER_STA) &&
+				    (data->dev_pwd_id == WPS_DEVICEPWDID_DEFAULT) &&
+					data->dev_pwd_len) {
+					len += os_snprintf(msg + len, sizeof(msg) - len, "-");
+					os_strncpy(msg + len, (char *)data->dev_pwd, 8);
+					len += 8;
+					msg[len] = 0;
+				}
+				wps_opt_upnp_request(sm, CTRL_REQ_TYPE_PASSWORD, msg, os_strlen(msg));
+			}
+			break;
+		}
+		case M4:
+		{
+			/* Should be received M4 message */
+			if (!eap_wps_config_process_message_M4(conf, data)) {
+				/* Build M5 message */
+				data->state = M5;
+			}
+			break;
+		}
+		case M6:
+		{
+			/* Should be received M6 message */
+			if (!eap_wps_config_process_message_M6(conf, data)) {
+				/* Build M7 message */
+				data->state = M7;
+			}
+			break;
+		}
+		case M8:
+		{
+			/* Should be received M8 message */
+			if (!eap_wps_config_process_message_M8(conf, data)) {
+				data->state = DONE;
+			}
+			break;
+		}
+		case ACK:
+		{
+			struct hostapd_data *hapd = (struct hostapd_data *)sm->ctx->ctx;
+
+			/* Should be received ACK message */
+			if (!eap_wps_config_process_message_special(conf, data, WPS_MSGTYPE_ACK,
+														data->nonce, target->nonce)) {
+				switch (data->reg_mode) {
+				case WPS_REGMODE_NONE_GET_CONF:
+					if (target->config) {
+						/* Set Network Configuration */
+						(void)eap_wps_config_set_ssid_configuration(hapd, conf, data,
+																	target->config,
+																	target->config_len,
+																	0,
+																	EAP_WPS_COMP_FILENAME);
+						wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, EAP_WPS_COMP_FILENAME,
+											 os_strlen(EAP_WPS_COMP_FILENAME));
+					} else
+						/* Send EAP-WPS complete message */
+						wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+					break;
+				case WPS_REGMODE_NONE_ADDED:
+					/* Send EAP-WPS complete message */
+					wps_opt_upnp_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+					break;
+				default:
+					break;
+				}
+
+				if (conf->enabled_pbc) {
+					(void)eap_wps_enabled_pbc(hapd, conf, 0);
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				data->state = FAILURE;
+			}
+			break;
+		}
+		case NACK:
+		{
+			/* Should be received NACK message */
+			if (!eap_wps_config_process_message_special(conf, data, WPS_MSGTYPE_NACK,
+														data->nonce, target->nonce)) {
+				data->state = FAILURE;
+			}
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+		if (prev_state == data->state)
+			break;
+		ret = 0;
+	} while (0);
+
+	return ret;
+#undef EAP_WPS_COMP_FILENAME
+}
+
+
+u8 *
+wps_opt_upnp_received_message(struct wps_opt_upnp_sm *sm,
+							  struct eap_wps_data *data,
+							  size_t *req_len)
+{
+	u8 *req = 0;
+	int ret = -1;
+	int timeout = 0;
+	struct os_time end, now;
+
+	do {
+		if (!sm || !data || !req_len)
+			break;
+		*req_len = 0;
+
+		os_get_time(&end);
+		end.sec += 2;
+		while (!timeout) {
+			if (sm->rcvUpnpMsg && sm->rcvUpnpMsgLen)
+				break;
+
+			os_sleep(0, 100000);
+			os_get_time(&now);
+			if((now.sec > end.sec) ||
+			   ((now.sec == end.sec) &&
+				(now.usec >= end.usec)))
+				timeout = 1;
+		}
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+
+		data->sndMsg = (u8 *)wpa_zalloc(sm->rcvUpnpMsgLen);
+		if (!data->sndMsg)
+			break;
+		os_memcpy(data->sndMsg, sm->rcvUpnpMsg, sm->rcvUpnpMsgLen);
+		data->sndMsgLen = sm->rcvUpnpMsgLen;
+
+		req = (u8 *)wpa_zalloc(data->sndMsgLen);
+		if (!req)
+			break;
+		os_memcpy(req, data->sndMsg, data->sndMsgLen);
+		*req_len = data->sndMsgLen;
+
+		ret = 0;
+	} while (0);
+
+	if (sm->rcvUpnpMsg) {
+		os_free(sm->rcvUpnpMsg);
+		sm->rcvUpnpMsg = 0;
+		sm->rcvUpnpMsgLen = 0;
+	}
+
+	if (ret) {
+		if (sm->proc_data)
+			sm->proc_data = 0;
+		if (req) {
+			os_free(req);
+			req = 0;
+		}
+		if (req_len)
+			*req_len = 0;
+	}
+
+	return req;
+}
+
+
+int
+wps_opt_upnp_send_wlan_event(struct wps_opt_upnp_sm *sm,
+							 struct eap_wps_data *data,
+							 int ev_type)
+{
+	int ret = -1;
+
+	do {
+		if (!sm)
+			break;
+
+		if (sm->rcvUpnpMsg) {
+			os_free(sm->rcvUpnpMsg);
+			sm->rcvUpnpMsg = 0;
+			sm->rcvUpnpMsgLen = 0;
+		}
+
+		if (upnp_wps_device_send_wlan_event(sm->upnp_device_sm, ev_type,
+											data->rcvMsg, data->rcvMsgLen))
+			break;
+
+		sm->proc_data = data;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_get_device_info(void *priv,
+										  u8 **rsp, size_t *rsp_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = priv;
+	struct wps_config *conf;
+	struct eap_wps_data *data = 0;
+
+	do {
+		if (!sm || !sm->ctx || !rsp || !rsp_len)
+			break;
+		*rsp = 0;
+		*rsp_len = 0;
+
+		if (!sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+		if (!conf)
+			break;
+
+		if(wps_opt_upnp_init_data(sm, &data))
+			break;
+
+		*rsp = wps_opt_upnp_build_req_enrollee(sm, conf, data, rsp_len);
+		if (!rsp)
+			break;
+
+		sm->proc_data = data;
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		os_free(data);
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+		if (rsp_len)
+			*rsp_len = 0;
+		sm->proc_data = 0;
+	}
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_put_message(void *priv,
+									  u8 *msg, size_t msg_len,
+									  u8 **rsp, size_t *rsp_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = priv;
+	struct wps_config *conf;
+	struct eap_wps_data *data;
+
+	do {
+		if (!sm || !sm->ctx || !msg || !rsp || !rsp_len)
+			break;
+		*rsp = 0;
+		*rsp_len = 0;
+
+		if (!sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+		if (!conf)
+			break;
+
+		if (!sm->proc_data)
+			break;
+
+		data = sm->proc_data;
+		if (data->rcvMsg) {
+			os_free(data->rcvMsg);
+			data->rcvMsg = 0;
+			data->rcvMsgLen = 0;
+		}
+		data->rcvMsg = (u8 *)wpa_zalloc(msg_len);
+		if (!data->rcvMsg)
+			break;
+		os_memcpy(data->rcvMsg, msg, msg_len);
+		data->rcvMsgLen = msg_len;
+
+		if (wps_opt_upnp_process_enrollee(sm, conf, data))
+			break;
+
+		if (FAILURE == data->state) {
+			wps_opt_upnp_deinit_data(data);
+			sm->proc_data = 0;
+			ret = 0;
+			break;
+		}
+
+		*rsp = wps_opt_upnp_build_req_enrollee(sm, conf, data, rsp_len);
+		if (!rsp)
+			break;
+		if (FAILURE == data->state) {
+			wps_opt_upnp_deinit_data(data);
+			sm->proc_data = 0;
+			ret = 0;
+			break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		(void)wps_opt_upnp_deinit_data(sm->proc_data);
+		sm->proc_data = 0;
+
+		if (rsp && *rsp) {
+			os_free(*rsp);
+			*rsp = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_get_ap_settings(void *priv,
+										  u8 *msg, size_t msg_len,
+										  u8 **rsp, size_t *rsp_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_set_ap_settings(void *priv,
+										  u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_del_ap_settings(void *priv,
+										  u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_get_sta_settings(void *priv,
+										   u8 *msg, size_t msg_len,
+										   u8 **rsp, size_t *rsp_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_set_sta_settings(void *priv,
+										   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_del_sta_settings(void *priv,
+										   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_put_wlan_event_response(void *priv,
+												  int ev_type,
+												  u8 *msg,
+												  size_t msg_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = priv;
+
+	do {
+		if (!sm)
+			break;
+
+		if (!sm->proc_data)
+			break;
+
+		if (sm->rcvUpnpMsg) {
+			os_free(sm->rcvUpnpMsg);
+			sm->rcvUpnpMsg = 0;
+			sm->rcvUpnpMsgLen = 0;
+		}
+		sm->rcvUpnpMsg = (u8 *)wpa_zalloc(msg_len);
+		if (!sm->rcvUpnpMsg)
+			break;
+		os_memcpy(sm->rcvUpnpMsg, msg, msg_len);
+		sm->rcvUpnpMsgLen = msg_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		sm->proc_data = 0;
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_set_selected_registrar(void *priv,
+												 u8 *msg,
+												 size_t msg_len)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = priv;
+	struct wps_config *conf;
+	struct wps_data *wps = 0;
+	Boolean blval;
+	u8 u8val;
+	u16 u16val;
+
+	do {
+		if (!sm)
+			break;
+
+		if (!sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx)?
+			   sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+		if (!conf)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(msg, msg_len, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &u8val, 0))
+			break;
+		if ((WPS_VERSION != u8val) && (WPS_VERSION_EX != u8val))
+			break;
+
+		/* Selected Registrar */
+		if (wps_get_value(wps, WPS_TYPE_SEL_REGISTRAR, &blval, 0))
+			break;
+		conf->selreg = blval;
+
+		/* Device Password ID */
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_PWD_ID, &u16val, 0))
+			break;
+		conf->dev_pwd_id = conf->selreg?u16val:WPS_DEVICEPWDID_DEFAULT;
+
+		/* Selected Registrar Config Methods */
+		if (wps_get_value(wps, WPS_TYPE_SEL_REG_CFG_METHODS, &u16val, 0))
+			break;
+		conf->selreg_config_methods = conf->selreg?u16val:0;
+
+		conf->upnp_enabled = conf->selreg?1:0;
+
+		os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+		conf->dev_pwd_len = 0;
+
+		if (conf->set_pub_key) {
+			if (conf->dh_secret)
+				eap_wps_free_dh(&conf->dh_secret);
+			os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+			conf->set_pub_key = 0;
+		}
+
+		if (conf->selreg) {
+			os_get_time(&sm->end_selreg_time);
+			sm->end_selreg_time.sec += EAP_WPS_PBC_TIMEOUT_SEC;
+			sm->end_selreg_time.usec += EAP_WPS_PBC_TIMEOUT_USEC;
+		} else {
+			os_memset(&sm->end_selreg_time, 0, sizeof(sm->end_selreg_time));
+		}
+
+		if (eap_wps_set_ie((struct hostapd_data *)sm->ctx->ctx))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_reboot_ap(void *priv,
+									u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_reset_ap(void *priv,
+								   u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_reboot_sta(void *priv,
+									 u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+wps_opt_upnp_received_req_reset_sta(void *priv,
+									u8 *msg, size_t msg_len)
+{
+	int ret = -1;
+
+	do {
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static void
+wps_opt_upnp_sm_check_monitor(void *ctx, void *timeout)
+{
+	struct wps_opt_upnp_sm *sm = ctx;
+	struct wps_config *conf = (sm && sm->ctx && sm->ctx->get_conf &&
+							   sm->ctx->get_conf(sm->ctx->ctx))?
+							   sm->ctx->get_conf(sm->ctx->ctx)->wps:0;
+
+	if (conf && conf->upnp_enabled) {
+		struct os_time now;
+		os_get_time(&now);
+		if ((now.sec > sm->end_selreg_time.sec) ||
+			((now.sec == sm->end_selreg_time.sec) &&
+			 (now.usec >= sm->end_selreg_time.usec))) {
+			conf->upnp_enabled = 0;
+			conf->selreg = 0;
+			conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			conf->selreg_config_methods = 0;
+			os_memset(&sm->end_selreg_time, 0, sizeof(sm->end_selreg_time));
+
+			(void)eap_wps_set_ie((struct hostapd_data *)sm->ctx->ctx);
+			hostapd_msg(sm->ctx->msg_ctx, MSG_INFO, "WPS-Selected Registrar timeout");
+		}
+	}
+}
+
+static void 
+wps_opt_upnp_sm_check_monitor_timer(void *ctx, void *timeout)
+{
+	wps_opt_upnp_sm_check_monitor(ctx, timeout);
+	eloop_register_timeout(0, 0, wps_opt_upnp_sm_check_monitor_timer, ctx, timeout);
+}
+
+struct wps_opt_upnp_sm *
+wps_opt_upnp_sm_init(struct wps_opt_upnp_sm_ctx *ctx)
+{
+	int ret = -1;
+	struct wps_opt_upnp_sm *sm = 0;
+	struct upnp_wps_device_ctx *dev_ctx = 0;
+	struct upnp_wps_device_sm *dev = 0;
+	struct hostapd_config *conf;
+	struct wps_config *wps;
+
+	do {
+		dev_ctx = wpa_zalloc(sizeof(*dev_ctx));
+		if (!dev_ctx)
+			break;
+		dev_ctx->received_req_get_device_info = 
+			wps_opt_upnp_received_req_get_device_info;
+		dev_ctx->received_req_put_message = 
+			wps_opt_upnp_received_req_put_message;
+		dev_ctx->received_req_get_ap_settings = 
+			wps_opt_upnp_received_req_get_ap_settings;
+		dev_ctx->received_req_set_ap_settings = 
+			wps_opt_upnp_received_req_set_ap_settings;
+		dev_ctx->received_req_del_ap_settings = 
+			wps_opt_upnp_received_req_del_ap_settings;
+		dev_ctx->received_req_get_sta_settings = 
+			wps_opt_upnp_received_req_get_sta_settings;
+		dev_ctx->received_req_set_sta_settings = 
+			wps_opt_upnp_received_req_set_sta_settings;
+		dev_ctx->received_req_del_sta_settings = 
+			wps_opt_upnp_received_req_del_sta_settings;
+		dev_ctx->received_req_put_wlan_event_response = 
+			wps_opt_upnp_received_req_put_wlan_event_response;
+		dev_ctx->received_req_set_selected_registrar = 
+			wps_opt_upnp_received_req_set_selected_registrar;
+		dev_ctx->received_req_reboot_ap = 
+			wps_opt_upnp_received_req_reboot_ap;
+		dev_ctx->received_req_reset_ap = 
+			wps_opt_upnp_received_req_reset_ap;
+		dev_ctx->received_req_reboot_sta = 
+			wps_opt_upnp_received_req_reboot_sta;
+		dev_ctx->received_req_reset_sta = 
+			wps_opt_upnp_received_req_reset_sta;
+
+		sm = wpa_zalloc(sizeof(*sm));
+		if (!sm)
+			break;
+		sm->ctx = ctx;
+
+		if (!sm->ctx || !sm->ctx->get_conf)
+			break;
+		conf = sm->ctx->get_conf(sm->ctx->ctx);
+		if (!conf || !conf->bss || !conf->wps)
+			break;
+
+		wps = conf->wps;
+		if (!conf->bss->iface[0] || !conf->bss->bridge[0])
+			break;
+
+		if (!wps->upnp_iface)
+			wps->upnp_iface = os_strdup(conf->bss->bridge);
+
+		if (!wps->upnp_iface || !wps->upnp_iface[0])
+			break;
+
+		dev = upnp_wps_device_init(dev_ctx,
+								   wps->upnp_root_dir,
+								   wps->upnp_desc_url,
+								   sm);
+		if (!dev)
+			break;
+		sm->upnp_device_sm = dev;
+
+		if (wps->upnp_iface) {
+			if (upnp_wps_device_start(sm->upnp_device_sm, wps->upnp_iface))
+				break;
+			wps->upnp_enabled = 0;
+		}
+
+		eloop_register_timeout(0, 0, wps_opt_upnp_sm_check_monitor_timer, sm, 0);
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (sm) {
+			wps_opt_upnp_sm_deinit(sm);
+			sm = 0;
+		}
+	}
+
+	return sm;
+}
+
+
+void wps_opt_upnp_sm_deinit(struct wps_opt_upnp_sm *sm)
+{
+	do {
+		if (!sm)
+			break;
+		upnp_wps_device_deinit(sm->upnp_device_sm);
+		if (sm->rcvUpnpMsg)
+			free(sm->rcvUpnpMsg);
+		free(sm->ctx);
+		free(sm);
+	} while (0);
+}
+
+
Index: eap_wps.c
===================================================================
--- eap_wps.c	(revision 0)
+++ eap_wps.c	(revision 2)
@@ -0,0 +1,5279 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: eap_wps.c
+//  Description: EAP-WPS main source
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#include "includes.h"
+
+#include "defs.h"
+#include "common.h"
+#include "eloop.h"
+#include "hostapd.h"
+#include "wps_config.h"
+#include "eap_i.h"
+#include "eap_wps.h"
+#include "wps_parser.h"
+#include "wpa_ctrl.h"
+#include "driver.h"
+
+#include <openssl/rand.h>
+#include <openssl/bn.h>
+#include <openssl/dh.h>
+#include <openssl/sha.h>
+#include <openssl/hmac.h>
+#include <openssl/aes.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+#ifdef WPS_OPT_UPNP
+#include "upnp_wps_device.h"
+#include "wps_opt_upnp.h"
+#endif /* WPS_OPT_UPNP */
+
+
+#define EAP_OPCODE_WPS_START	0x01
+#define EAP_OPCODE_WPS_ACK		0x02
+#define EAP_OPCODE_WPS_NACK		0x03
+#define EAP_OPCODE_WPS_MSG		0x04
+#define EAP_OPCODE_WPS_DONE		0x05
+#define EAP_OPCODE_WPS_FLAG_ACK	0x06
+
+#define EAP_FLAG_MF	0x01
+#define EAP_FLAG_LF	0x02
+
+#define EAP_VENDOR_ID_WPS	"\x00\x37\x2a"
+#define EAP_VENDOR_TYPE_WPS	"\x00\x00\x00\x01"
+
+#define EAP_WPS_PBC_PERIOD_SEC		1
+#define EAP_WPS_PBC_PERIOD_USEC		0
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+static u8 DH_P_VALUE[SIZE_1536_BITS] = 
+{
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
+    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
+    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
+    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
+    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
+    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
+    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
+    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
+    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
+    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
+    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
+    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
+    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
+    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
+    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
+    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,
+    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
+    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,
+    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
+    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
+    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
+    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x23, 0x73, 0x27,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+static u32 DH_G_VALUE = 2;
+
+struct eap_format {
+	u8 type;
+	u8 vendor_id[3];
+	u8 vendor_type[4];
+	u8 op_code;
+	u8 flags;
+};
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+static int eap_wps_clear_target_info(struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+
+	do {
+		if (!data || !data->target)
+			break;
+
+		target = data->target;
+
+		if (target->manufacturer)
+			os_free(target->manufacturer);
+		if (target->model_name)
+			os_free(target->model_name);
+		if (target->model_number)
+			os_free(target->model_number);
+		if (target->serial_number)
+			os_free(target->serial_number);
+		if (target->dev_name)
+			os_free(target->dev_name);
+		if (target->config) {
+			os_free(target->config);
+			target->config = 0;
+			target->config_len = 0;
+		}
+
+		os_memset(target, 0, sizeof(*target));
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+eap_wps_config_init_data(struct hostapd_data *hapd,
+						 struct wps_config *conf,
+						 struct eap_wps_data *data)
+{
+	int ret = -1;
+
+	do {
+		if (!hapd || !conf || !data)
+			break;
+
+		data->target = wpa_zalloc(sizeof(*data->target));
+		if (!data->target)
+			break;
+
+		if (conf->dev_pwd_len) {
+			data->dev_pwd_id = conf->dev_pwd_id;
+			os_memcpy(data->dev_pwd, conf->dev_pwd, conf->dev_pwd_len);
+			data->dev_pwd_len = conf->dev_pwd_len;
+		}
+
+		if (conf->set_pub_key) {
+			os_memcpy(data->pubKey, conf->pub_key, sizeof(data->pubKey));
+			if (conf->dh_secret)
+				data->dh_secret = (DH *)conf->dh_secret;
+			data->preset_pubKey = 1;
+		}
+
+		if (conf->config_len) {
+			data->config = (u8 *)os_malloc(conf->config_len);
+			if (!data->config)
+				break;
+			os_memcpy(data->config, conf->config, conf->config_len);
+			data->config_len = conf->config_len;
+		} else {
+			int wrap_credential = -1;
+			switch (conf->reg_mode) {
+			case WPS_REGMODE_REGISTER_STA:
+				wrap_credential = 1;
+				break;
+			case WPS_REGMODE_NONE_GET_CONF:
+			case WPS_REGMODE_NONE_ADDED:
+				wrap_credential = 0;
+				break;
+			default:
+				break;
+			}
+			if (wrap_credential >= 0) {
+				if ((WPS_REGMODE_REGISTER_STA == conf->reg_mode) &&
+					(WPS_WPSSTATE_UNCONFIGURED == conf->wps_state)) {
+					if (eap_wps_config_get_auto_configuration(hapd,
+															  conf, data,
+															  &data->config,
+															  &data->config_len,
+															  wrap_credential))
+						break;
+				} else {
+					if (eap_wps_config_get_ssid_configuration(hapd,
+															  conf, data,
+															  &data->config,
+															  &data->config_len,
+															  wrap_credential))
+					break;
+				}
+			}
+		}
+
+		data->reg_mode = conf->reg_mode;
+
+		data->state = START;
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_init_data(struct eap_sm *sm, struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+	const u8 *pwd;
+	size_t pwd_len;
+
+	do {
+		if (!sm || !data || !conf || !hapd)
+			break;
+
+		if (eap_wps_config_init_data(hapd, conf, data))
+			break;
+
+		pwd = sm->user->password;
+		pwd_len = sm->user->password_len;
+		if ( pwd && pwd_len ) {
+			if (pwd_len > sizeof(data->dev_pwd))
+				pwd_len = sizeof(data->dev_pwd);
+
+			if (8 == pwd_len) {
+				if (eap_wps_device_password_validation(pwd, (int)pwd_len))
+					data->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+				else
+					data->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			} else
+				data->dev_pwd_id = WPS_DEVICEPWDID_USER_SPEC;
+			os_memcpy(data->dev_pwd, pwd, pwd_len);
+			data->dev_pwd_len = pwd_len;
+
+			conf->upnp_enabled = 0;
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static void *eap_wps_init(struct eap_sm *sm)
+{
+	int result = -1;
+	struct eap_wps_data *data;
+
+	do {
+		data = wpa_zalloc(sizeof(*data));
+		if (data == NULL)
+			break;
+
+		if (eap_wps_init_data(sm, data))
+			break;
+
+		sm->eap_method_priv = data;
+		result = 0;
+	} while (0);
+
+	if (result) {
+		os_free(data);
+		data = 0;
+	}
+
+	return data;
+}
+
+
+void
+eap_wps_config_deinit_data(struct eap_wps_data *data)
+{
+	do {
+		if (!data)
+			break;
+
+		if (data->rcvMsg) {
+			os_free(data->rcvMsg);
+			data->rcvMsg = 0;
+			data->rcvMsgLen = 0;
+			data->fragment = 0;
+		}
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+
+		if (!data->preset_pubKey && data->dh_secret) {
+			DH_free(data->dh_secret);
+			data->dh_secret = 0;
+		}
+
+		if (data->config) {
+			os_free(data->config);
+			data->config = 0;
+			data->config_len = 0;
+		}
+
+		if (data->target) {
+			eap_wps_clear_target_info(data);
+			os_free(data->target);
+			data->target = 0;
+		}
+
+		os_free(data);
+	} while (0);
+}
+
+
+static void eap_wps_reset(struct eap_sm *sm, void *priv)
+{
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+	if (data == NULL)
+		return;
+
+	eap_wps_config_deinit_data(data);
+}
+
+
+static void eap_wps_request(struct eap_sm *sm,
+							int req_type, const char *msg, size_t msg_len)
+{
+#define CTRL_REQ_TYPE_COMP			0
+#define CTRL_REQ_TYPE_FAIL			1
+#define CTRL_REQ_TYPE_PASSWORD		2
+	char *buf;
+	struct hostapd_data *hapd = 0;
+	size_t buflen;
+	int len = 0;
+	char *field;
+	char *txt;
+
+	if (sm == NULL)
+		return;
+
+	hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+	if (!hapd)
+		return;
+
+	switch(req_type) {
+	case CTRL_REQ_TYPE_COMP:
+		field = "EAP_WPS_COMP";
+		txt = "Complete EAP-WPS authentication";
+		break;
+	case CTRL_REQ_TYPE_FAIL:
+		field = "EAP_WPS_FAIL";
+		txt = "Fail EAP-WPS authentication";
+		break;
+	case CTRL_REQ_TYPE_PASSWORD:
+		field = "EAP_WPS_PASSWORD";
+		txt = "Request Password for EAP-WPS";
+		break;
+	default:
+		return;
+	}
+
+	buflen = 100 + os_strlen(txt);
+	buf = os_malloc(buflen);
+	if (buf == NULL)
+		return;
+	len = os_snprintf(buf + len, buflen - len, WPA_CTRL_REQ "%s%s%s%s-%s ",
+		       field, msg?":[":"", msg?msg:"", msg?"]":"", txt);
+	if (len < 0 || (size_t) len >= buflen) {
+		os_free(buf);
+		return;
+	}
+	buf[buflen - 1] = '\0';
+	hostapd_msg(hapd, MSG_INFO, "%s", buf);
+	os_free(buf);
+}
+
+
+int eap_wps_generate_sha256hash(u8 *inbuf, int inbuf_len, u8 *outbuf)
+{
+	int ret = -1;
+
+	do {
+		if (!inbuf || !inbuf_len || !outbuf)
+			break;
+
+		if (!SHA256(inbuf, inbuf_len, outbuf))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_free_dh(void **dh)
+{
+	int ret = -1;
+	do {
+		if (!dh || !*dh)
+			break;
+
+		DH_free(*dh);
+		*dh = 0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_generate_public_key(void **dh_secret, u8 *public_key)
+{
+	int ret = -1;
+	u8 tmp[SIZE_PUB_KEY];
+	DH *dh = 0;
+	u32 g;
+	int length;
+
+	do {
+		if (!dh_secret || !public_key)
+			break;
+
+		*dh_secret = 0;
+
+		dh = DH_new();
+		if(!dh)
+			break;
+
+		dh->p = BN_new();
+		if (!dh->p)
+			break;
+
+		dh->g = BN_new();
+		if (!dh->g)
+			break;
+	   
+		if(!BN_bin2bn(DH_P_VALUE, SIZE_1536_BITS, dh->p))
+			break;
+
+		g = host_to_be32(DH_G_VALUE);
+		if(!BN_bin2bn((u8 *)&g, 4, dh->g))
+			break;
+
+		if(!DH_generate_key(dh))
+			break;
+
+		length = BN_bn2bin(dh->pub_key, tmp);
+		if (!length)
+			break;
+
+		length = BN_bn2bin(dh->pub_key, public_key);
+		if (!length)
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret && dh) {
+		DH_free(dh);
+	} else if (dh) {
+		*dh_secret = dh;
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_generate_kdk(struct eap_wps_data *data, u8 *e_nonce, u8 *mac,
+								u8 *r_nonce, u8 *kdk)
+{
+	int ret = -1;
+	DH *dh_secret = (DH *)data->dh_secret;
+	BIGNUM *bn_peer = 0;
+	u8 sec_key[SIZE_PUB_KEY];
+	int sec_key_len;
+	u8 sec_key_sha[SIZE_256_BITS];
+	u8 kdk_src[SIZE_NONCE + SIZE_MAC_ADDR + SIZE_NONCE];
+	int kdk_src_len;
+
+	do {
+		if (!dh_secret || !e_nonce || !mac || !r_nonce || !kdk)
+			break;
+
+		bn_peer = BN_new();
+		if (!bn_peer)
+			break;
+
+		if (!BN_bin2bn(data->target->pubKey, SIZE_PUB_KEY, bn_peer))
+			break;
+
+		sec_key_len = DH_compute_key(sec_key, bn_peer, dh_secret);
+		if (-1 == sec_key_len)
+			break;
+
+		if (!SHA256(sec_key, sec_key_len, sec_key_sha))
+			break;
+
+		kdk_src_len = 0;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, e_nonce, SIZE_NONCE);
+		kdk_src_len += SIZE_NONCE;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, mac, SIZE_MAC_ADDR);
+		kdk_src_len += SIZE_MAC_ADDR;
+		os_memcpy((u8 *)kdk_src + kdk_src_len, r_nonce, SIZE_NONCE);
+		kdk_src_len += SIZE_NONCE;
+		if (!HMAC(EVP_sha256(), sec_key_sha, SIZE_256_BITS,
+				  kdk_src, kdk_src_len, kdk, NULL))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (bn_peer)
+		BN_free(bn_peer);
+
+	return ret;
+}
+
+
+static int eap_wps_key_derive_func(struct eap_wps_data *data, 
+								   u8 *kdk, char *personalization, u32 total_key_bits,
+								   u8 *keys, u32 *keys_len_bytes)
+{
+	int ret = -1;
+	u8 *prf;
+	u32 prf_len, iterations;
+	u8 *hmac = 0, *pos;
+	u32 hmac_len = 0, length = 0;
+	u32 i;
+
+	do {
+		prf_len = sizeof(u32) + os_strlen(personalization) + sizeof(u32);
+		prf = (u8 *)os_malloc(prf_len);
+		if (!prf)
+			break;
+
+		iterations = ((total_key_bits/8) + PRF_DIGEST_SIZE - 1) / PRF_DIGEST_SIZE;
+
+		pos = prf + sizeof(u32);
+		os_memcpy(pos, personalization, os_strlen(personalization));
+		pos += os_strlen(personalization);
+		WPA_PUT_BE32(pos, total_key_bits);
+
+		for (i = 1; i <= iterations; i++) {
+			WPA_PUT_BE32(prf, i);
+			length = 0;
+			(void)HMAC(EVP_sha256(), kdk, SIZE_256_BITS, prf, prf_len, 0, &length);
+			hmac = (u8 *)os_realloc(hmac, hmac_len + length);
+			pos = hmac + hmac_len;
+			if (!HMAC(EVP_sha256(), kdk, SIZE_256_BITS, prf, prf_len, pos, &length))
+				break;
+			hmac_len += length;
+		}
+		if (i <= iterations)
+			break; 
+		if ((total_key_bits / 8) > hmac_len)
+			break;
+
+		if (keys_len_bytes) {
+			*keys_len_bytes = total_key_bits / 8;
+		}
+
+		if (!keys)
+			break;
+		os_memcpy(keys, hmac, total_key_bits / 8);
+
+		ret = 0;
+	} while (0);
+
+	if (prf)
+		os_free(prf);
+	if (hmac)
+		os_free(hmac);
+	return ret;
+}
+
+
+static int eap_wps_hmac_validation(struct eap_wps_data *data,
+								   u8 *authenticator, u8 *auth_key)
+{
+	int ret = -1;
+	u8 *hmac_src = 0;
+	u32 hmac_src_len;
+	struct wps_data *wps = 0;
+	u8 *buf = 0;
+	u16 buf_len;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!data || !authenticator || !auth_key)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		if (wps_remove_value(wps, WPS_TYPE_AUTHENTICATOR))
+			break;
+
+		if (wps_write_wps_data(wps, &buf, &buf_len))
+			break;
+
+		hmac_src_len = data->sndMsgLen + buf_len;
+		hmac_src = (u8 *)os_malloc(hmac_src_len);
+		if (!hmac_src)
+			break;
+
+		os_memcpy(hmac_src, data->sndMsg, data->sndMsgLen);
+		os_memcpy(hmac_src + data->sndMsgLen, buf, buf_len);
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, hmac_src, hmac_src_len, hmac, NULL))
+			break;
+
+		if (os_memcmp(hmac, authenticator, SIZE_64_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (hmac_src)
+		os_free(hmac_src);
+	if (buf)
+		os_free(buf);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_encrypt_data(struct eap_wps_data *data,
+								u8 *inbuf, int inbuf_len,
+								u8 *encrKey,
+								u8 *iv, u8 **cipher, int *cipher_len)
+{
+	int ret = -1;
+	EVP_CIPHER_CTX ctx;
+	u8 buf[1024];
+	int buf_len;
+	int length, curr_len; int block_size;
+
+	do {
+		RAND_bytes(iv, SIZE_128_BITS);
+
+		if (!cipher || !cipher_len)
+			break;
+
+		if (!EVP_EncryptInit(&ctx, EVP_aes_128_cbc(), encrKey, iv))
+			break;
+
+		length = inbuf_len;
+		block_size = sizeof(buf) - SIZE_128_BITS;
+
+		*cipher = 0;
+		*cipher_len  = 0;
+		while (length) {
+			if (length > block_size)
+				curr_len = block_size;
+			else
+				curr_len = length;
+
+			if (!EVP_EncryptUpdate(&ctx, buf, &buf_len, inbuf, curr_len))
+				break;
+			*cipher = (u8 *)os_realloc(*cipher, *cipher_len + buf_len);
+			os_memcpy(*cipher + *cipher_len, buf, buf_len);
+			*cipher_len += buf_len;
+			length -= curr_len;
+		}
+
+		if (length)
+			break;
+
+		if (!EVP_EncryptFinal(&ctx, buf, &buf_len))
+			break;
+
+		*cipher = (u8 *)os_realloc(*cipher, *cipher_len + buf_len);
+		os_memcpy(*cipher + *cipher_len, buf, buf_len);
+		*cipher_len += buf_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (cipher_len)
+			*cipher_len = 0;
+		if (cipher && *cipher) {
+			os_free(*cipher);
+			*cipher = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_decrypt_data(struct eap_wps_data *data, u8 *iv,
+								u8 *cipher, int cipher_len,
+								u8 *encrKey, u8 **plain, int *plain_len)
+{
+	int ret = -1;
+	EVP_CIPHER_CTX ctx;
+	u8 buf[1024];
+	int buf_len = sizeof(buf);
+	int length, curr_len;
+	int block_size;
+
+	do {
+		if (!iv || !cipher || !encrKey || !plain || !plain_len)
+			break;
+
+		*plain = 0;
+		*plain_len = 0;
+
+		if (!EVP_DecryptInit(&ctx, EVP_aes_128_cbc(), encrKey, iv))
+			break;
+
+		length = cipher_len;
+		block_size = sizeof(buf) - SIZE_128_BITS;
+
+		while (length) {
+			if (length > block_size)
+				curr_len = block_size;
+			else
+				curr_len = length;
+
+			if (!EVP_DecryptUpdate(&ctx, buf, &buf_len, cipher, curr_len))
+				break;
+			*plain = (u8 *)os_realloc(*plain, *plain_len + buf_len);
+			os_memcpy(*plain + *plain_len, buf, buf_len);
+			*plain_len += buf_len;
+			length -= curr_len;
+		}
+
+		if (length)
+			break;
+
+		if (!EVP_DecryptFinal(&ctx, buf, &buf_len))
+			break;
+
+		*plain = (u8 *)os_realloc(*plain, *plain_len + buf_len);
+		os_memcpy(*plain + *plain_len, buf, buf_len);
+		*plain_len += buf_len;
+
+		ret = 0;
+	} while (0);
+
+	if (ret) {
+		if (plain_len)
+			*plain_len = 0;
+		if (plain || *plain) {
+			os_free(*plain);
+			*plain = 0;
+		}
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_encrsettings_creation(struct eap_wps_data *data,
+										 u16 nonce_type, u8 *nonce,
+										 u8 *buf, size_t buf_len,
+										 u8 *auth_key, u8 *key_wrap_auth,
+										 u8 **encrs, int *encrs_len)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 hmac[SIZE_256_BITS];
+	u16 length = 0;
+	u8 *tmp = 0;
+	u8 *cipher = 0, iv[SIZE_128_BITS];;
+	int cipher_len;
+
+	do {
+		if (!auth_key || !key_wrap_auth || !encrs || !encrs_len)
+			break;
+
+		*encrs = 0;
+		*encrs_len = 0;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (nonce) {
+			length = SIZE_NONCE;
+			if (wps_set_value(wps, nonce_type, nonce, length))
+				break;
+
+			length = 0;
+			if (wps_write_wps_data(wps, &tmp, &length))
+				break;
+		}
+
+		if (buf && buf_len) {
+			(void)wps_destroy_wps_data(&wps);
+
+			tmp = os_realloc(tmp, length + buf_len);
+			if (!tmp)
+				break;
+			os_memcpy(tmp + length, buf, buf_len);
+			length += buf_len;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(tmp, length, wps))
+				break;
+		}
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, tmp, length, hmac, NULL))
+			break;
+
+		if (wps_set_value(wps, WPS_TYPE_KEY_WRAP_AUTH, hmac, SIZE_64_BITS))
+			break;
+
+		os_free(tmp);
+		tmp = 0;
+
+		length = 0;
+		if (wps_write_wps_data(wps, &tmp, &length))
+			break;
+
+		if (eap_wps_encrypt_data(data, tmp, length, key_wrap_auth, iv, &cipher, &cipher_len))
+			break;
+
+		*encrs = os_malloc(SIZE_128_BITS + cipher_len);
+		if (!*encrs)
+			break;
+		os_memcpy(*encrs, iv, SIZE_128_BITS);
+		os_memcpy(*encrs + SIZE_128_BITS, cipher, cipher_len);
+		*encrs_len = SIZE_128_BITS + cipher_len;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (cipher)
+		os_free(cipher);
+
+	if (ret) {
+		if (encrs_len)
+			*encrs_len = 0;
+		if (encrs && *encrs) {
+			os_free(*encrs);
+			*encrs = 0;
+		}
+	}
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_encrsettings_validation(struct eap_wps_data *data,
+										   u8 *plain, int plain_len,
+										   u8 *auth_key, u16 nonce_type,
+										   u8 *nonce, u8 *key_wrap_auth)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u16 length;
+	u8 *buf = 0;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!plain || !plain_len || !key_wrap_auth)
+			break;
+		
+		if (wps_create_wps_data(&wps))
+			break;
+		if (wps_parse_wps_data(plain, plain_len, wps))
+			break;
+
+		if (nonce) {
+		/* Nonce */
+			length = SIZE_NONCE;
+			if (wps_get_value(wps, nonce_type, nonce, &length))
+				break;
+		}
+
+		/* Key Wrap Authenticator */
+		length = SIZE_8_BYTES;
+		if (wps_get_value(wps, WPS_TYPE_KEY_WRAP_AUTH, key_wrap_auth, &length))
+			break;
+
+		if (wps_remove_value(wps, WPS_TYPE_KEY_WRAP_AUTH))
+			break;
+
+		length = 0;
+		if (wps_write_wps_data(wps, &buf, &length))
+			break;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, buf, length, hmac, NULL))
+			break;
+
+		if (os_memcmp(hmac, key_wrap_auth, SIZE_64_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (nonce)
+			os_memset(nonce, 0, SIZE_NONCE);
+		if (key_wrap_auth)
+			os_memset(key_wrap_auth, 0, SIZE_8_BYTES);
+	}
+
+	return ret;
+}
+
+
+static int eap_wps_generate_hash(struct eap_wps_data *data,
+								 u8 *src, int src_len,
+								 u8 *pub_key1, u8 *pub_key2,
+								 u8 *auth_key,
+								 u8 *psk, u8 *es, u8 *hash)
+{
+	int ret = -1;
+	u8 hash_tmp[SIZE_256_BITS];
+	u8 hash_src[SIZE_128_BITS * 2 + SIZE_PUB_KEY * 2];
+	u8 *tmp;
+
+	do {
+		if (!src || !pub_key1 || !pub_key2 || !psk || !es || !auth_key)
+			break;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, src, src_len,
+			 hash_tmp, NULL))
+			break;
+		os_memcpy(psk, hash_tmp, SIZE_128_BITS);
+
+		RAND_bytes(es, SIZE_128_BITS);
+
+		tmp = hash_src;
+		os_memcpy(tmp, es, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, psk, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, pub_key1, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+		os_memcpy(tmp, pub_key2, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS,
+				  hash_src, tmp - hash_src, hash, NULL))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_generate_device_password_id(u16 *dev_pwd_id)
+{
+	int ret = -1;
+
+	do {
+		if (!dev_pwd_id)
+			break;
+
+		RAND_bytes((u8 *)dev_pwd_id, 2);
+		*dev_pwd_id |= 0x8000;
+		*dev_pwd_id &= 0xfff0;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 eap_wps_compute_device_password_checksum(u32 pin)
+{
+	u32 acc = 0;
+	u32 tmp = pin * 10;
+
+	acc += 3 * ((tmp / 10000000) % 10);
+	acc += 1 * ((tmp / 1000000) % 10);
+	acc += 3 * ((tmp / 100000) % 10);
+	acc += 1 * ((tmp / 10000) % 10);
+	acc += 3 * ((tmp / 1000) % 10);
+	acc += 1 * ((tmp / 100) % 10);
+	acc += 3 * ((tmp / 10) % 10);
+
+	return (u8)(10 - (acc % 10)) % 10;
+}
+
+
+int eap_wps_generate_device_password(u8 *dev_pwd, int dev_pwd_len)
+{
+	int ret = -1;
+
+	do {
+		if (!dev_pwd || !dev_pwd_len)
+			break;
+
+		RAND_bytes(dev_pwd, dev_pwd_len);
+		if (8 == dev_pwd_len) {
+			u32 val;
+			u8 check_sum, tmp[9];
+			val = *(u32 *)dev_pwd;
+			check_sum = eap_wps_compute_device_password_checksum(val);
+			val = val * 10 + check_sum;
+			os_snprintf((char *)tmp, 9, "%08u", val);
+			os_memcpy(dev_pwd, tmp, 8);
+		}
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_oobdevpwd_public_key_hash_validation(const u8 *hashed, const u8 *raw)
+{
+	int ret = -1;
+	u8 src[SIZE_256_BITS];
+
+	do {
+		if (!hashed || !raw)
+			break;
+
+		if (eap_wps_generate_sha256hash((u8 *)raw, SIZE_PUB_KEY, src))
+			break;
+
+		if (os_memcmp(hashed, src, SIZE_20_BYTES))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int eap_wps_device_password_validation(const u8 *pwd, const int len)
+{
+	int ret = -1;
+	u32 pin;
+	char str_pin[9], *end;
+	u8 check_sum;
+
+	do {
+		if (!pwd || 8 != len)
+			break;
+
+		os_memcpy(str_pin, pwd, 8);
+		str_pin[8] = 0;
+		pin = strtoul(str_pin, &end, 10);
+		if (end != (str_pin + 8))
+			break;
+
+		check_sum = eap_wps_compute_device_password_checksum(pin / 10);
+		if (check_sum != (u8)(pin % 10))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int eap_wps_calcurate_authenticator(struct eap_wps_data *data,
+										   u8 *sndmsg, size_t sndmsg_len,
+										   u8 *auth_key, u8 *authenticator)
+{
+	int ret = -1;
+	u8 *hmac_src = 0;
+	int hmac_src_len;
+	u8 hmac[SIZE_256_BITS];
+
+	do {
+		if (!data || !sndmsg || !authenticator)
+			break;
+
+		hmac_src_len = data->rcvMsgLen + sndmsg_len;
+		hmac_src = (u8 *)os_malloc(hmac_src_len);
+		os_memcpy(hmac_src, data->rcvMsg, data->rcvMsgLen);
+		os_memcpy(hmac_src + data->rcvMsgLen, sndmsg, sndmsg_len);
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS,
+				  hmac_src, hmac_src_len, hmac, NULL))
+			break;
+
+		os_memcpy(authenticator, hmac, SIZE_64_BITS);
+
+		ret = 0;
+	} while (0);
+
+	if (hmac_src)
+		os_free(hmac_src);
+
+	return ret;
+}
+
+
+static int eap_wps_hash_validation(struct eap_wps_data *data,
+								   u8 *compared,
+								   u8 *rsnonce, u8 *psk,
+								   u8 *pub_key1, u8 *pub_key2,
+								   u8 *auth_key)
+{
+	int ret = -1;
+	u8 hash_src[SIZE_128_BITS * 2 + SIZE_PUB_KEY * 2];
+	u8 *tmp;
+	u8 target[SIZE_256_BITS];
+
+	do {
+		if (!compared || !rsnonce || !psk || !pub_key1 || !pub_key2 || !auth_key)
+			break;
+
+		tmp = hash_src;
+		os_memcpy(tmp, rsnonce, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, psk, SIZE_128_BITS);
+		tmp += SIZE_128_BITS;
+		os_memcpy(tmp, pub_key1, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+		os_memcpy(tmp, pub_key2, SIZE_PUB_KEY);
+		tmp += SIZE_PUB_KEY;
+
+		if (!HMAC(EVP_sha256(), auth_key, SIZE_256_BITS, hash_src, tmp - hash_src, target, NULL))
+			 	break;
+
+		if (os_memcmp(compared, target, SIZE_256_BITS))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+eap_wps_config_get_ssid_configuration(struct hostapd_data *hapd,
+									  struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  u8 **config,
+									  size_t *config_len,
+									  Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 *tmp = 0, *tmp2 = 0;
+	size_t tmp_len;
+	u16 tmp2_len;
+	u16 length;
+
+	do {
+		if (!hapd || !conf || !config || !config_len)
+			break;
+		*config = 0;
+		*config_len = 0;
+
+		if (wps_get_ssid_configuration(hapd, &tmp, &tmp_len, !wrap_credential))
+			break;
+
+		if (wrap_credential) {
+			u8 nwIdx;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			/* Network Index */
+			nwIdx = 1;
+			if (wps_set_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, 0))
+				break;
+
+			tmp2_len = 0;
+			if (wps_write_wps_data(wps, &tmp2, &tmp2_len))
+				break;
+
+			(void)wps_destroy_wps_data(&wps);
+
+			tmp2 = os_realloc(tmp2, tmp2_len + tmp_len);
+			if (!tmp)
+				break;
+			os_memcpy(tmp2 + tmp2_len, tmp, tmp_len);
+			tmp2_len += tmp_len;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_set_value(wps, WPS_TYPE_CREDENTIAL, tmp2, tmp2_len))
+				break;
+
+			length = 0;
+			if (wps_write_wps_data(wps, config, &length))
+				break;
+
+			*config_len = length;
+		} else {
+			*config = (u8 *)os_malloc(tmp_len);
+			if (!*config)
+				break;
+			os_memcpy(*config, tmp, tmp_len);
+			*config_len = tmp_len;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+
+	if (tmp2)
+		os_free(tmp2);
+
+	if (wrap_credential)
+		wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (config && *config) {
+			os_free(*config);
+			*config = 0;
+		}
+		if (config_len)
+			*config_len = 0;
+	}
+
+	return ret;
+}
+
+
+int
+eap_wps_config_get_auto_configuration(struct hostapd_data *hapd,
+									  struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  u8 **config,
+									  size_t *config_len,
+									  Boolean wrap_credential)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 *tmp = 0, *tmp2 = 0;;
+	size_t tmp_len;
+	u16 tmp2_len;
+	u16 length;
+
+	do {
+		if (!hapd || !conf || !config || !config_len)
+			break;
+		*config = 0;
+		*config_len = 0;
+
+		if (wps_get_auto_configuration(hapd, &tmp, &tmp_len))
+			break;
+
+		if (wrap_credential) {
+			u8 nwIdx;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			/* Network Index */
+			nwIdx = 1;
+			if (wps_set_value(wps, WPS_TYPE_NW_INDEX, &nwIdx, 0))
+				break;
+
+			tmp2_len = 0;
+			if (wps_write_wps_data(wps, &tmp2, &tmp2_len))
+				break;
+
+			(void)wps_destroy_wps_data(&wps);
+
+			tmp2 = os_realloc(tmp2, tmp2_len + tmp_len);
+			if (!tmp)
+				break;
+			os_memcpy(tmp2 + tmp2_len, tmp, tmp_len);
+			tmp2_len += tmp_len;
+
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_set_value(wps, WPS_TYPE_CREDENTIAL, tmp2, tmp2_len))
+				break;
+
+			length = 0;
+			if (wps_write_wps_data(wps, config, &length))
+				break;
+
+			*config_len = length;
+		} else {
+			*config = (u8 *)os_malloc(tmp_len);
+			if (!*config)
+				break;
+			os_memcpy(*config, tmp, tmp_len);
+			*config_len = tmp_len;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+
+	if (tmp2)
+		os_free(tmp2);
+
+	if (wrap_credential)
+		wps_destroy_wps_data(&wps);
+
+	if (ret) {
+		if (config && *config) {
+			os_free(*config);
+			*config = 0;
+		}
+		if (config_len)
+			*config_len = 0;
+	}
+
+	return ret;
+}
+
+
+int
+eap_wps_config_set_ssid_configuration(struct hostapd_data *hapd,
+									  struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  u8 *raw_data, size_t raw_data_len,
+									  Boolean wrap_credential,
+									  char *out_filename)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 *val = 0;
+	u16 val_len;
+
+	do {
+		if (!hapd || !conf || !data || !raw_data || !raw_data_len)
+			break;
+
+		/* Creadential */
+		val_len = 0;
+		if (wrap_credential) {
+			if (wps_create_wps_data(&wps))
+				break;
+
+			if (wps_parse_wps_data(raw_data, raw_data_len, wps))
+				break;
+
+			(void)wps_get_value(wps, WPS_TYPE_CREDENTIAL, 0, &val_len);
+			if (!val_len)
+				break;
+			val = (u8 *)os_malloc(val_len);
+			if (!val)
+				break;
+			if (wps_get_value(wps, WPS_TYPE_CREDENTIAL, val, &val_len))
+				break;
+		} else {
+			val = (u8 *)os_malloc(raw_data_len);
+			if (!val)
+				break;
+			os_memcpy(val, raw_data, raw_data_len);
+			val_len = raw_data_len;
+		}
+
+		if (wps_set_ssid_configuration(hapd, out_filename, val, val_len))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (val)
+		os_free(val);
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_set_ssid_configuration(struct eap_sm *sm,
+										  struct eap_wps_data *data,
+										  u8 *raw_data, size_t raw_data_len,
+										  Boolean wrap_credential)
+{
+#define EAP_WPS_COMP_FILENAME "eap_wps_cmp.conf"
+	int ret = -1;
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !raw_data || !raw_data_len || !hapd || !conf)
+			break;
+
+		if (eap_wps_config_set_ssid_configuration(hapd, conf, data, raw_data,
+												  raw_data_len, wrap_credential,
+												  EAP_WPS_COMP_FILENAME))
+			break;
+
+		eap_wps_request(sm, CTRL_REQ_TYPE_COMP, EAP_WPS_COMP_FILENAME, os_strlen(EAP_WPS_COMP_FILENAME));
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+#undef EAP_WPS_COMP_FILENAME
+}
+
+
+u8 *
+eap_wps_config_build_message_M1(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !msg_len)
+			break;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M1;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* UUID-E */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_E, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* MAC Address */
+		if (!conf->mac_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_MAC_ADDR, conf->mac, sizeof(conf->mac)))
+			break;
+
+		/* Enrollee Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* Public Key */
+		if (!data->preset_pubKey) {
+			if (data->dh_secret)
+				eap_wps_free_dh(&data->dh_secret);
+			if (eap_wps_generate_public_key(&data->dh_secret, data->pubKey))
+				break;
+		}
+		if (wps_set_value(wps, WPS_TYPE_PUBLIC_KEY, data->pubKey, sizeof(data->pubKey)))
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &conf->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &conf->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &conf->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_METHODS, &conf->config_methods, 0))
+			break;
+
+		/* Wi-Fi Protected Setup State */
+		if (wps_set_value(wps, WPS_TYPE_WPSSTATE, &conf->wps_state, 0))
+			break;
+
+		/* Manufacturer */
+		if (wps_set_value(wps, WPS_TYPE_MANUFACTURER, conf->manufacturer, conf->manufacturer_len))
+			break;
+
+		/* Model Name */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NAME, conf->model_name, conf->model_name_len))
+			break;
+
+		/* Model Number */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NUMBER, conf->model_number, conf->model_number_len))
+			break;
+
+		/* Serial Number */
+		if (wps_set_value(wps, WPS_TYPE_SERIAL_NUM, conf->serial_number, conf->serial_number_len))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps, WPS_TYPE_PRIM_DEV_TYPE, conf->prim_dev_type, sizeof(conf->prim_dev_type)))
+			break;
+
+		/* Device Name */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_NAME, conf->dev_name, conf->dev_name_len))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps, WPS_TYPE_RF_BANDS, &conf->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_set_value(wps, WPS_TYPE_ASSOC_STATE, &data->assoc_state, 0))
+			break;
+
+		/* Device Passwork ID */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_PWD_ID, &data->dev_pwd_id, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &data->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M1(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M1(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M1(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	struct eap_wps_target_info *target;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		eap_wps_clear_target_info(data);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &target->version, 0))
+			break;
+		if ((target->version != WPS_VERSION) && (target->version != WPS_VERSION_EX))
+			break;
+
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M1)
+			break;
+
+		/* UUID-E */
+		length = sizeof(target->uuid);
+		if (wps_get_value(wps, WPS_TYPE_UUID_E, target->uuid, &length))
+			break;
+
+		/* MAC Address */
+		length = sizeof(target->mac);
+		if (wps_get_value(wps, WPS_TYPE_MAC_ADDR, target->mac, &length))
+			break;
+		target->mac_set = 1;
+
+		/* Enrollee Nonce */
+		length = sizeof(target->nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, &length))
+			break;
+
+		/* Public Key */
+		length = sizeof(target->pubKey);
+		if (wps_get_value(wps, WPS_TYPE_PUBLIC_KEY, target->pubKey, &length))
+			break;
+		if (data->preset_pubKey) {
+			if (eap_wps_oobdevpwd_public_key_hash_validation(data->pubKey, target->pubKey))
+				break;
+
+			os_memset(data->pubKey, 0, sizeof(data->pubKey));
+			data->preset_pubKey = 0;
+		}
+
+		/* Authentication Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &target->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &target->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &target->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_METHODS, &target->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		(void)wps_get_value(wps, WPS_TYPE_MANUFACTURER, 0, &length);
+		if (!length)
+			break;
+		target->manufacturer = (u8 *)os_malloc(length);
+		target->manufacturer_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MANUFACTURER, target->manufacturer, &length))
+			break;
+
+		/* Model Name */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NAME, 0, &length);
+		if (!length)
+			break;
+		target->model_name = (u8 *)os_malloc(length);
+		target->model_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NAME, target->model_name, &length))
+			break;
+
+		/* Model Number */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, 0, &length);
+		if (!length)
+			break;
+		target->model_number = (u8 *)os_malloc(length);
+		target->model_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, target->model_number, &length))
+			break;
+
+		/* Serial Number */
+		(void)wps_get_value(wps, WPS_TYPE_SERIAL_NUM, 0, &length);
+		if (!length)
+			break;
+		target->serial_number = (u8 *)os_malloc(length);
+		target->serial_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_SERIAL_NUM, target->serial_number, &length))
+			break;
+
+		/* Primary Device Type */
+		length = sizeof(target->prim_dev_type);
+		if (wps_get_value(wps, WPS_TYPE_PRIM_DEV_TYPE, target->prim_dev_type, &length))
+			break;
+
+		/* Device Name */
+		(void)wps_get_value(wps, WPS_TYPE_DEVICE_NAME, 0, &length);
+		if (!length)
+			break;
+		target->dev_name = (u8 *)os_malloc(length);
+		target->dev_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_NAME, target->dev_name, &length))
+			break;
+
+		/* RF Bands */
+		if (wps_get_value(wps, WPS_TYPE_RF_BANDS, &target->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_get_value(wps, WPS_TYPE_ASSOC_STATE, &target->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_get_value(wps, WPS_TYPE_OS_VERSION, &target->os_version, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		eap_wps_clear_target_info(data);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M1(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (!conf->dev_pwd_len && conf->upnp_iface)
+			(void)wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											 UPNP_WPS_WLANEVENT_TYPE_EAP);
+
+		if (!conf->upnp_enabled)
+#endif /* WPS_OPT_UPNP */
+		if (eap_wps_config_process_message_M1(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static int
+eap_wps_config_build_message_M2_M2D(struct wps_config *conf,
+									struct eap_wps_data *data,
+									struct wps_data *wps)
+{
+	int ret = -1;
+
+	do {
+		if (!conf || !data || !wps)
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &conf->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &conf->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_set_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &conf->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_METHODS, &conf->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		if (wps_set_value(wps, WPS_TYPE_MANUFACTURER, conf->manufacturer, conf->manufacturer_len))
+			break;
+
+		/* Model Name */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NAME, conf->model_name, conf->model_name_len))
+			break;
+
+		/* Model Number */
+		if (wps_set_value(wps, WPS_TYPE_MODEL_NUMBER, conf->model_number, conf->model_number_len))
+			break;
+
+		/* Serial Number */
+		if (wps_set_value(wps, WPS_TYPE_SERIAL_NUM, conf->serial_number, conf->serial_number_len))
+			break;
+
+		/* Primary Device Type */
+		if (wps_set_value(wps, WPS_TYPE_PRIM_DEV_TYPE, conf->prim_dev_type, sizeof(conf->prim_dev_type)))
+			break;
+
+		/* Device Name */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_NAME, conf->dev_name, conf->dev_name_len))
+			break;
+
+		/* RF Bands */
+		if (wps_set_value(wps, WPS_TYPE_RF_BANDS, &conf->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_set_value(wps, WPS_TYPE_ASSOC_STATE, &data->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &data->config_error, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M2(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 kdk[SIZE_256_BITS];
+	u8 keys[KDF_KEY_BITS/8];
+	u32 keys_length_bytes;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M2;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* UUID-R */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_R, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* Public Key */
+		if (!data->preset_pubKey) {
+			if (data->dh_secret)
+				eap_wps_free_dh(&data->dh_secret);
+			if (eap_wps_generate_public_key(&data->dh_secret, data->pubKey))
+				break;
+		}
+		if (wps_set_value(wps, WPS_TYPE_PUBLIC_KEY, data->pubKey, sizeof(data->pubKey)))
+			break;
+
+		/* M2/M2D common data */
+		if (eap_wps_config_build_message_M2_M2D(conf, data, wps))
+			break;
+
+		/* Device Password ID */
+		if (wps_set_value(wps, WPS_TYPE_DEVICE_PWD_ID, &data->dev_pwd_id, 0))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		/* Encrypted Settings */
+#if 0
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, encrs_len))
+			break;
+#endif
+
+		/* Generate KDK */
+		if (!target->mac_set)
+			break;
+		if (eap_wps_generate_kdk(data, target->nonce, target->mac, data->nonce, kdk))
+			break;
+
+		/* Key Derivation Function */
+		if (eap_wps_key_derive_func(data, kdk, WPS_PERSONALIZATION_STRING, KDF_KEY_BITS,
+							keys, &keys_length_bytes))
+			break;
+		os_memcpy(data->authKey, keys, SIZE_256_BITS);
+		os_memcpy(data->keyWrapKey, keys + SIZE_256_BITS, SIZE_128_BITS);
+		os_memcpy(data->emsk, keys + SIZE_256_BITS + SIZE_128_BITS, SIZE_256_BITS);
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M2(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		conf->upnp_enabled = 0;
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_M2(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+u8 *
+eap_wps_config_build_message_M2D(struct wps_config *conf,
+								 struct eap_wps_data *data,
+								 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M2D;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		RAND_bytes(data->nonce, sizeof(data->nonce));
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* UUID-R */
+		if (!conf->uuid_set)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_UUID_R, conf->uuid, sizeof(conf->uuid)))
+			break;
+
+		/* M2/M2D common data */
+		if (eap_wps_config_build_message_M2_M2D(conf, data, wps))
+			break;
+
+		/* OS Version */
+		if (wps_set_value(wps, WPS_TYPE_OS_VERSION, &conf->os_version, 0))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M2D(struct eap_sm *sm,
+									 struct eap_wps_data *data,
+									 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+	struct wps_data *wps = 0;
+	struct eap_wps_target_info *target;
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_iface) {
+			u8 msg_type;
+			msg = wps_opt_upnp_received_message(hapd->wps_opt_upnp, data,
+												msg_len);
+			if (msg) {
+				u16 length;
+				do {
+					target = data->target;
+					if (!target)
+						break;
+
+					/* Get Enrollee Nonce from M1 */
+					if (wps_create_wps_data(&wps))
+						break;
+					if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+						break;
+
+					/* Message Type */
+					if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+						break;
+					if (msg_type != WPS_MSGTYPE_M1)
+						break;
+
+					/* Enrollee Nonce */
+					length = sizeof(target->nonce);
+					if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, &length))
+						break;
+					(void)wps_destroy_wps_data(&wps);
+
+					/* Get Registrar Nonce from M2 */
+					if (wps_create_wps_data(&wps))
+						break;
+					if (wps_parse_wps_data(data->sndMsg, data->sndMsgLen, wps))
+						break;
+
+					/* Message Type */
+					if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+						break;
+					if ((msg_type != WPS_MSGTYPE_M2) && (msg_type != WPS_MSGTYPE_M2D))
+						break;
+
+					/* Registrar Nonce */
+					length = sizeof(data->nonce);
+					if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, data->nonce, &length))
+						break;
+					(void)wps_destroy_wps_data(&wps);
+				} while (0);
+				(void)wps_destroy_wps_data(&wps);
+
+				msg_type = wps_get_message_type(msg, *msg_len);
+				switch(msg_type) {
+				case WPS_MSGTYPE_M2:
+					data->state = M3;
+					break;
+				case WPS_MSGTYPE_M2D:
+					data->state = ACK;
+					break;
+				case WPS_MSGTYPE_NACK:
+					data->state = NACK;
+					break;
+				default:
+					if (msg) {
+						os_free(msg);
+						msg = 0;
+					}
+					*msg_len = 0;
+					break;
+				}
+			}
+		}
+
+		if (!conf->upnp_enabled && !msg &&
+			(M2D1 == data->state))
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_M2D(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+static int
+eap_wps_config_process_message_M2_M2D(struct wps_config *conf,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	u8 tmp[SIZE_64_BYTES];
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		eap_wps_clear_target_info(data);
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &target->version, 0))
+			break;
+		if ((target->version != WPS_VERSION) && (target->version != WPS_VERSION_EX))
+			break;
+
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if ((msg_type != WPS_MSGTYPE_M2) && (msg_type != WPS_MSGTYPE_M2D))
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(tmp);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, tmp, &length))
+			break;
+		if (os_memcmp(data->nonce, tmp, sizeof(data->nonce)))
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(target->nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, &length))
+			break;
+
+		/* UUID-R */
+		length = sizeof(target->uuid);
+		if (wps_get_value(wps, WPS_TYPE_UUID_R, target->uuid, &length))
+			break;
+
+		/* Authentication Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_AUTH_TYPE_FLAGS, &target->auth_type_flags, 0))
+			break;
+
+		/* Encryption Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_ENCR_TYPE_FLAGS, &target->encr_type_flags, 0))
+			break;
+
+		/* Connection Type Flags */
+		if (wps_get_value(wps, WPS_TYPE_CONN_TYPE_FLAGS, &target->conn_type_flags, 0))
+			break;
+
+		/* Config Methods */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_METHODS, &target->config_methods, 0))
+			break;
+
+		/* Manufacturer */
+		(void)wps_get_value(wps, WPS_TYPE_MANUFACTURER, 0, &length);
+		if (!length)
+			break;
+		target->manufacturer = (u8 *)os_malloc(length);
+		target->manufacturer_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MANUFACTURER, target->manufacturer, &length))
+			break;
+
+		/* Model Name */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NAME, 0, &length);
+		if (!length)
+			break;
+		target->model_name = (u8 *)os_malloc(length);
+		target->model_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NAME, target->model_name, &length))
+			break;
+
+		/* Model Number */
+		(void)wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, 0, &length);
+		if (!length)
+			break;
+		target->model_number = (u8 *)os_malloc(length);
+		target->model_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_MODEL_NUMBER, target->model_number, &length))
+			break;
+
+		/* Serial Number */
+		(void)wps_get_value(wps, WPS_TYPE_SERIAL_NUM, 0, &length);
+		if (!length)
+			break;
+		target->serial_number = (u8 *)os_malloc(length);
+		target->serial_number_len = length;
+		if (wps_get_value(wps, WPS_TYPE_SERIAL_NUM, target->serial_number, &length))
+			break;
+
+		/* Primary Device Type */
+		length = sizeof(target->prim_dev_type);
+		if (wps_get_value(wps, WPS_TYPE_PRIM_DEV_TYPE, target->prim_dev_type, &length))
+			break;
+
+		/* Device Name */
+		(void)wps_get_value(wps, WPS_TYPE_DEVICE_NAME, 0, &length);
+		if (!length)
+			break;
+		target->dev_name = (u8 *)os_malloc(length);
+		target->dev_name_len = length;
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_NAME, target->dev_name, &length))
+			break;
+
+		/* RF Bands */
+		if (wps_get_value(wps, WPS_TYPE_RF_BANDS, &target->rf_bands, 0))
+			break;
+
+		/* Association State */
+		if (wps_get_value(wps, WPS_TYPE_ASSOC_STATE, &target->assoc_state, 0))
+			break;
+
+		/* Configuration Error */
+		if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+			break;
+
+		/* OS Version */
+		if (wps_get_value(wps, WPS_TYPE_OS_VERSION, &target->os_version, 0))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (ret)
+		eap_wps_clear_target_info(data);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+int
+eap_wps_config_process_message_M2(struct wps_config *conf,
+								  struct eap_wps_data *data,
+								  Boolean *with_config)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	u8 kdk[SIZE_256_BITS];
+	u8 keys[KDF_KEY_BITS/8];
+	u32 keys_length_bytes;
+	u16 length;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (with_config)
+			*with_config = 0;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M2)
+			break;
+
+		if (eap_wps_config_process_message_M2_M2D(conf, data))
+			break;
+
+		/* Public Key */
+		length = sizeof(target->pubKey);
+		if (wps_get_value(wps, WPS_TYPE_PUBLIC_KEY, target->pubKey, &length))
+			break;
+
+		/* Device Password ID */
+		if (wps_get_value(wps, WPS_TYPE_DEVICE_PWD_ID, &target->dev_pwd_id, 0))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* Generate KDK */
+		if (eap_wps_generate_kdk(data, data->nonce, conf->mac, target->nonce, kdk))
+			break;
+
+		/* Key Derivation Function */
+		if (eap_wps_key_derive_func(data, kdk, WPS_PERSONALIZATION_STRING, KDF_KEY_BITS,
+							keys, &keys_length_bytes))
+			break;
+		os_memcpy(data->authKey, keys, SIZE_256_BITS);
+		os_memcpy(data->keyWrapKey, keys + SIZE_256_BITS, SIZE_128_BITS);
+		os_memcpy(data->emsk, keys + SIZE_256_BITS + SIZE_128_BITS, SIZE_256_BITS);
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (length) {
+			u8 *encrs = 0;
+			u8 *iv, *cipher;
+			int cipher_len;
+			u8 *config = 0;
+			int config_len;
+			int fail = 1;
+
+			do {
+				encrs = (u8 *)os_malloc(length);
+				if (!encrs)
+					break;
+				if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, &length))
+					break;
+
+				iv = encrs;
+				cipher = encrs + SIZE_128_BITS;
+				cipher_len = length - SIZE_128_BITS;
+				if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &config, &config_len))
+					break;
+
+				target->config = config;
+				target->config_len = config_len;
+
+				fail = 0;
+			} while (0);
+			
+			if (encrs)
+				os_free(encrs);
+			if (fail && config) {
+				os_free(config);
+				target->config = 0;
+				target->config_len = 0;
+			}
+			if (fail)
+				break;
+
+			if (with_config)
+				*with_config = 1;
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M2(struct eap_sm *sm,
+									  struct eap_wps_data *data,
+									  Boolean *with_config)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M2(conf, data, with_config))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+int
+eap_wps_config_process_message_M2D(struct wps_config *conf,
+								   struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M2D)
+			break;
+
+		if (eap_wps_config_process_message_M2_M2D(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M2D(struct eap_sm *sm,
+									   struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M2D(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M3(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M3;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Generate Device Password, if it hasn't been set yet */
+		if (!data->dev_pwd_len) {
+			if (eap_wps_generate_device_password(data->dev_pwd, 8))
+				break;
+			data->dev_pwd_len = 8;
+			data->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			printf("eap_wps : generated device password [%s]\n", data->dev_pwd);
+			os_memcpy(data->dev_pwd, "12345670", 8);
+			data->dev_pwd_len = 8;
+		}
+
+		/* E-Hash1 */
+		if (eap_wps_generate_hash(data, data->dev_pwd,
+								   data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->pubKey, target->pubKey, data->authKey,
+								   data->psk1, data->snonce1, data->hash1))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_E_HASH1, data->hash1, sizeof(data->hash1)))
+			break;
+
+		/* E-Hash2 */
+		if (eap_wps_generate_hash(data, data->dev_pwd + data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->dev_pwd_len/2,
+								   data->pubKey, target->pubKey, data->authKey,
+								   data->psk2, data->snonce2, data->hash2))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_E_HASH2, data->hash2, sizeof(data->hash2)))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M3(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M3(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M3(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	u8 tmp[SIZE_64_BYTES];
+	u16 length;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M3)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(tmp);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, tmp, &length))
+			break;
+		if (os_memcmp(tmp, data->nonce, sizeof(data->nonce)))
+			break;
+
+		/* E-Hash1 */
+		length = sizeof(target->hash1);
+		if (wps_get_value(wps, WPS_TYPE_E_HASH1, target->hash1, &length))
+			break;
+
+		/* E-Hash2 */
+		length = sizeof(target->hash2);
+		if (wps_get_value(wps, WPS_TYPE_E_HASH2, target->hash2, &length))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M3(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled) {
+			if (wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											 UPNP_WPS_WLANEVENT_TYPE_EAP))
+				break;
+		} else
+#endif /* WPS_OPT_UPNP */
+		if (eap_wps_config_process_message_M3(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M4(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 u8val;
+	u16 length;
+	u8 *encrs;
+	int encrs_len;
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M4;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		if (!data->dev_pwd_len)
+			break;
+
+		/* R-Hash1 */
+		if (eap_wps_generate_hash(data, data->dev_pwd,
+								   data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   target->pubKey, data->pubKey, data->authKey,
+								   data->psk1, data->snonce1, data->hash1))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_R_HASH1, data->hash1, sizeof(data->hash1)))
+			break;
+
+		/* R-Hash2 */
+		if (eap_wps_generate_hash(data, data->dev_pwd + data->dev_pwd_len/2 + data->dev_pwd_len%2,
+								   data->dev_pwd_len/2,
+								   target->pubKey, data->pubKey, data->authKey,
+								   data->psk2, data->snonce2, data->hash2))
+			break;
+		if(wps_set_value(wps, WPS_TYPE_R_HASH2, data->hash2, sizeof(data->hash2)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_R_SNONCE1, data->snonce1, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M4(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled)
+			msg = wps_opt_upnp_received_message(hapd->wps_opt_upnp, data,
+												msg_len);
+		else
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_M4(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M4(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 msg_type;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M4)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* R-Hash1 */
+		length = sizeof(target->hash1);
+		if (wps_get_value(wps, WPS_TYPE_R_HASH1, target->hash1, &length))
+			break;
+
+		/* R-Hash2 */
+		length = sizeof(target->hash2);
+		if (wps_get_value(wps, WPS_TYPE_R_HASH2, target->hash2, &length))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_R_SNONCE1, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* RHash1 validation */
+		if (eap_wps_hash_validation(data, target->hash1, rsnonce, data->psk1, data->pubKey, target->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M4(struct eap_sm *sm,
+									 struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M4(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M5(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M5;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_E_SNONCE1, data->snonce1, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M5(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M5(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M5(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	u8 version;
+	struct wps_data *wps = 0;
+	u8 msg_type;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M5)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_E_SNONCE1, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* EHash1 validation */
+		if (eap_wps_hash_validation(data, target->hash1, rsnonce, data->psk1, target->pubKey, data->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M5(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled) {
+			if (wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											 UPNP_WPS_WLANEVENT_TYPE_EAP))
+				break;
+		} else
+#endif /* WPS_OPT_UPNP */
+		if (eap_wps_config_process_message_M5(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M6(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M6;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_R_SNONCE2, data->snonce2, 0, 0, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M6(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled)
+			msg = wps_opt_upnp_received_message(hapd->wps_opt_upnp, data,
+												msg_len);
+		else
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_M6(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M6(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 msg_type;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M6)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_R_SNONCE2, rsnonce, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* RHash2 validation */
+		if (eap_wps_hash_validation(data, target->hash2, rsnonce, data->psk2, data->pubKey, target->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M6(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M6(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M7(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M7;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, WPS_TYPE_E_SNONCE2, data->snonce2, data->config, data->config_len, data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M7(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+		msg = eap_wps_config_build_message_M7(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M7(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 msg_type;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 rsnonce[SIZE_NONCE];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M7)
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len, data->authKey,
+											WPS_TYPE_E_SNONCE2, rsnonce, keyWrapAuth))
+			break;
+		if (target->config)
+			os_free(target->config);
+		target->config = decrypted;
+		target->config_len = decrypted_len;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		/* EHash2 validation */
+		if (eap_wps_hash_validation(data, target->hash2, rsnonce, data->psk2, target->pubKey, data->pubKey, data->authKey))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (ret && decrypted) {
+		os_free(decrypted);
+		if (data->target) {
+			target = data->target;
+			target->config = 0;
+			target->config_len = 0;
+		}
+	}
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M7(struct eap_sm *sm,
+									  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled) {
+			if (wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											 UPNP_WPS_WLANEVENT_TYPE_EAP))
+				break;
+		} else
+#endif /* WPS_OPT_UPNP */
+		if (eap_wps_config_process_message_M7(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_M8(struct wps_config *conf,
+								struct eap_wps_data *data,
+								size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 u8val;
+	u16 length;
+	u8 *encrs = 0;
+	int encrs_len;
+	u8 authenticator[SIZE_8_BYTES];
+
+	do {
+		if (!conf || !data || !data->target || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		u8val = WPS_MSGTYPE_M8;
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, target->nonce, sizeof(target->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		if (eap_wps_encrsettings_creation(data, 0, 0,
+					data->config, data->config_len,
+					data->authKey, data->keyWrapKey, &encrs, &encrs_len))
+			break;
+		if (wps_set_value(wps, WPS_TYPE_ENCR_SETTINGS, encrs, (u16)encrs_len))
+			break;
+
+		/* Authenticator */
+		length = 0;
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+		if (eap_wps_calcurate_authenticator(data, msg, length,
+									data->authKey, authenticator)) {
+			os_free(msg);
+			msg = 0;
+			break;
+		}
+		os_free(msg);
+		msg = 0;
+		if (wps_set_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, sizeof(authenticator)))
+			break;
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	if (encrs)
+		os_free(encrs);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_M8(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled)
+			msg = wps_opt_upnp_received_message(hapd->wps_opt_upnp, data,
+												msg_len);
+		else
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_M8(conf, data, msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_M8(struct wps_config *conf,
+								  struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 msg_type;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+	u8 *tmp = 0, *iv, *cipher, *decrypted = 0;
+	int cipher_len, decrypted_len;
+	u8 authenticator[SIZE_8_BYTES];
+	u8 keyWrapAuth[SIZE_64_BITS];
+
+	do {
+		if (!conf || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+		if (msg_type != WPS_MSGTYPE_M8)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(data->nonce, nonce, sizeof(data->nonce)))
+			break;
+
+		/* Encrypted Settings */
+		length = 0;
+		(void)wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, 0, &length);
+		if (!length)
+			break;
+		tmp = (u8 *)os_malloc(length);
+		if (!tmp)
+			break;
+		if (wps_get_value(wps, WPS_TYPE_ENCR_SETTINGS, tmp, &length))
+			break;
+		iv = tmp;
+		cipher = tmp + SIZE_128_BITS;
+		cipher_len = length - SIZE_128_BITS;
+		if (eap_wps_decrypt_data(data, iv, cipher, cipher_len, data->keyWrapKey, &decrypted, &decrypted_len))
+			break;
+		if (eap_wps_encrsettings_validation(data, decrypted, decrypted_len,
+											data->authKey, 0, 0, keyWrapAuth))
+			break;
+
+		/* Authenticator */
+		length = sizeof(authenticator);
+		if (wps_get_value(wps, WPS_TYPE_AUTHENTICATOR, authenticator, &length))
+			break;
+
+		/* HMAC validation */
+		if (eap_wps_hmac_validation(data, authenticator, data->authKey))
+			break;
+
+		if (target->config)
+			os_free(target->config);
+		target->config = decrypted;
+		target->config_len = decrypted_len;
+
+		ret = 0;
+	} while (0);
+
+	if (tmp)
+		os_free(tmp);
+	if (ret && decrypted)
+		os_free(decrypted);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_M8(struct eap_sm *sm,
+									 struct eap_wps_data *data)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+	do {
+		if (!sm || !data || !conf)
+			break;
+
+		if (eap_wps_config_process_message_M8(conf, data))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+u8 *
+eap_wps_config_build_message_special(struct wps_config *conf,
+									 struct eap_wps_data *data,
+									 u8 msg_type,
+									 u8 *e_nonce, u8 *r_nonce,
+									 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u16 length;
+
+	do {
+		if (!conf || !data || !data->target || !e_nonce || !r_nonce || !msg_len)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		/* Version */
+		if (!conf->version)
+			break;
+		if (wps_set_value(wps, WPS_TYPE_VERSION, &conf->version, 0))
+			break;
+
+		/* Message Type */
+		if (wps_set_value(wps, WPS_TYPE_MSG_TYPE, &msg_type, 0))
+			break;
+
+		/* Enrollee Nonce */
+		if (wps_set_value(wps, WPS_TYPE_ENROLLEE_NONCE, e_nonce, SIZE_UUID))
+			break;
+
+		/* Registrar Nonce */
+		if (wps_set_value(wps, WPS_TYPE_REGISTRAR_NONCE, r_nonce, SIZE_UUID))
+			break;
+
+		/* Configuration Error */
+		if (WPS_MSGTYPE_NACK == msg_type) {
+			if (wps_set_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+				break;
+		}
+
+		if (wps_write_wps_data(wps, &msg, &length))
+			break;
+
+		*msg_len = length;
+
+		if (data->sndMsg) {
+			os_free(data->sndMsg);
+			data->sndMsg = 0;
+			data->sndMsgLen = 0;
+		}
+		data->sndMsg = (u8 *)os_malloc(*msg_len);
+		if (!data->sndMsg) {
+			os_free(msg);
+			msg = 0;
+			*msg_len = 0;
+			break;
+		}
+
+		os_memcpy(data->sndMsg, msg, *msg_len);
+		data->sndMsgLen = *msg_len;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return msg;
+}
+
+
+static u8 *eap_wps_build_message_special(struct eap_sm *sm,
+										 struct eap_wps_data *data,
+										 u8 msg_type,
+										 u8 *e_nonce, u8 *r_nonce,
+										 size_t *msg_len)
+{
+	u8 *msg = 0;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !e_nonce || !r_nonce || !msg_len || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (conf->upnp_enabled)
+			msg = wps_opt_upnp_received_message(hapd->wps_opt_upnp, data,
+												msg_len);
+		else
+#endif /* WPS_OPT_UPNP */
+		msg = eap_wps_config_build_message_special(conf, data, msg_type,
+												   e_nonce, r_nonce,
+												   msg_len);
+	} while (0);
+
+	return msg;
+}
+
+
+int
+eap_wps_config_process_message_special(struct wps_config *conf,
+									   struct eap_wps_data *data,
+									   u8 msg_type,
+									   u8 *e_nonce, u8 *r_nonce)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	struct wps_data *wps = 0;
+	u8 version;
+	u8 u8val;
+	u8 nonce[SIZE_NONCE];
+	u16 length;
+
+	do {
+		if (!data->target)
+			break;
+		target = data->target;
+
+		if (wps_create_wps_data(&wps))
+			break;
+
+		if (wps_parse_wps_data(data->rcvMsg, data->rcvMsgLen, wps))
+			break;
+
+		/* Version */
+		if (wps_get_value(wps, WPS_TYPE_VERSION, &version, 0))
+			break;
+		if ((version != WPS_VERSION) && (version != WPS_VERSION_EX))
+			break;
+
+		/* Message Type */
+		if (wps_get_value(wps, WPS_TYPE_MSG_TYPE, &u8val, 0))
+			break;
+		if (msg_type != u8val)
+			break;
+
+		/* Enrollee Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_ENROLLEE_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(e_nonce, nonce, length))
+			break;
+
+		/* Registrar Nonce */
+		length = sizeof(nonce);
+		if (wps_get_value(wps, WPS_TYPE_REGISTRAR_NONCE, nonce, &length))
+			break;
+		if (os_memcmp(r_nonce, nonce, length))
+			break;
+
+		if (msg_type == WPS_MSGTYPE_NACK) {
+			/* Configuration Error */
+			if (wps_get_value(wps, WPS_TYPE_CONFIG_ERROR, &target->config_error, 0))
+				break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	(void)wps_destroy_wps_data(&wps);
+
+	return ret;
+}
+
+
+static int eap_wps_process_message_special(struct eap_sm *sm,
+										   struct eap_wps_data *data,
+										   u8 msg_type,
+										   u8 *e_nonce, u8 *r_nonce)
+{
+	int ret = -1;
+	struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+#ifdef WPS_OPT_UPNP
+	struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if (!sm || !data || !e_nonce || !r_nonce || !conf)
+			break;
+
+#ifdef WPS_OPT_UPNP
+		if (!hapd)
+			break;
+
+		if (msg_type == WPS_MSGTYPE_DONE) {
+			(void)wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											   UPNP_WPS_WLANEVENT_TYPE_EAP);
+		} else if (conf->upnp_enabled) {
+			if (wps_opt_upnp_send_wlan_event(hapd->wps_opt_upnp, data,
+											 UPNP_WPS_WLANEVENT_TYPE_EAP))
+				break;
+		} else
+#endif /* WPS_OPT_UPNP */
+		if (eap_wps_config_process_message_special(conf, data, msg_type,
+												   e_nonce, r_nonce))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 *eap_wps_build_packet(u8 code, u8 identifier,
+								u8 op_code, u8 flags,
+								u8 *msg, size_t msg_len,
+								size_t *rsp_len)
+{
+	u8 *rsp = 0;
+	struct eap_hdr *rsp_hdr;
+	struct eap_format *rsp_fmt;
+	u8 *tmp;
+#ifdef WPS_OPT_UPNP
+	u8 msg_type;
+#endif /* WPS_OPT_UPNP */
+
+	do {
+		if ((!msg && msg_len) || !rsp_len)
+			break;
+
+		if (flags & EAP_FLAG_LF)
+			*rsp_len = sizeof(*rsp_hdr) + sizeof(*rsp_fmt) + msg_len + 2;
+		else
+			*rsp_len = sizeof(*rsp_hdr) + sizeof(*rsp_fmt) + msg_len;
+		rsp = wpa_zalloc(*rsp_len);
+		
+		if (rsp) {
+			rsp_hdr = (struct eap_hdr *)rsp;
+			rsp_hdr->code = code;
+			rsp_hdr->identifier = identifier;
+			rsp_hdr->length = host_to_be16(*rsp_len);
+
+			rsp_fmt = (struct eap_format *)(rsp_hdr + 1);
+			rsp_fmt->type = EAP_TYPE_EXPANDED;
+			os_memcpy(rsp_fmt->vendor_id, EAP_VENDOR_ID_WPS, sizeof(rsp_fmt->vendor_id));
+			os_memcpy(rsp_fmt->vendor_type, EAP_VENDOR_TYPE_WPS, sizeof(rsp_fmt->vendor_type));
+#ifdef WPS_OPT_UPNP
+			msg_type = wps_get_message_type(msg, msg_len);
+			switch (msg_type) {
+			case WPS_MSGTYPE_ACK:
+				if (op_code != EAP_OPCODE_WPS_ACK)
+					op_code = EAP_OPCODE_WPS_ACK;
+				break;
+			case WPS_MSGTYPE_DONE:
+				if (op_code != EAP_OPCODE_WPS_DONE)
+					op_code = EAP_OPCODE_WPS_DONE;
+				break;
+			case WPS_MSGTYPE_NACK:
+				if (op_code != EAP_OPCODE_WPS_NACK)
+					op_code = EAP_OPCODE_WPS_NACK;
+				break;
+			default:
+				break;
+			}
+#endif /* WPS_OPT_UPNP */
+			rsp_fmt->op_code = op_code;
+			rsp_fmt->flags = flags;
+
+			tmp = (u8 *)(rsp_fmt + 1);
+			if (flags & EAP_FLAG_LF) {
+				WPA_PUT_BE16(tmp, msg_len);
+				tmp += 2;
+			}
+
+			if (msg_len)
+				os_memcpy(tmp, msg, msg_len);
+		}
+	} while (0);
+
+	if (!rsp && rsp_len)
+		*rsp_len = 0;
+
+	return rsp;
+}
+
+
+static u8 *eap_wps_build_req_registrar(struct eap_sm *sm,
+									   struct eap_wps_data *data,
+									   u8 req_identifier,
+									   size_t *req_len)
+{
+	u8 *req = 0;
+	u8 *wps_msg = 0;
+	size_t wps_msg_len;
+	struct eap_wps_target_info *target = data->target;
+
+	do {
+		switch (data->state) {
+		case START:
+		{
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+									   EAP_OPCODE_WPS_START, 0, NULL, 0,
+									   req_len);
+			if(!req)
+				break;
+			data->state = M1;
+			break;
+		}
+		case M2:
+		{
+			/* Build M2 message */
+			if (!(wps_msg = eap_wps_build_message_M2(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M3;
+			break;
+		}
+		case M2D1:
+		{
+			int prev_state = data->state;
+
+			/* Build M2D message */
+			if (!(wps_msg = eap_wps_build_message_M2D(sm, data, &wps_msg_len))) {
+				if (M2D2 == data->state)
+					data->state = FAILURE;
+				break;
+			}
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+#ifdef WPS_OPT_UPNP
+			/* data->state may change in eap_wps_build_message_M2D */
+			/* when UPnP is enabled */
+			if ((M2D1 == prev_state) && ((NACK != data->state) && (M3 != data->state))) {
+#endif /* WPS_OPT_UPNP */
+			eap_wps_request(sm, CTRL_REQ_TYPE_PASSWORD, "REGISTRAR", 9);
+			data->state = ACK;
+#ifdef WPS_OPT_UPNP
+			}
+#endif /* WPS_OPT_UPNP */
+			break;
+		}
+#ifdef WPS_OPT_UPNP
+		case M2D2:
+		{
+			if (!data->sndMsg || !data->sndMsgLen)
+				data->state = FAILURE;
+			else {
+				/* Build M2D message */
+				req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+											EAP_OPCODE_WPS_MSG, 0,
+											data->sndMsg, data->sndMsgLen,
+											req_len);
+				if(!req)
+					break;
+				data->state = ACK;
+			}
+			break;
+		}
+#endif /* WPS_OPT_UPNP */
+		case M4:
+		{
+			/* Build M4 message */
+			if (!(wps_msg = eap_wps_build_message_M4(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M5;
+			break;
+		}
+		case M6:
+		{
+			/* Build M6 message */
+			if (!(wps_msg = eap_wps_build_message_M6(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M7;
+			break;
+		}
+		case M8:
+		{
+			/* Build M8 message */
+			if (!(wps_msg = eap_wps_build_message_M8(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = DONE;
+			break;
+		}
+		case NACK:
+		{
+			/* Build NACK */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = NACK;
+		}
+		default:
+		{
+			/* Build NACK */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = NACK;
+			break;
+		}
+		}
+	} while (0);
+
+	if (wps_msg)
+		os_free(wps_msg);
+
+	return req;
+}
+
+
+static int eap_wps_process_registrar(struct eap_sm *sm,
+									 struct eap_wps_data *data,
+									 u8 req_identifier,
+									 u8 req_op_code)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	int prev_state;
+
+	do {
+		if (!sm || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (data->interface != REGISTRAR)
+			break;
+
+		switch (req_op_code) {
+		case EAP_OPCODE_WPS_NACK:
+			data->state = NACK;
+			break;
+		default:
+			break;
+		}
+
+		prev_state = data->state;
+		switch (data->state) {
+		case M1:
+		{
+			/* Should be received M1 message */
+			if (!eap_wps_process_message_M1(sm, data)) {
+				if (data->dev_pwd_len) {
+					data->state = M2;
+				} else {
+					data->state = M2D1;
+				}
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M3:
+		{
+			/* Should be received M3 message */
+			if (!eap_wps_process_message_M3(sm, data)) {
+				data->state = M4;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M5:
+		{
+			/* Should be received M5 message */
+			if (!eap_wps_process_message_M5(sm, data)) {
+				data->state = M6;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case M7:
+		{
+			/* Should be received M7 message */
+			if (!eap_wps_process_message_M7(sm, data)) {
+				data->state = M8;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case DONE:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received Done */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_DONE, target->nonce, data->nonce)) {
+				if (!conf->upnp_enabled &&
+					(conf->wps_state == WPS_WPSSTATE_UNCONFIGURED)) {
+					/* Set Network Configuration */
+					(void)eap_wps_set_ssid_configuration(sm, data, data->config, data->config_len, 1);
+					conf->wps_state = WPS_WPSSTATE_CONFIGURED;
+				} else {
+#ifdef WPS_OPT_UPNP
+					if (!conf->upnp_enabled)
+#endif /* WPS_OPT_UPNP */
+					/* Send EAP-WPS complete message */
+					eap_wps_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+				}
+
+				if (conf->enabled_pbc) {
+					struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+					(void)eap_wps_enabled_pbc(hapd, conf, 0);
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				data->state = FAILURE;
+			} else
+				data->state = NACK;
+			break;
+		}
+		case ACK:
+		{
+			/* Should be received ACK */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_ACK, target->nonce, data->nonce)) {
+#ifndef WPS_OPT_UPNP
+				data->state = FAILURE;
+#else /* WPS_OPT_UPNP */
+				u8 *wps_msg = 0;
+				size_t wps_msg_len;
+
+				/* Check if other M2D message is avalable */
+				data->state = M2D2;
+				if (!(wps_msg = eap_wps_build_message_M2D(sm, data, &wps_msg_len))) {
+					data->state = FAILURE;
+					break;
+				}
+				os_free(wps_msg);
+#endif /* WPS_OPT_UPNP */
+			}
+			data->state = FAILURE;
+			break;
+		}
+		case NACK:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received NACK */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_NACK, target->nonce, data->nonce)) {
+				if (conf->enabled_pbc) {
+					struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+					(void)eap_wps_enabled_pbc(hapd, conf, 0);
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+#ifdef WPS_OPT_UPNP
+				if (!conf->upnp_enabled)
+#endif /* WPS_OPT_UPNP */
+				/* Send EAP-WPS fail message */
+				eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, 0, 0);
+			}
+
+			data->state = FAILURE;
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+
+		if (prev_state != data->state)
+			ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 *eap_wps_build_req_enrollee(struct eap_sm *sm,
+									  struct eap_wps_data *data,
+									  u8 req_identifier,
+									  size_t *req_len)
+{
+	u8 *req = 0;
+	u8 *wps_msg = 0;
+	size_t wps_msg_len;
+	struct eap_wps_target_info *target;
+
+	do {
+		if (!sm || !data || !data->target || !req_len)
+			break;
+		target = data->target;
+
+		switch (data->state) {
+		case START:
+		{
+			/* Should be received Start Message */
+			/* Build M1 message */
+			if (!(wps_msg = eap_wps_build_message_M1(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M2;
+			break;
+		}
+		case M3:
+		{
+			/* Build M3 message */
+			if (!(wps_msg = eap_wps_build_message_M3(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M4;
+			break;
+		}
+		case M5:
+		{
+			/* Build M5 message */
+			if (!(wps_msg = eap_wps_build_message_M5(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M6;
+			break;
+		}
+		case M7:
+		{
+			/* Build M7 message */
+			if (!(wps_msg = eap_wps_build_message_M7(sm, data, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_MSG, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = M8;
+			break;
+		}
+		case NACK:
+		{
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = NACK;
+			break;
+		}
+		case DONE:
+		{
+			/* Build Done */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_DONE, data->nonce, target->nonce, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_DONE, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = ACK;
+			break;
+		}
+		default:
+		{
+			/* Build NACK */
+			if (!(wps_msg = eap_wps_build_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce, &wps_msg_len)))
+				break;
+
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, req_identifier,
+										EAP_OPCODE_WPS_NACK, 0,
+										wps_msg, wps_msg_len,
+										req_len);
+			if(!req)
+				break;
+			data->state = NACK;
+			break;
+		}
+		}
+	} while (0);
+
+	return req;
+}
+
+
+static int eap_wps_process_enrollee(struct eap_sm *sm,
+									struct eap_wps_data *data,
+									u8 rsp_identifier,
+									u8 rsp_op_code)
+{
+	int ret = -1;
+	struct eap_wps_target_info *target;
+	int prev_state;
+
+	do {
+		if (!sm || !data || !data->target)
+			break;
+		target = data->target;
+
+		if (data->interface != ENROLLEE)
+			break;
+
+		switch (rsp_op_code) {
+		case EAP_OPCODE_WPS_MSG:
+			break;
+		case EAP_OPCODE_WPS_NACK:
+			data->state = NACK;
+			break;
+		default:
+			break;
+		}
+
+		prev_state = data->state;
+		switch (data->state) {
+		case M2:
+		{
+			Boolean with_config;
+			/* Should be received M2/M2D message */
+			if (!eap_wps_process_message_M2(sm, data, &with_config)) {
+				/* Received M2 */
+				if (with_config) {
+					/* Build Done message */
+					data->state = DONE;
+				} else {
+					/* Build M3 message */
+					data->state = M3;
+				}
+			} else if (!eap_wps_process_message_M2D(sm, data)) {
+				char msg[32];
+				int len;
+
+				/* Received M2D */
+				/* Build NACK message */
+				data->state = NACK;
+
+				len = os_snprintf(msg, sizeof(msg), "ENROLLEE:%d", data->reg_mode);
+				if ((data->reg_mode != WPS_REGMODE_REGISTER_STA) &&
+				    (data->dev_pwd_id == WPS_DEVICEPWDID_DEFAULT) &&
+					data->dev_pwd_len) {
+					len += os_snprintf(msg + len, sizeof(msg) - len, "-");
+					os_strncpy(msg + len, (char *)data->dev_pwd, 8);
+					len += 8;
+					msg[len] = 0;
+				}
+				eap_wps_request(sm, CTRL_REQ_TYPE_PASSWORD, msg, os_strlen(msg));
+			}
+			break;
+		}
+		case M4:
+		{
+			/* Should be received M4 message */
+			if (!eap_wps_process_message_M4(sm, data)) {
+				/* Build M5 message */
+				data->state = M5;
+			}
+			break;
+		}
+		case M6:
+		{
+			/* Should be received M6 message */
+			if (!eap_wps_process_message_M6(sm, data)) {
+				/* Build M7 message */
+				data->state = M7;
+			}
+			break;
+		}
+		case M8:
+		{
+			/* Should be received M8 message */
+			if (!eap_wps_process_message_M8(sm, data)) {
+				data->state = DONE;
+			}
+			break;
+		}
+		case ACK:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received ACK message */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_ACK, data->nonce, target->nonce)) {
+				switch (data->reg_mode) {
+				case WPS_REGMODE_NONE_GET_CONF:
+					if (target->config)
+						/* Set Network Configuration */
+						(void)eap_wps_set_ssid_configuration(sm, data, target->config, target->config_len, 0);
+					else
+						/* Send EAP-WPS complete message */
+						eap_wps_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+					break;
+				case WPS_REGMODE_NONE_ADDED:
+					/* Send EAP-WPS complete message */
+					eap_wps_request(sm, CTRL_REQ_TYPE_COMP, 0, 0);
+					break;
+				default:
+					break;
+				}
+
+				if (conf->enabled_pbc) {
+					struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+					(void)eap_wps_enabled_pbc(hapd, conf, 0);
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				data->state = FAILURE;
+			}
+			break;
+		}
+		case NACK:
+		{
+			struct wps_config *conf = (struct wps_config *)eap_get_wps_config(sm);
+
+			/* Should be received NACK message */
+			if (!eap_wps_process_message_special(sm, data, WPS_MSGTYPE_NACK, data->nonce, target->nonce)) {
+				if (conf->enabled_pbc) {
+					struct hostapd_data *hapd = (struct hostapd_data *)eap_get_hostapd_data(sm);
+					(void)eap_wps_enabled_pbc(hapd, conf, 0);
+				}
+
+				if (conf->dev_pwd_len) {
+					conf->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+					os_memset(conf->dev_pwd, 0, sizeof(conf->dev_pwd));
+					conf->dev_pwd_len = 0;
+				}
+
+				if (conf->set_pub_key) {
+					if (conf->dh_secret)
+						eap_wps_free_dh(&conf->dh_secret);
+					os_memset(conf->pub_key, 0, sizeof(conf->pub_key));
+					conf->set_pub_key = 0;
+				}
+
+				/* Send EAP-WPS fail message */
+				eap_wps_request(sm, CTRL_REQ_TYPE_FAIL, 0, 0);
+			}
+
+			data->state = FAILURE;
+			break;
+		}
+		default:
+		{
+			break;
+		}
+		}
+
+		if (prev_state != data->state)
+			ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static u8 *eap_wps_build_req(struct eap_sm *sm, void *priv, int id,
+							 size_t *req_len)
+{
+	u8 *req = 0;
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+	const u8 *identity;
+	size_t identity_len;
+
+	do {
+		if (data->fragment) {
+			req = eap_wps_build_packet(EAP_CODE_REQUEST, id,
+									   EAP_OPCODE_WPS_FLAG_ACK, 0, NULL, 0,
+									   req_len);
+			break;
+		}
+
+		identity = sm->identity;
+		identity_len = sm->identity_len;
+		if (0 == os_strncmp((char *)identity, WPS_IDENTITY_REGISTRAR, os_strlen(WPS_IDENTITY_REGISTRAR)))
+			data->interface = ENROLLEE;
+		else if (0 == os_strncmp((char *)identity, WPS_IDENTITY_ENROLLEE, os_strlen(WPS_IDENTITY_ENROLLEE)))
+			data->interface = REGISTRAR;
+		else {
+			/* Error */
+			return 0;
+		}
+
+		switch (data->interface) {
+		case REGISTRAR:
+			req = eap_wps_build_req_registrar(sm, data, id,
+											  req_len);
+			break;
+		case ENROLLEE:
+			req = eap_wps_build_req_enrollee(sm, data, id,
+											 req_len);
+			break;
+		default:
+			break;
+		}
+	} while (0);
+
+	return req;
+}
+
+
+static Boolean eap_wps_check(struct eap_sm *sm, void *priv,
+							 u8 *resp, size_t resp_len)
+{
+	Boolean ret = TRUE;
+	struct eap_hdr *req_hdr = (struct eap_hdr *)resp;
+	struct eap_format *req_fmt;
+	u16 msg_len;
+
+	do {
+		req_fmt = (struct eap_format *)(req_hdr + 1);
+		if (be_to_host16(req_hdr->length) != resp_len) {
+			break;
+		} else if ((EAP_TYPE_EXPANDED != req_fmt->type) ||
+				   (0 != os_memcmp(req_fmt->vendor_id, EAP_VENDOR_ID_WPS,
+				                sizeof(req_fmt->vendor_id))) ||
+				   (0 != os_memcmp(req_fmt->vendor_type, EAP_VENDOR_TYPE_WPS,
+				                sizeof(req_fmt->vendor_type)))) {
+			break;
+		}
+
+		if (req_fmt->flags & EAP_FLAG_LF) {
+			msg_len = req_hdr->length - (sizeof(*req_hdr) + sizeof(*req_fmt));
+			if (msg_len != WPA_GET_BE16((u8 *)req_fmt + 1)) {
+				break;
+			}
+		}
+
+		ret = FALSE;
+	} while (0);
+
+	return ret;
+}
+
+
+static void eap_wps_process(struct eap_sm *sm, void *priv,
+							u8 *resp, size_t resp_len)
+{
+	int ret = -1;
+	struct eap_wps_data *data = (struct eap_wps_data *)priv;
+	struct eap_hdr *req_hdr = (struct eap_hdr *)resp;
+	struct eap_format *req_fmt;
+	const u8 *identity;
+	size_t identity_len;
+	u8 *raw;
+	u16 msg_len;
+
+	do {
+		req_fmt = (struct eap_format *)(req_hdr + 1);
+
+		if (req_fmt->flags & EAP_FLAG_LF) {
+			raw = (u8 *)(req_fmt + 1);
+			msg_len = req_hdr->length - (sizeof(*req_hdr) + sizeof(*req_fmt));
+			if (msg_len != WPA_GET_BE16((u8 *)req_fmt + 1)) {
+				break;
+			}
+		} else {
+			raw = (u8 *)(req_fmt + 1);
+			msg_len = resp_len - (sizeof(*req_hdr) + sizeof(*req_fmt));
+		}
+
+		if (data->fragment) {
+			data->fragment = 0;
+			data->rcvMsg = (u8 *)os_realloc(data->rcvMsg, data->rcvMsgLen + msg_len);
+			if (data->rcvMsg) {
+				os_memcpy(data->rcvMsg + data->rcvMsgLen, raw, msg_len);
+				data->rcvMsgLen += msg_len;
+			}
+		} else {
+			if (data->rcvMsg)
+				os_free(data->rcvMsg);
+			data->rcvMsg = (u8 *)os_malloc(msg_len);
+			if (data->rcvMsg) {
+				os_memcpy(data->rcvMsg, raw, msg_len);
+				data->rcvMsgLen = msg_len;
+			}
+		}
+
+		if (!data->rcvMsg) {
+			/* Memory allocation Error */
+			data->rcvMsgLen = 0;
+			break;
+		}
+
+		if (req_fmt->flags & EAP_FLAG_MF) {
+			data->fragment = 1;
+			ret = 0;
+			break;
+		}
+
+		identity = sm->identity;
+		identity_len = sm->identity_len;
+		if (0 == os_strncmp((char *)identity, WPS_IDENTITY_REGISTRAR, os_strlen(WPS_IDENTITY_REGISTRAR)))
+			data->interface = ENROLLEE;
+		else if (0 == os_strncmp((char *)identity, WPS_IDENTITY_ENROLLEE, os_strlen(WPS_IDENTITY_ENROLLEE)))
+			data->interface = REGISTRAR;
+		else {
+			/* Error */
+			break;
+		}
+
+		switch (data->interface) {
+		case REGISTRAR:
+			ret = eap_wps_process_registrar(sm, data,
+											req_hdr->identifier,
+											req_fmt->op_code);
+			break;
+		case ENROLLEE:
+			ret = eap_wps_process_enrollee(sm, data,
+										   req_hdr->identifier,
+										   req_fmt->op_code);
+			break;
+		default:
+			break;
+		}
+	} while (0);
+
+	if (ret)
+		data->state = NACK;
+
+	return;
+}
+
+
+static Boolean eap_wps_is_done(struct eap_sm *sm, void *priv)
+{
+	struct eap_wps_data *data = priv;
+	return data->state == FAILURE;
+}
+
+
+static Boolean eap_wps_is_success(struct eap_sm *sm, void *priv)
+{
+	return FALSE;
+}
+
+
+int eap_server_wps_register(void)
+{
+	struct eap_method *eap;
+	int ret;
+
+	eap = eap_server_method_alloc(EAP_SERVER_METHOD_INTERFACE_VERSION,
+				    WPA_GET_BE24(EAP_VENDOR_ID_WPS), WPA_GET_BE32(EAP_VENDOR_TYPE_WPS), "WPS");
+	if (eap == NULL)
+		return -1;
+
+	eap->init = eap_wps_init;
+	eap->reset = eap_wps_reset;
+	eap->buildReq = eap_wps_build_req;
+	eap->check = eap_wps_check;
+	eap->process = eap_wps_process;
+	eap->isDone = eap_wps_is_done;
+	eap->isSuccess = eap_wps_is_success;
+
+	ret = eap_server_method_register(eap);
+	if (ret)
+		eap_server_method_free(eap);
+	return ret;
+}
+
+
+int eap_wps_set_ie(struct hostapd_data *hapd)
+{
+	int ret = -1;
+	u8 *iebuf = 0;
+	size_t iebuflen;
+
+	do {
+		if (!hapd)
+			break;
+
+		/* Create WPS Beacon IE */
+		if (wps_config_create_beacon_ie(hapd, &iebuf, &iebuflen)) {
+			break;
+		}
+		/* Set WPS Beacon IE */
+		if (hostapd_set_wps_beacon_ie(hapd, iebuf, iebuflen)) {
+			break;
+		}
+		os_free(iebuf);
+		iebuf = 0;
+		/* Create WPS ProbeResp IE */
+		if (wps_config_create_probe_resp_ie(hapd, &iebuf, &iebuflen)) {
+			break;
+		}
+		/* Set WPS ProbeResp IE */
+		if (hostapd_set_wps_probe_resp_ie(hapd, iebuf, iebuflen)) {
+			break;
+		}
+		os_free(iebuf);
+		iebuf = 0;
+		/* Create WPS AssocResp IE */
+		if (wps_config_create_assoc_resp_ie(hapd, &iebuf, &iebuflen)) {
+			break;
+		}
+		/* Set WPS AssocResp IE */
+		if (hostapd_set_wps_assoc_resp_ie(hapd, iebuf, iebuflen)) {
+			break;
+		}
+
+		ret = 0;
+	} while (0);
+
+	if (iebuf)
+		os_free(iebuf);
+
+	return ret;
+}
+
+
+static int eap_wps_set_pbc_ie(struct hostapd_data *hapd, struct wps_config *wps, int enabled)
+{
+	int ret = -1;
+
+	do {
+		if (!hapd || !wps)
+			break;
+
+		if (enabled) {
+			os_memset(wps->pub_key, 0, sizeof(wps->pub_key));
+			wps_config_free_dh(&wps->dh_secret);
+			wps->set_pub_key = 0;
+
+			wps->dev_pwd_id = WPS_DEVICEPWDID_PUSH_BTN;
+			os_memcpy(wps->dev_pwd, "00000000", 8);
+			wps->dev_pwd_len = 8;
+
+			wps->selreg = 1;
+			wps->selreg_config_methods = WPS_CONFMET_PBC;
+		} else {
+			wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+			os_memset(wps->dev_pwd, 0, sizeof(wps->dev_pwd));
+			wps->dev_pwd_len = 0;
+
+			wps->selreg = 0;
+			wps->selreg_config_methods = 0;
+		}
+
+		if (eap_wps_set_ie(hapd))
+			break;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
+static void eap_wps_pbc_timer_tick(void *ctx, void *conf)
+{
+	struct wps_config *wps = conf;
+	struct os_time now;
+	int timeout = 0;
+
+	if(!wps->enabled_pbc) {
+		os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+		return;
+	}
+
+	os_get_time(&now);
+	if (now.sec > wps->end_pbc_time.sec)
+		timeout = 1;
+	else if ((now.sec == wps->end_pbc_time.sec) &&
+			 (now.usec >= wps->end_pbc_time.usec))
+		timeout = 1;
+
+	if (timeout) {
+		wps->enabled_pbc = 0;
+		os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+		wps->dev_pwd_id = WPS_DEVICEPWDID_DEFAULT;
+
+		(void)eap_wps_set_pbc_ie(ctx, conf, 0);
+
+		hostapd_msg(ctx, MSG_INFO, "WPS-PBC timeout");
+	} else
+		eloop_register_timeout(EAP_WPS_PBC_PERIOD_SEC, EAP_WPS_PBC_PERIOD_USEC, eap_wps_pbc_timer_tick, ctx, conf);
+}
+
+
+int eap_wps_enabled_pbc(struct hostapd_data *hapd, struct wps_config *wps, int enabled)
+{
+	int ret = -1;
+
+	do {
+		if (enabled) {
+			(void)os_get_time(&wps->end_pbc_time);
+			wps->end_pbc_time.sec += EAP_WPS_PBC_TIMEOUT_SEC;
+			wps->end_pbc_time.usec += EAP_WPS_PBC_TIMEOUT_USEC;
+
+			if (!wps->enabled_pbc) {
+				if (eap_wps_set_pbc_ie(hapd, wps, enabled))
+					break;
+
+				hostapd_msg(hapd, MSG_INFO, "WPS-PBC start");
+				eloop_register_timeout(EAP_WPS_PBC_PERIOD_SEC, EAP_WPS_PBC_PERIOD_USEC, eap_wps_pbc_timer_tick, hapd, wps);
+			} else
+				hostapd_msg(hapd, MSG_INFO, "WPS-PBC restart");
+		} else {
+			os_memset(&wps->end_pbc_time, 0, sizeof(wps->end_pbc_time));
+
+			if (wps->enabled_pbc) {
+				if (eap_wps_set_pbc_ie(hapd, wps, enabled))
+					break;
+
+				hostapd_msg(hapd, MSG_INFO, "WPS-PBC stop");
+				eloop_cancel_timeout(eap_wps_pbc_timer_tick, hapd, wps);
+			}
+		}
+		wps->enabled_pbc = enabled;
+
+		ret = 0;
+	} while (0);
+
+	return ret;
+}
+
+
Index: wps_opt_upnp.h
===================================================================
--- wps_opt_upnp.h	(revision 0)
+++ wps_opt_upnp.h	(revision 2)
@@ -0,0 +1,57 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: wps_opt_upnp.h
+//  Description: EAP-WPS UPnP option source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef WPS_OPT_UPNP_H
+#define WPS_OPT_UPNP_H
+
+struct wps_opt_upnp_sm;
+struct eap_wps_data;
+
+struct wps_opt_upnp_sm_ctx {
+	void *ctx;		/* pointer to arbitrary upper level context */
+	void *msg_ctx;
+
+	struct hostapd_config *(*get_conf)(void *ctx);
+};
+
+struct wps_opt_upnp_sm *wps_opt_upnp_sm_init(struct wps_opt_upnp_sm_ctx *ctx);
+void wps_opt_upnp_sm_deinit(struct wps_opt_upnp_sm *sm);
+
+u8 *wps_opt_upnp_received_message(struct wps_opt_upnp_sm *sm,
+								  struct eap_wps_data *data,
+								  size_t *req_len);
+int wps_opt_upnp_send_wlan_event(struct wps_opt_upnp_sm *sm,
+								 struct eap_wps_data *data,
+								 int ev_type);
+#endif /* WPS_OPT_UPNP_H */
Index: eap_wps.h
===================================================================
--- eap_wps.h	(revision 0)
+++ eap_wps.h	(revision 2)
@@ -0,0 +1,223 @@
+/**************************************************************************
+//
+//  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.
+//
+//  File Name: eap_wps.h
+//  Description: EAP-WPS main source header
+//
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in
+//       the documentation and/or other materials provided with the
+//       distribution.
+//     * Neither the name of Sony Corporation nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+//   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+//   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**************************************************************************/
+
+#ifndef EAP_WPS_H
+#define EAP_WPS_H
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+struct eap_wps_target_info {
+	u8		version;
+	u8		uuid[SIZE_UUID];
+	int		uuid_set;
+
+	u8		mac[SIZE_MAC_ADDR];
+	int		mac_set;
+
+	u16		auth_type_flags;
+	u16		encr_type_flags;
+	u8		conn_type_flags;
+	u16		config_methods;
+	u8		wps_state;
+	u8		*manufacturer;
+	size_t	manufacturer_len;
+	u8		*model_name;
+	size_t	model_name_len;
+	u8		*model_number;
+	size_t	model_number_len;
+	u8		*serial_number;
+	size_t	serial_number_len;
+	u8		prim_dev_type[SIZE_8_BYTES];
+	u8		*dev_name;
+	size_t	dev_name_len;
+	u8		rf_bands;
+	u16		assoc_state;
+	u16		config_error;
+	u32		os_version;
+
+	u8		nonce[SIZE_NONCE];
+	u8		pubKey[SIZE_PUB_KEY];
+	int		pubKey_set;
+	u16		dev_pwd_id;
+	u8		hash1[SIZE_256_BITS];
+	u8		hash2[SIZE_256_BITS];
+
+	u8		*config;
+	size_t	config_len;
+};
+
+struct eap_wps_data {
+	enum {START, M1, M2, M2D1, M2D2, M3, M4, M5, M6, M7, M8, DONE, ACK, NACK, FAILURE} state;
+	enum {NONE, REGISTRAR, ENROLLEE} interface;
+
+	u8		*rcvMsg;
+	u32		rcvMsgLen;
+	Boolean	fragment;
+
+	u8		*sndMsg;
+	u32		sndMsgLen;
+
+	u16		dev_pwd_id;
+	u8		dev_pwd[SIZE_64_BYTES];
+	u16		dev_pwd_len;
+
+	u16		assoc_state;
+	u16		config_error;
+
+	u8		nonce[SIZE_NONCE];
+	u8		pubKey[SIZE_PUB_KEY];
+	int		preset_pubKey;
+
+	void	*dh_secret;
+
+	u8		authKey[SIZE_256_BITS];
+	u8		keyWrapKey[SIZE_128_BITS];
+	u8		emsk[SIZE_256_BITS];
+
+	u8		snonce1[SIZE_128_BITS];
+	u8		snonce2[SIZE_128_BITS];
+	u8		psk1[SIZE_128_BITS];
+	u8		psk2[SIZE_128_BITS];
+	u8		hash1[SIZE_256_BITS];
+	u8		hash2[SIZE_256_BITS];
+
+	enum wps_reg_mode reg_mode;
+	u8		*config;
+	size_t	config_len;
+
+	struct eap_wps_target_info *target;
+};
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+#define EAP_WPS_PBC_TIMEOUT_SEC		120
+#define EAP_WPS_PBC_TIMEOUT_USEC	0
+
+int eap_wps_config_init_data(struct hostapd_data *hapd,
+							 struct wps_config *conf,
+							 struct eap_wps_data *data);
+void eap_wps_config_deinit_data(struct eap_wps_data *data);
+
+int eap_wps_free_dh(void **dh);
+int eap_wps_generate_sha256hash(u8 *inbuf, int inbuf_len, u8 *outbuf);
+int eap_wps_generate_public_key(void **dh_secret, u8 *public_key);
+int eap_wps_generate_device_password_id(u16 *dev_pwd_id);
+int eap_wps_generate_device_password(u8 *dev_pwd, int dev_pwd_len);
+
+int eap_wps_enabled_pbc(struct hostapd_data *hapd, struct wps_config * wps, int enabled);
+
+int eap_wps_device_password_validation(const u8 *pwd, const int len);
+
+int eap_wps_set_ie(struct hostapd_data *hapd);
+
+int eap_wps_config_get_ssid_configuration(struct hostapd_data *hapd,
+										  struct wps_config *conf,
+										  struct eap_wps_data *data,
+										  u8 **config,
+										  size_t *config_len,
+										  Boolean wrap_credential);
+int eap_wps_config_get_auto_configuration(struct hostapd_data *hapd,
+										  struct wps_config *conf,
+										  struct eap_wps_data *data,
+										  u8 **config,
+										  size_t *config_len,
+										  Boolean wrap_credential);
+int eap_wps_config_set_ssid_configuration(struct hostapd_data *hapd,
+										  struct wps_config *conf,
+										  struct eap_wps_data *data,
+										  u8 *raw_data, size_t raw_data_len,
+										  Boolean wrap_credential,
+										  char *out_filename);
+
+u8 *eap_wps_config_build_message_M1(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M1(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M2(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+u8 *eap_wps_config_build_message_M2D(struct wps_config *conf,
+									 struct eap_wps_data *data,
+									 size_t *msg_len);
+int eap_wps_config_process_message_M2(struct wps_config *conf,
+									  struct eap_wps_data *data,
+									  Boolean *with_config);
+int eap_wps_config_process_message_M2D(struct wps_config *conf,
+									   struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M3(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M3(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M4(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M4(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M5(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M5(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M6(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M6(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M7(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M7(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_M8(struct wps_config *conf,
+									struct eap_wps_data *data,
+									size_t *msg_len);
+int eap_wps_config_process_message_M8(struct wps_config *conf,
+									  struct eap_wps_data *data);
+u8 *eap_wps_config_build_message_special(struct wps_config *conf,
+										 struct eap_wps_data *data,
+										 u8 msg_type,
+										 u8 *e_nonce, u8 *r_nonce,
+										 size_t *msg_len);
+int eap_wps_config_process_message_special(struct wps_config *conf,
+										   struct eap_wps_data *data,
+										   u8 msg_type,
+										   u8 *e_nonce, u8 *r_nonce);
+
+#endif /* EAP_WPS_H */
Index: defconfig
===================================================================
--- defconfig	(revision 1)
+++ defconfig	(revision 2)
@@ -10,14 +10,15 @@
 # to override previous values of the variables.
 
 # Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
+#CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for wired authenticator
 #CONFIG_DRIVER_WIRED=y
 
 # Driver interface for madwifi driver
-#CONFIG_DRIVER_MADWIFI=y
+CONFIG_DRIVER_MADWIFI=y
 #CFLAGS += -I../head # change to reflect local setup; directory for madwifi src
+CFLAGS += -I/usr/src/redhat/BUILD/madwifi-0.9.3.1
 
 # Driver interface for Prism54 driver
 #CONFIG_DRIVER_PRISM54=y
@@ -102,3 +103,20 @@
 
 # Build IPv6 support for RADIUS operations
 CONFIG_IPV6=y
+
+# EAP-WPS for the integrated EAP server
+CONFIG_EAP_WPS=y
+CONFIG_WPS_OPT_UPNP=y
+LIBS += /usr/lib/libupnp.so
+
+CONFIG_WPS_OPT_NFC=y
+CFLAGS += -I/usr/src/redhat/BUILD/WpsNfcLibrary
+LIBS += /usr/lib/wpsnfc.dll /usr/lib/libnfc_mapping_pn53x.dll
+
+# use Intel-SDK for WPS
+#CONFIG_USE_INTEL_SDK=y
+#DIFF_PORT_FROM_SUPPS=y
+
+# including bugfix
+MODIFIED_BY_SONY=y
+
Index: eapol_sm.c
===================================================================
--- eapol_sm.c	(revision 1)
+++ eapol_sm.c	(revision 2)
@@ -1241,6 +1241,26 @@
 }
 
 
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+static const struct hostapd_data *
+eapol_sm_get_hostapd_data(void *ctx)
+{
+	struct eapol_state_machine *sm = ctx;
+	return sm->hapd;
+}
+
+
+static const struct wps_config *
+eapol_sm_get_wps_config(void *ctx)
+{
+	struct eapol_state_machine *sm = ctx;
+	return sm->hapd->iconf->wps;
+}
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
+
+
 static struct eapol_callbacks eapol_cb =
 {
 	.get_bool = eapol_sm_get_bool,
@@ -1249,6 +1269,12 @@
 	.set_eapKeyData = eapol_sm_set_eapKeyData,
 	.get_eap_user = eapol_sm_get_eap_user,
 	.get_eap_req_id_text = eapol_sm_get_eap_req_id_text,
+#ifdef EAP_WPS
+#ifndef USE_INTEL_SDK
+	.get_hostapd_data = eapol_sm_get_hostapd_data,
+	.get_wps_config = eapol_sm_get_wps_config,
+#endif /* USE_INTEL_SDK */
+#endif /* EAP_WPS */
 };
 
 
Index: driver.h
===================================================================
--- driver.h	(revision 1)
+++ driver.h	(revision 2)
@@ -141,6 +141,12 @@
 	 * this handler will be called after initial setup has been completed.
 	 */
 	int (*commit)(void *priv);
+
+#ifdef EAP_WPS
+	int (*set_wps_beacon_ie)(void *priv, u8 *iebuf, int iebuflen);
+	int (*set_wps_probe_resp_ie)(void *priv, u8 *iebuf, int iebuflen);
+	int (*set_wps_assoc_resp_ie)(void *priv, u8 *iebuf, int iebuflen);
+#endif /* EAP_WPS */
 };
 
 static inline int
@@ -653,4 +659,33 @@
 	return hapd->driver->commit(hapd->driver);
 }
 
+#ifdef EAP_WPS
+static inline int
+hostapd_set_wps_beacon_ie(struct hostapd_data *hapd, u8 *iebuf, 
+					int iebuflen)
+{
+	if (hapd->driver == NULL || hapd->driver->set_wps_beacon_ie == NULL)
+		return 0;
+	return hapd->driver->set_wps_beacon_ie(hapd->driver, iebuf, iebuflen);
+}
+
+static inline int
+hostapd_set_wps_probe_resp_ie(struct hostapd_data *hapd, u8 *iebuf, 
+					int iebuflen)
+{
+	if (hapd->driver == NULL || hapd->driver->set_wps_probe_resp_ie == NULL)
+		return 0;
+	return hapd->driver->set_wps_probe_resp_ie(hapd->driver, iebuf, iebuflen);
+}
+
+static inline int
+hostapd_set_wps_assoc_resp_ie(struct hostapd_data *hapd, u8 *iebuf, 
+					int iebuflen)
+{
+	if (hapd->driver == NULL || hapd->driver->set_wps_assoc_resp_ie == NULL)
+		return 0;
+	return hapd->driver->set_wps_assoc_resp_ie(hapd->driver, iebuf, iebuflen);
+}
+#endif /* EAP_WPS */
+
 #endif /* DRIVER_H */
Index: eapol_sm.h
===================================================================
--- eapol_sm.h	(revision 1)
+++ eapol_sm.h	(revision 2)
@@ -37,6 +37,14 @@
 	size_t count;
 };
 
+#ifdef EAP_WPS
+enum enm_wps_state {
+	WPS_STATE_NONE = 0,
+	WPS_STATE_PREPARED,
+	WPS_STATE_STARTED,
+};
+#endif /* EAP_WPS */
+
 struct eapol_state_machine {
 	/* timers */
 	int aWhile;
@@ -195,6 +203,10 @@
 	 * passing these to every function */
 	struct hostapd_data *hapd;
 	struct sta_info *sta;
+
+#ifdef EAP_WPS
+	enum enm_wps_state wps_state;
+#endif /* EAP_WPS */
 };
 
 
Index: ieee802_1x.c
===================================================================
--- ieee802_1x.c	(revision 1)
+++ ieee802_1x.c	(revision 2)
@@ -819,8 +819,10 @@
 	u16 datalen;
 	struct rsn_pmksa_cache_entry *pmksa;
 
+#ifndef EAP_WPS
 	if (!hapd->conf->ieee802_1x && !hapd->conf->wpa)
 		return;
+#endif /* EAP_WPS */
 
 	HOSTAPD_DEBUG(HOSTAPD_DEBUG_MINIMAL,
 		      "IEEE 802.1X: %lu bytes from " MACSTR "\n",
@@ -870,14 +872,22 @@
 		return;
 	}
 
+#ifndef EAP_WPS
 	if (!hapd->conf->ieee802_1x ||
 	    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_PSK)
 		return;
+#else /* EAP_WPS */
+	if (wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_PSK)
+		return;
+#endif /* EAP_WPS */
 
 	if (!sta->eapol_sm) {
 		sta->eapol_sm = eapol_sm_alloc(hapd, sta);
 		if (!sta->eapol_sm)
 			return;
+#ifdef EAP_WPS
+		sta->eapol_sm->wps_state = WPS_STATE_PREPARED;
+#endif /* EAP_WPS */
 	}
 
 	/* since we support version 1, we can ignore version field and proceed
@@ -904,6 +914,14 @@
 				       "STA sent EAPOL-Start");
 			wpa_auth_sta_clear_pmksa(sta->wpa_sm, pmksa);
 		}
+
+#ifdef EAP_WPS
+		if (sta->eapol_sm->wps_state == WPS_STATE_PREPARED) {
+			sta->eapol_sm->wps_state = WPS_STATE_STARTED;
+			ieee802_1x_notify_port_enabled(sta->eapol_sm, 1);
+		}
+#endif /* EAP_WPS */
+
 		sta->eapol_sm->eapolStart = TRUE;
 		sta->eapol_sm->dot1xAuthEapolStartFramesRx++;
 		wpa_auth_sm_event(sta->wpa_sm, WPA_REAUTH_EAPOL);
@@ -1653,6 +1671,12 @@
 	    hostapd_set_ieee8021x(hapd->conf->iface, hapd, 1))
 		return -1;
 
+#ifdef EAP_WPS
+	if (!hapd->conf->ieee802_1x && !hapd->conf->wpa &&
+	    hostapd_set_ieee8021x(hapd->conf->iface, hapd, 0))
+		return -1;
+#endif /* EAP_WPS */
+
 	if (radius_client_register(hapd->radius, RADIUS_AUTH,
 				   ieee802_1x_receive_auth, hapd))
 		return -1;
